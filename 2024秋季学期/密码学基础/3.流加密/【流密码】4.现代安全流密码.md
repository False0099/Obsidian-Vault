## 定义：
设 $(E,D)$，是定义在 $(K,M,C)$ 上的一个流密码算法，称输出序列的周期达到最大值2n 的非线性移位寄存器序列为M序列。

则我们的加密通过下面的方法进行：
$E(k,m):G(k)\oplus m=c$
$D(k,c):G(k)\oplus c=m$
其中我们有：$G(k)=\{0,1\}^{s}\to\{0,1\}^{M}$,也就是我们的随机数生成器。
	
非线性移位寄存器反馈函数的数量极大 GF(2)上的 n 级移位寄存器共有 2n 个状态，因此共有种不同的反馈函数，其中线性反馈函数只有 2n-1种，其余均为非线性。
## A5/1, A5/2
A5 / 1是用于在 GSM 蜂窝电话标准中提供无线通信隐私的流密码。它是为 GSM 使用指定的七种算法之一。最初是保密的，但通过泄漏和逆向工程成为公众的知识。

A5/1算法使用**3个线性反馈移位寄存器**，简称为 LFSR。三个寄存器的分别为19位、22位、23位。这里要使用三个共包含64位二进制的线性反馈移位寄存器，这个设计绝非偶然。
 
A5/1算法的密钥 K 也是64位。该密钥用于三个线性反馈移位寄存器的初始填充，也就是说，该**密钥用于充当三个寄存器的初始值**。这三个寄存器用密钥填充之后，就可以开始生成密钥流了。

A5 / 1流密码使用三个 LFSR。如果一个寄存器的时钟位（橙色）与其他两个寄存器中的一个或两个的时钟位一致，则该寄存器会被时钟控制。

A5 / 1的每个回合步骤可以拆分为：取KEY，反馈多项式（Feedback Polynomial），位移

1. 取Key： 取三个寄存器的最后一位，也就是19位、22位、23位，进行XOR操作，得到的结果为这一轮Key的一位。
2. 反馈多项式（Feedback Polynomial）： LFSR 进行位移的前置操作，具体可以分成两步：判定是否需要进行位移，判定新的充填的值。判定是否需要进行位移： 这里使用的是择多原则，三个寄存器中选择三个钟控信号，19位中的第8位，22位，23位中皆为第10位，两种二进制0,1，必定有0或1数量居多，居多的寄存器需要进行位移操作。判定新的充填的值： 这里需要用到反馈多项式：
![[Pasted image 20240930112909.png]]

3. 位移：三个寄存器，由上一步的判定后进行位移，空出第0位用于充填反馈多项式得到的值。

## Salsa 20 算法
Salsa20是一种流式对称加密算法，类似于 Chacha20，算法性能相比 AES 能够快3倍以上。Salsa20算法通过将32 Byte 的 key 和8 Byte 的随机数 nonce 扩展为2^70 Byte 的随机字节流，通过随机字节流和异或操作实现加解密，因此 Salsa20算法中随机字节流的生成为关键所在。

### 随机字节生成：
Salsa20算法生成随机字节流时，**一次生成一个64字节的 block**，每一个 block 是通过将 key、nonce 和 block number 以及部分常量组成64字节的 input，通过核函数，输出64字节的 output。最终**多个 block 组成长度为2^70的随机字节流**，在生成过程中，每个 block 相互独立。

流程：
1. 我们定义我们的输入如下：
- 4字节的常量0x61707865
- key的前16字节
- 4字节的常量0x3320646e
- 8字节的随机数nonce
- 8字节的block-counter
- 4字节的常量0x79622d32
- key的剩余16字节
- 4字节的常量0x6b206574

最终64字节（16 words）组成一个 $4*4$ 的矩阵。例如，对于 key (1, 2, 3, 4, 5, . . . , 32), nonce (3, 1, 4, 1, 5, 9, 2, 6), 以及 block 7的初始矩阵为:

也就是我们会把我们的原来的内容按照下面的方法进行排列：
```
std::array<uint32_t, 16> state = {

        0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,

        key[0], key[1], key[2], key[3],

        nonce[0], nonce[1], 0, 0,

        key[4], key[5], key[6], key[7]

    };
```


```
0x61707865, 0x04030201, 0x08070605, 0x0c0b0a09,
0x100f0e0d, 0x3320646e, 0x01040103, 0x06020905,
0x00000007, 0x00000000, 0x79622d32, 0x14131211,
0x18171615, 0x1c1b1a19, 0x201f1e1d, 0x6b206574.
```

第二步：我们把我们的对应的内容进行对应的处理：我们将我们的对应位置按照我们的 salsa20 算法进行对应的处理：
```
 //x[i]^=(x[i-4]+x[i+8])<<i

  

        x[ 4] ^= (x[ 0] + x[12]) << 7  | (x[ 0] + x[12]) >> (32 - 7);

        x[ 8] ^= (x[ 4] + x[ 0]) << 9  | (x[ 4] + x[ 0]) >> (32 - 9);

        x[12] ^= (x[ 8] + x[ 4]) << 13 | (x[ 8] + x[ 4]) >> (32 - 13);

        x[ 0] ^= (x[12] + x[ 8]) << 18 | (x[12] + x[ 8]) >> (32 - 18);

  

        x[ 9] ^= (x[ 5] + x[ 1]) << 7  | (x[ 5] + x[ 1]) >> (32 - 7);

        x[13] ^= (x[ 9] + x[ 5]) << 9  | (x[ 9] + x[ 5]) >> (32 - 9);

        x[ 1] ^= (x[13] + x[ 9]) << 13 | (x[13] + x[ 9]) >> (32 - 13);

        x[ 5] ^= (x[ 1] + x[13]) << 18 | (x[ 1] + x[13]) >> (32 - 18);

  

        x[14] ^= (x[10] + x[ 6]) << 7  | (x[10] + x[ 6]) >> (32 - 7);

        x[ 2] ^= (x[14] + x[10]) << 9  | (x[14] + x[10]) >> (32 - 9);

        x[ 6] ^= (x[ 2] + x[14]) << 13 | (x[ 2] + x[14]) >> (32 - 13);

        x[10] ^= (x[ 6] + x[ 2]) << 18 | (x[ 6] + x[ 2]) >> (32 - 18);
        x[ 3] ^= (x[15] + x[11]) << 7  | (x[15] + x[11]) >> (32 - 7);
        x[ 7] ^= (x[ 3] + x[15]) << 9  | (x[ 3] + x[15]) >> (32 - 9);
        x[11] ^= (x[ 7] + x[ 3]) << 13 | (x[ 7] + x[ 3]) >> (32 - 13);
        x[15] ^= (x[11] + x[ 7]) << 18 | (x[11] + x[ 7]) >> (32 - 18);
        x[ 1] ^= (x[ 0] + x[ 3]) << 7  | (x[ 0] + x[ 3]) >> (32 - 7);
        x[ 2] ^= (x[ 1] + x[ 0]) << 9  | (x[ 1] + x[ 0]) >> (32 - 9);
        x[ 3] ^= (x[ 2] + x[ 1]) << 13 | (x[ 2] + x[ 1]) >> (32 - 13);
        x[ 0] ^= (x[ 3] + x[ 2]) << 18 | (x[ 3] + x[ 2]) >> (32 - 18);
        x[ 6] ^= (x[ 5] + x[ 4]) << 7  | (x[ 5] + x[ 4]) >> (32 - 7);
        x[ 7] ^= (x[ 6] + x[ 5]) << 9  | (x[ 6] + x[ 5]) >> (32 - 9);
        x[ 4] ^= (x[ 7] + x[ 6]) << 13 | (x[ 7] + x[ 6]) >> (32 - 13);
        x[ 5] ^= (x[ 4] + x[ 7]) << 18 | (x[ 4] + x[ 7]) >> (32 - 18);
        x[11] ^= (x[10] + x[ 9]) << 7  | (x[10] + x[ 9]) >> (32 - 7);
        x[ 8] ^= (x[11] + x[10]) << 9  | (x[11] + x[10]) >> (32 - 9);
        x[ 9] ^= (x[ 8] + x[11]) << 13 | (x[ 8] + x[11]) >> (32 - 13);
        x[10] ^= (x[ 9] + x[ 8]) << 18 | (x[ 9] + x[ 8]) >> (32 - 18);
        x[12] ^= (x[15] + x[14]) << 7  | (x[15] + x[14]) >> (32 - 7);
        x[13] ^= (x[12] + x[15]) << 9  | (x[12] + x[15]) >> (32 - 9);
        x[14] ^= (x[13] + x[12]) << 13 | (x[13] + x[12]) >> (32 - 13);
        x[15] ^= (x[14] + x[13]) << 18 | (x[14] + x[13]) >> (32 - 18);
```

第三步：将我们的处理过后的结果和我们的原来的结果进行直接的加法操作，就能够得到我们的最终的结果。作为我们的最终的加密结果（**针对一个 64bit 的块**）。
```cpp
 for (int i = 0; i < 16; ++i) {

        state[i] += x[i];

    }
```

第四步：我们将我们的所有长度为 64 的块都去进行我们的对应的异或操作。最后就能够得到我们的整体的加密结果。
```cpp
 for (size_t i = 0; i < length; i += 64) {

        salsa20_core(state);

  

        for (int j = 0; j < 16; ++j) {

            keystream[j * 4 + 0] = (state[j] >> 0) & 0xff;

            keystream[j * 4 + 1] = (state[j] >> 8) & 0xff;

            keystream[j * 4 + 2] = (state[j] >> 16) & 0xff;

            keystream[j * 4 + 3] = (state[j] >> 24) & 0xff;

        }

  

        for (size_t j = 0; j < 64 && i + j < length; ++j) {

            output[i + j] = data[i + j] ^ keystream[j];

        }

        state[8]++;

        if (state[8] == 0) {

            state[9]++;

        }

    }
```



## TRIVIUM 算法：
下面我们详细介绍 Trivium 的算法细节。这里再次提醒，**Trivium 实际上是个数字电路**，由 3 个 Non-Linear Feedback Shift Register (NLFSR) 连在一起的电路。

首先，我们有一个 Trivium 机器，他的内部状态由 288 个 bit 决定 $S_1\ldots S_{288}$,确定了这 288个 bit, 我们就可以复制一个 Trivium 机器，输出一模一样的 Keystream ( $Z_i$ )用来加密。

下面就是一组公式，决定了怎么计算 $Z_i=T_1\oplus T_2\oplus T_3$,其中 $Z_i$ 就是输出的 Keystream。如果把它当作公式和算法，会很难理解 Trivium, 不知道这公式都是啥意思，但是把它当作一个电路来看，就豁然开朗。

![[Pasted image 20240930142605.png]]

### 计算流程：
设 TRIVIUM 内部状态为 S1...S288，初始化密钥为 K1...K80，初始化向量为 IV1...IV80，则初始化过程为
1. 随机生成（或者人工生成我们的密钥），随机生成我们的初始化向量。要求我们的向量和密钥都满足长度为 80 bit,（可以用 C++中的 bitset 来优雅的实现）
2. 将我们的内部状态中的 $[1-80]$ 设置为我们的密钥，$[93-173]$ 设置为我们的初始化向量。$[81-92]$ 设置为 0，其余的设置为 1
3. 按照下面的规则，将我们的结果重新进行赋值：

```cpp
for(iter = 0; iter < (4 * 288); iter++ ){

        tmp1 = (this->state[65] + this->state[90] * this->state[91] + this->state[92] + this->state[170]) % 2;

        tmp2 = (this->state[161] + this->state[174] * this->state[175] + this->state[176] + this->state[263]) % 2;

        tmp3 = (this->state[242] + this->state[285] * this->state[286] + this->state[287] + this->state[68]) % 2;

        for(iter2 = 92; iter2 > 0; iter2--) {

            this->state[iter2] = this->state[iter2 - 1];

        }

        this->state[0] = tmp3;

  

        for(iter2 = 176; iter2 > 93; iter2--) {

            this->state[iter2] = this->state[iter2 - 1];

        }

        this->state[93] = tmp1;

  

        for(iter2 = 287; iter2 > 177; iter2--) {

            this->state[iter2] = this->state[iter2 - 1];

        }

        this->state[177] = tmp2;

    }
```

我们的加密过程如下所示：
1. 