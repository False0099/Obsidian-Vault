## 一次一密
所以叫一次一密好了，那么我们用数学的偏这个我们用这个，这个我们用我们的标准的加密解密模型来描述它。One time pad 就是这样的，你看它的这个呢，每一个小 $S_i$，那就是一个密钥的某一个密钥流当中的某一个比特，单个的比特对不对？那么 $X_i$ 呢，在我们的这个中，总是 $X_i$ 代表铭文的第 $i$ 个比特就代表流当中的，加个比特代表密文的第 $i$ 个比特。那也就是说你看一次性密码本，它加密很简单。他的加密就是我们今天，我们说实际上用用它来加密短小的消息没问题。暗示用它来加密大量，今天我们的这个是要使用的密码算法，一定是要加密任意大的数据。面的加密，那它就存在问题了，我们来看存在什么问题，

第一，One time pad，几乎所有的应用而言**不方便**，你那个乱码本，你想你这个你要加你要这个苏克格勃苏联的这个。特工特个博，他要。他如果要加很多，要准备一大本的。你是乱码本嘛，你打的很厚的。是吧，如果我说哪一天用完了怎么办？它能够达到完美安，完美安全呢，无条件安全，但是它并不实用。Impractical。

实际上**对于所有的无条件安全的加密算法，密钥都至少要跟铭文一样长**，这个地方是因为我就稍微提一下，因为我们这个是属于初学者的课程。实际上呢，我们的香农已经证明了，他在 1949 年发表的一篇论文保密通信的数学理论当中，这个我们的信息认知部香农已经证明。已经证明了。他证明了就是完美安全或者无条件安全。

>实际上是对于任意的，对任意的。完美安全的加密算法。它的其密钥。要长度，那我们就用一个最简，我们用一个英文单词，叫做密钥长度，密钥长度是 $K$，这是密钥的长度了吧。必须是大于等于铭文的长度。

## 随机数发生器
这太麻烦了，我能很自然的我想到我能不能以这样的方式，我有一个中间有一个发生器，我们叫做 $G$，这个叫做 $G$。这个地方。Generator 嘛，对，记 generator 的缩写，Generate 发生器生成器。我们能不能设计出这样一个发生器来？这个发生器它能够把一个短小的种子**扩张成为任意长度的看起来随机的比特位串**。然后我要加密的时候用这个，生成的这个比特位串来跟铭文抑或，是吧，所以他的 ID，
它是先有一个种子，短小的种子 $K$。一个密钥生成函数，密钥流的生成函数。生成跟你铭文一样长度。这个映射，这个映射把一个短小的种子扩张成为任意长度的一个看起来随机的。序列，这个生成函数我们就叫做 $G$ 函数，所以你看它这个 $G$ 函数将 $K$ 映射成函数值，是不是我们就用 $G(K)$ 来表达？那去发送方加密的时候呢，我就是由同样对技术公开的。是一个确定性的算法，只要 $K$ 一确定，它的函数值就确定了，是确定性的，只要你知道 $K$，你是不是都能够把 $G(K)$ 这个密钥序列。

### 安全性
就是这样一个思，那么问前提就是这样的老师，你怎么去保证？这个 $G(K)$ 这个序列的安全性呢？我们说现在我们只能说从直观的意义上来说，我们要让这**二者不可区分**，看起来就像一个真随机序列一样。前提是对于观察者而言，你只要不知道这个 $K$，然后你来观察，这边是左边是一个抛公平硬币的一个真随机序列，右边是一个伪随机序列，这个我们叫伪随机序列，你看对于观察者而言，他无法区分，所以我们用的约等于符号就是无法区分。如果能够满足这个 $G$，能够满足这样一个。对观察者而言，拥有有限计算资源的观察者而言，他无法区分这二者。那我这个 $G(K)$ 就足够安全，那么我这个加密算法就不安全了，

那么下面关键的问题是，老师，怎么构建这样的密钥流发生器呢？要满足你刚才说的这二者看起来无法区分性，对不对？怎么去构造，所以就核心整个流密码的核心是如何构造安全，密码安全，我们叫做**密码安全的密钥流发生器**，就是这个嘛。这就是我们的本质问题是吧？

所以后面我们就来看好，我刚才我们说了，老师，那现在我要需要给一个安全性一个重新的定义，因为你的无条件安全已经高度相同，已经证明了安全或者信息安全的加密算法，它的密钥长度要大于等于铭文的。显然就是这个，这个我们无法设计出完美安全的实用的加密算法，因此我要给出一个新的安全性定义，好，现在我们教材就给一个新的安全意义，现在我们大家我们商用的，或者我们使用的所有的密码算法，它都是计算安全的了。

我现在提出一个新的概念叫做计算安全。计算安全它又是怎么定义的，我们来看一看，我们也当然这个也是很直白的语言，但是真正的理论密码学是要给他严格的数学定义，对于我们同学而言呢，因为那个就理论的，所以我们把它转为直白的语言，一个密码体系，一个密码系统，或者一个密码算法是计算安全的。

>计算安全：如果是最已知的最好的加密算法，破解它的加密算法都需要至少 $T$ 次的运算。$T$ 次的运算，而且我们教材这个后面这一句话没有说，我给他补充的，这 $T$ 次运算是指的对现今的计算机而言，要完成 $T$ 次的运算是计算上不可行的。这样才叫做安全性。

对于我们当今的计算机而言，$2^{80}$ 次方是一个 $T$ 的临界点。这是个临界点。只要大于它就不可行了，小于它就是可行的了。是吧，你现在大体对于当今的电脑，你知道 $T$ 下界就应该是。这个等于 $2^{80}$ 次方，大概约等于这个概念，你理解它就行了，这样去理解我们的计算安全就行了，就可以了。

他说计算安全是指的，现在我就没有说你这个。我没有说敌手的计算资源是无限的啦，是不是？隐含的意思就是，对于所而言，它的**计算资源是有限的**，比如说我们当今地球上所有的计算机。虽然组合了所有的计算机。都用来破解这个密码算法，它也是有限的计算资源，是不是？当然现在我们只能感性的给大家一个这样的一个感性的认识，今天我们密码学家所有设计的，不管是协议和算法，我们追求的是计算安全。

那待会儿我们就看，我们可以，后面我们就，我们确实可以设计出实用的又是计算安全的密码算法。又实用把这个你当然存在一些很多的问题，对不对，并不严谨，为什么，因为它不是数据源给你的描述，直本元。什么是最好的算法呢？那有没有可能还有更好的更强的攻击方法呢？是吧，比如说我们前面在讲过，我们代加密算法替代加密算法老师，我知道他的密钥空间。对蛮力攻击而言是不可行的，因为他的这个密钥的这个空间是大概是 $2^{80}$，已经超过 $2^{80}$ 次方了，是吧，但是呢，我们也我们又找到了更好的攻击方法。频率啊，字母频率分析的攻击，是不是。所以说你怎么你这个下界怎么来去定义呢？是不是什么叫做最好的算法，你的下界对于一种攻击而言，对于已知的你已知的我是容易找到下跌，但是万一我还有更好的攻击方法呢。是不是，所以这个地方的 best known algorithm。**不严谨**，更不严谨。

如果说我们在现实当中所有的密码分析学家都**找不到一种以蛮力攻击或者密钥穷举搜索攻击更好**。而更加。你这个算法的。好，也就是说复杂度。同体收缩或者蛮力攻击复杂度更低的密码系统。如果我都找不到。我们就可以认为这个对称加密算法是安全的，所以我们怎么去衡量一个对称加密算法的安全性，满足这一条就行了，只要我们在现实生活当中，待会儿我们会看好多例子都是这样，我们找不到一种比蛮力攻击。或者说你要重组，受受攻击更好的。初级算法，那我认为这个加密算法就是足够安全的。所以现实当中，我们达到这个安全目标就够了。

对于对称加密算法，我们现在最好的评价标准就是，不到一种以蛮力攻击或者枚举攻击更好的攻击方法。我一直找不到，可能我们人类，我们现在要提醒同学们的，就是说我们现在真正实用的一些对称加密算法，在对称加密算法加密这个领域我们无法证明它的安全性。

在对称加密领域当中，说到根子上，所有的分组密码或者密码，我们是**无法去证明它的安全性**的。虽然你有这样的定义的，对，我们在我们后面理论的密码学是对这个有数学的意义的定义，但是你没有一个实用的密码算法是可以证明它的安全性的，所以我们只能是凭借相当于一个经验准则，人类分析这个密码是什么？
在对称加密领域当中还没有真正的实现我们说的从**艺术变成科学**了。因为密码学在早期，古典密码，它纯粹就是艺术。科学啊。好了，那么怎么刚才我们已经说了，我说，那现在我知道了流密码的思路，就是这样的一个思路，是不是我能不能产生出一个，我用一个这个唯一就是这个我能不能设计一个足够安全的伪随机数发生器，即使得它产生的密流看起来跟真随机的这个密钥序列是无法区分的。

### 线性同余实现：
老师，我能不能伪随机数发生器来构造流密码，或者我能不能用密码安全伪随机数发生器来构造流密码，是这样来构造右边这个这这个右边这个图好，我们先看第一种。只有两种方法，我们现在看第一种。伪随机数发生器的构造方法，我们来看看。那就像比如说这个我们经常在现实当中经常用到的，一个伪随机数发生器，人们在现实当中经常用到的一种伪随机数发生器，就是我们的线性同余发生器。那它很简单，是怎么来生成的？你看我首先呢，我取 $S_{0}$ 就等于一个短小的种子，然后呢，我就代入这个方程来计算，你看我要计算 $S_{i}=(a\times S_{i-1}+b) \text{mod M}$，

我们真正要把它用来做加密流密码的时候，我们实际上会 **A 和 B 以及种子视频都把它合起来叫做密钥**。因为他都不能让敌手知道，如果都敌手都知道的话，不就自己就能够把所有的 SI 都计算出来了吗？那密钥流不就计算出来了吗？所以说合起来的 ABS 零合起来。O 必须是不能让敌手知道的。那合起来就叫就叫做我们的密钥了。

那这个线性同余方程呢。A 和 B，甚至总之就可以恢复。为什么？我们来看一看。你看他说三百个比特，知道就是说想假设现在我们知道的 S 一 S 二 S 三我们都知道，因为我们大概 M 应该要求密钥长度是一百个，每个 absi 都是大概是一百个比特，那就相当于这个模数 M 大概也是一百个比特的规模，对吧，一百个比特嘛。然后密钥三百个，那么每个 SI 都是一百个比特，那我们现在你要知道哪个比特，就我们举一个具体例子，比如说我们用举手就知道 S 一。S 二也知道 S 三了。这个时候现实当中，我们说的，对于很多的文件格式，或者说标准的协议，他的协议的首部是一知道。也就是说，这一块是已知的协议首部文件的类，各种文件类型的文件的标题都是固定的。就这个相当于是已知明文。

我就把你的密钥流当中的三百个比特恢复出来了，假定，那么我们说恢复出来了，是不是就相当于这两个方程当中。我们联立方程 S 一 S 二 SN 已知数，那未知数只有两个未知数了，A 和 B，因为我们说 A 和 B 是要保密的，模数 M 是要公开的。对，唯一保密的只是 AB 和 S 零。AB 和 S 要保要保密，那也是连离这两个方程，这个只有两个未知数的两个方程，是不是能够**把 A 和 B 解出来了**。你的这个密钥都被破解了，你还有安全性可言吗？A 和 B 都能知道了，S 零同样也可以恢复出来了，是不是 S 零也可以恢复出来了？

那么我们说真正要构造流密码，一定要用**密码安全**的，我们叫做 IC geically secure，就是我们只能用最后一种了。我们今天讲的三种随机数发生器。前两种都不能用，对不对，这个不适用 onetimepad。这个呢，这个伪随机数发生器呢，这个我们这个地方定义的伪随机数发生器，

好，它就应该是这样的，我们只能现在第二条唯一的途径只能用密码安全的 graphically secured，随发生期等等，那必须是**不可预测的**，我们来看为什么。我来看看为什么，依法安全的不必须必须是不可预测，这是可以预测的，
那么老师我现在我就定什么叫做可以预测。就不给什么叫预预，可以预测呢，我们就来给他一个定义
>可预测性：我们给定了你这个输出，比如说输出 SI。当中的。这这个输出的这个密钥流嘛，比如密钥流当中的 N 个连续的比特，我给你已知了，那么后面的 DN 加一个比特不能够被预测，如果可以被预测。就是浓度高于百分之五十的概率。预测到。预测准 N 加一个比得。我们就说是可以预测的，如果我们不能以高于百分之五十的好于百分之五十的概率去猜中下一个比特，那么我们就说它是不预测。

对不对。这个这个很容易这个定义，那比如说换换一句话说你看，我们说一个伪随机数发生器 PRG ，就是告这个这个序列当中，我告诉你前 N 个比特。对，你可以通过运行某种算法上是时间的，这个算法可以预测后面的 N 减 X 比特，那我就说这就是可以预测的。

对不对，这就叫可以预测好了，那我们来看，如果是说我们的伪随机数发生器其实可以预测的话，我们真正安全的是密文，**不能泄露明文的任何信息**，哪怕一个比特的信息都不行。

所以这加上，即使你的**可预测性没有那么强**，你只可以预测第加一个比特，**也不安全**呢，因为通过这种攻击，你可以知道明文的第二个比特了。

第一个比特了是吧，那也。因为真正的安全是应该明文不能泄露秘文的。密文不能泄露铭文的任何信息，哪怕一个比特的信息不能泄露。所以通过这个例子我们就知道了为什么我们的伪随机数发生器一定是。

## 线性移位寄存器
接下来我们再来介绍一种。特殊的一种这个硬件的构造。硬件的构造叫做线性。一位寄存器先行反馈移位寄存器，因为他也在，特别是基于硬件实现的流密码还大，要用到它，所以这个地方我们要来介绍一下它的概念比较简单，线性反馈零点线性反馈 feedback。U a shift register 线性移位寄存器，它的概念非常简单，不要看着好像这个我们待会一解读大家就清楚了。我们来看它叫做线性。反馈一位继承器婴线性。Feedback 反馈。Shift 的一位。待会儿我们看，它是为什么叫为什么他就又叫反馈，又叫移位，这两个定语是什么意思，待会我们就看得出来，一位。寄存器。所以我们经常简称就是简称成 LFSR。每一个，所以它这个地方呢，就是一个度数为三的。负数为三的线性移位反馈寄存器，为什么它有三个触发器就叫做度数为三？都有数，你有多少个，你有 M 个。那我们就叫做你的度数。

是不是？很简单了，所以所以说你让我们来试试看一下，我们老师画一个线。好，我们大家就试着来做一下，可能这个有可能考试的时候是最简单的**考试题**。

