好了，同学们，我们开始上课了。我们来回忆一下密码这个概念。留密码呢，实际上我们中文翻译也就是密码是一个东西。我看到有些同学对数据密码不太理解。密码呢，有翻译成“Separate”的。在学术用语中有两种翻译，一种是“密码”，就是按照原来单词翻译的；另一种是“序列密码”，所以看到这个，你知道它是一个东西，一个概念。密码，这是我们回顾的内容。

## 流密码数学安全性：
这样啊，你看，序列密码或者留密码的加密解密过程，我们来看一看。我们也可以按照纳米的概念模型来理解它。在加密过程中，每一个 $X_i$、$Y_i$、$S_i$，$X_i$ 代表明文的一个比特，$Y_i$ 代表密文的一个比特，$S_i$ 代表密钥流的一个比特。序列密码或者留密码，它是一个一个比特按比特来加密的。$X_1$ 经过加密后得到 $Y_0$，$X_1$ 这个比特加密后得到的 $Y_1$ 一定是一样的，两个很明显。那么你看它的加密过程，按我们刚才说的，按比特加密，加密后的密文比特在不安全的信号上传输。到了接收方，接收方只要能够产生同样的密钥流，就一定能够解密了。只要发送方加密时用到的密钥流和接收方解密时用到的密钥流是同一个，当然就能够解密。你看这个解密过程，密文比特 $Y$ 与密钥流中的某个比特 $S_i$ 进行异或运算，得到明文 $X_i$。

好，接下来上一周我们分析了一个很重要的性质，然后呢，我们上一周专门学了一个重要的性质，就是异或运算的一个重要性质，模二加法运算的一个重要性质。我们回忆一下，这个性质我们在教材中深入讨论过。他说，

加入我们有一个分布情况位置的 $X$,和一个均匀分布的 $Y$,那么我们通过异或运算运算出来的 $Z$，一定是一个随机分布的变量。

这个定理的意义就是说，不管你的明文服从什么样的概率分布，只要我用一个一致随机的随机变量进行异或运算，得到的 $Z$ 也是一致随机的。不管你明文服从什么样的概率分布，我密钥流如果是一致随机的，那我就相当于通过异或运算，我就可以把你的明文一致随机化，得到密文。


这句话我们现在结合着来理解，我们前面的替代密码我们就知道了替代密码呢，它就是我们说我们回那个 P 密码很简单，他就是这样的，他说他就是把一个明文的任何一个**字符唯一的映射**为一个对应的一个，唯一的一个对应的一个密文字符。因此我们说密文仍然包含了明文的信息，比如说字母。是吧？那也就是说，因为你这种唯一映射的关系，也并没有通过这个映射关系以后，也并没有在密文当中将明文的字母频率信息隐藏，没有隐藏。仍然是保留了。因此这个角度来看。它就是一个非常不好的一个密码，因为他在**密文当中仍然保留了明文的统一统计信息**，某一个统计信息，比如说。仍然保留了，因此它是不安全，那我们反对应过来看，这边是一个时代的案例，这边是个最好的。

好了，所以我们现在就可以。通过这个定理，刚才这个定理我们就知道了，为什么模二加法运算，或者说我们异或运算，它就是一个非常好的加密运算或者加密函数。

因此只要你跟这个流密码，它的核心，它的最本质就在于，你怎么样去产生个**一致随机的密钥流**。是不是本质上就异或运算保证只要这个 $S_i$，每个 $S_i$ 或者说密钥流是一致的，那么得到的密文也一定是一种？那定理告诉我们了。一致随机，那当然是最好的隐藏认可。英文的统计信息是吧，因为它一致随机，还不够随机，它一致随是最随机，一致随机了。

所以那流密码的核心，或者它的中心问题就是，老师怎么样去一致随机的密钥流呢？这个时候就是随机数发生器。只要我们设计一个好的，我们如果能够设计一个一致一个好的一个这个随机发生器说它产生的密钥流是一致随机的，那这个流密码的问题就解决了，是不是刚才那个定理告诉我们了，好，所以我们下面的焦点就放在这个随机数发生器这个问题上。而随机数发生器 generator，所以简称 RNG。首字母缩写嘛，是吧。都这么缩写。Random number generator。而它又分成三大类，我们来看一看，三大类
一类呢，是真的随机数发生器。True random number generator。
一个是伪随机数发生器 pseudo random number generator。随机数发生器换一句话说，用直白的语言说。看起来像一个真随机数发生器，但是它本质上不是个随机数发生器
还有一个密码安全的伪随机数发生器密码安全的随机数发生器。Cryptographically secure pseudo random number generator。有时候我们就把它简称叫做 CSPRNG。

## 真随机数发生器：
真随机数发生器呢，它往往是基于一些物理的过程，物理的随机过程，比如说你看我们最简单的，这个这个我们课件上讲到的，比如说我们的抛公平硬币 Coin flipping。抛硬币对吧，还有比如说我们的半导体噪声。还有我们的这个无线电波的这个衰减，无线电的衰减，Radioactive decay 等等啊，这一些物理过程，
真随机的特点就是。你**无法重现**它，你不可能在我们英文叫 reproduce 是吧，你无法再重现，因为你要重现它的概率，你要每一个都跟我相等，每个比特位都跟我相等，那你要相等的这个概率，相等的概率是 $2^{100}$ 分之一。是不是因为每个比特位都是 $1/2$ 的概率，那一个比特。总共是一百个比特，所以按照乘法原则做一个事情有一百个，对不对？每一个步骤的可能性是 $1/2$，那就是 $2^{100}$ 分之一。所以约等于零呢，因为这个数是个极大的一个天文数字。几乎等于零，约等于零。所以说你是无法。毕竟是真随机的一个具体案例，我们这个可以很好的从直观上去理解它，你要重新抛公平硬币。产生跟我刚才产生的这一百比特位一模一样的比特位串，以概率是 $2^{100}$ 分之一，这是几乎不可能的。这就是真随机的一个。我们说可以从。这个角度去理解，什么叫做真随机了。接下来呢，这个，那么我们实际上我们今天的有些硬件里面也包含一些设备。它本身就含有这个。真随机数发生器，我们举一个例子，这个例子比如说我们的现在很多的主板上不会集成一个模块，硬件模块叫做 TPM platform。本身里边就还有一个，硬件的。基于硬件的一个随机数发生器技术非技术发生器。Platform module。这个模块反正大家现在了解，就是说它安全相关的，对不对，跟我们密码运算相关的就是。信任的平台模块。显示 TPM，它里边就包含一个随机数发生器。它就包含一个 T。这个 RNG。对不对。简称就叫 random number generator。这个是举一个一个一个一个例子。好，那么大家知道的就是艾老师真随机数一定是通过一些，基于一些物理的随机过程。一些啊。可以从当中去提取随机数是吧？那么他当然既然是真随机的话，那我就要求他的输出的这个。密钥流当中的每个比特位。等于 0 和等于 1 的概率各占各都是 $1/2$ 是吧，这是肯定，这才叫真随机嘛。
比如说他这个我们就要做这个 TRNG，他用经常用的什么呢？**产生密钥**。我们用来产生密钥，产生完密钥以后，我就把密钥分发给安全的，分发给发送方，给接收方。他们就共享了一个真随机的密钥，有有的时候呢，比如说我们产生临时值。新鲜随机数或者临时值，那这些 nonce 它就是从这个 used only one 这样的 use only one 是这样来缩写。前面讲过，nonce 临时值。
## 伪随机数发生器：
那么接下来就是我们的第二大类，中间为随机数发生器。对，真随机数发生器你过来就过过就是伪随机数发生器。伪随机数发生器呢，它实际上是怎么样的一个东西呢。它伪随机数发生器，它的概念就是。我是通过一个短小的种子来生成，通过递归式地迭代式的来生成一个序列，我们画一个很一个很很形象的图，大家

伪随机数发生器从一个初始的种子迭代，迭代地生成。待会儿我们就可以看怎么迭代生成，我们就可以看到递归率。他说通常来说，这个输出的比特流或者密钥流有很好的**统计特性**。那一个很好的统计特性就是刚才我们在图上这个黑板上画的，就说你要把这个伪随机的比特序列，伪随机数发生器产生的比特序列，与真随机数发生器产生的比特序列，你要拿来两个来区分的话，区分不开。

伪随机数发生器，他说可以被预测，为什么？我们待会看一些实例。比如说我们举一个例子，我怎么样来生成所谓的迭代的方法生成，你看我这用这样的一个一组的这个式子来生成，我 $S_0$，我把它这个变量我就叫做我就是我，或者说我把我的种子这一百二十八比特的种子。我把它赋给 $S_0$，然后呢，我就通过这个函数来迭代地生成，你看通过它的前，你看 $i$，而 $i-1$ 一直到 $i$ 这个比特来生成下一个比特，是不是。通过我们这儿就相当于是这个加一个比特来生成下一个 $i+1$ 比特，通过前面这总的一个比特嘛，比特币是吧。加一个比特，然后我们来生成下一个比特。

### 线性同余发生器
通过这个迭代的 $F$ 函数。看具体情况了，比如说我们最常见的一种，我们叫做线性同余方程。说让他来构造的这个随机数发生器，我们的是线性同余发生器。它就是这样来生成的。我们来看一看，最简单的这个函数呢，就是一个线性函数嘛，你看，这个函数我把它最简单的情况就是这种线性函数是吧。线性函数。好，所谓的这个线性同余，你看我这取一个模数，不是取 $M$ 这个模数，你看这 $M$。对不对，一般来说，通常情况下，我们这个 $M$ 是一个素数。这个模数 $M$ 是一个素数，一般情况下只取一个素数，大的素数取一个大的素数来。

你看我就通过这种方法，你看比如说我现在 $S_0$ 确定了，我要产生 $S_1$，是不是那一按照这个迭代方程来的话，$S_1$ 就是不是就等于 $aS_0 + b$ 嘛，在模一个 $M$ 是吧。最后我们的比特序列呢，我可以取 $S$ 每一个 $S_0$ 或者 $S_{i+1}$ 当中的，或者 $S_i$ 当中的某几个比特。把输出作为我的密钥，密钥序列。

但是我们要告诉告诉大家的是奖线性同余的这个发生器，随机数发生器，它是具有**坏的密码性质**，也就是说它是**可以预测**的。并不安全。并不安全。那么一待会儿我们来看一看为什么？这个这个是最简单的一种，例子啊，随机数发生器。线性同余发生器，

## 密码安全随机数发生器
接下来我们再介绍第三大类。随机数发生器，用密码安全的随机数发生器。密码安全的随机数发生器，那我们简称叫做 CSPRNG，密码安全的伪随机数发生器，简称叫做 CSPRNG 嘛，前面 cryptographically secure 密码安全的对吧，

它是实际上它是**一种伪随机数发生器**当中的。具有特别性质的一类。也就是我实际上，我们这个图他可能写的还不是特别标准，应该是实际上是说这个伪随机数发生器当中，我们又有一类叫做密码安全的伪随机数发生器，他是应该放在这个下面。这个图画的还不一定准确。好，那么这个密码安全的伪随机数发生器，它有什么特别特点呢？
它的输出必须是**不可预测**。那什么叫做可以预测？我们来首先来精确的给出一个概念，什么叫做可以预测，什么叫做预测，不，什么叫做不可预测，被预测，我们来给他一个比较。
>严格比较精确的定义是说给定你 $N$ 个连续的。比特输出。$i$ 比如说你看我就是这个 $S_1$，$S_0$ $S_1$ 一直到 $S_N$。$N$ 对不对？总共这 $N+1$ 个比特位，那么下一个输出的下一个比特位就是 $S_{N+1}$ 了，对 $N$ 个连续的比特。$S_0$ 一直到 $S_N$。那么下一个比特 $S_{N+1}$，它不能够与什么样的概率去预测呢？不能够被预测在同样时间内，不能与高于，好于或者高于百分之五十的概率去。预测到。那么它就是一个密码安全的，或者说它是一个不可预测的伪随机数发生器。

对于流密码来而言呢，这个 CSPRNG 非常非常重要，另外呢，他说在实践当中，实际上几乎没有其他的应用需要这种不可预测性。但是呢，在我们的密码学当中，就需要。但是因为他说有很多，但是很多很多的系统是需要。西安。但是在我们的密码当中呢，一定要求他是不可预测的，为什么？我们来看一看，为什么不可预测。我们举一个例子，教材上没有讲，我们展开一下。为什么说我们要要求这个伪随机数发生器必须是不可预测的？比如说我们就举我们这个回到我们刚才的这个图上。我们的流密码这个图。我们来看一看为什么我们密码上必须要要求，它是不可预测的。

所以这个这个地方非常重要的一个性质，这个叫做这个叫做。Next bit 的这下一个比特位的预测，这个叫做。当然我同样的也可以念，这个是知道 $N+1$ 个比特序列，这第 $N+1$ 个，前面 $N$ 个呢，这个实际上我们是假设，比如说 $N$ 个比特嘛，$S_1$ 开始知道 $S$，这个 $N$ 个比特序列增加一个比特，叫下一比特预测，那我也可以是我知道，这

## 一次一密
那么我们下面来看一个一类特殊的流密码，叫做 one time pad 一次一密乱码本。我们来看它的概念，什么叫做一次一密乱码本？

也可以。比如说一次性密乱码本呢，我们说是这个。是怎么样来那个呢，来加解密的，我们来看一看，他说。密钥，我们要求这个密钥流，一定是一个**真随机数发生器生成**的。你看 TRNG 生成的。

一个比如说现在我有这个我的每个比特位。是相当于抛公平的一样，或者说我们有一个物理的这个随机过程，从它中提取随机数得到的。那么假设明文呢？和这个明文呢，就是我们的明文比特就是 $X_i$ 了，明文比特就是 $Y_i$ 嘛，那我加密的时候就是这样的加密，我们你看我的这个 $X_i$ 每一个比特。加密每一个比特的时候都用一个。一个都用对应的 $S_i$，但是 $S_i$ 呢，不能被重复使用，它**只能使用一次**，就说这个比特位，它就是专门只能用来加密第 $i$ 个比特的，你不能用这个 $X_i$ 加其他的密钥。

是。解密的这么有类似的一样的嘛，对同样的这个就跟我们前面看到的这个流密码，老师看起来跟概念是一样的，但是这个有**两个限制性条件**，一个是这个密钥流必须是真随机数发生器生成的。另外一个，**每一个比特位在加密的时候只能用作一次**，这个一次一密乱码本是这样要求的话，那也就是意味着你的明文有多长，我的密钥流就要有多长，是不是因为每个比特位只能用一次？是不是你不能重复用它，那也就是说你的明文如果是这个有 $L$ 个比特，那我的密钥序列也必须是 $L$ 个比特。是吧，大 $L$ 个比特。人们研究发现它就具有**无条件安全性**，或者说完美安全，或者信息论安全。我们来解读一下什么叫做信息论安全或者完美安全，这个地方的教材只是有几种表述，只是给出了两种表述方法。实际上我们还有。另外呢，这个第三种描述，叫做完美安全。
>无条件安全：当他这个密码系统密码系统不能被破解，第是敌手，敌使使用无限的计算资源也不能被破解。这就叫做无条件安全，信息论安全或者完美安全，就是敌手的计算资源是无限的，他都没办法破解。

我们这个密码密码系统，那么教材举了一个比较形象的例子，我们来看一看。我跟大家复述一下，举了一个例子，比如说现在我们有一个假设，我们有一个对称加密算法，它的密钥长度是一万个比特。一万个比特密钥长度 $KS$。是一万个比特。而且我们还有一个假定，第一个假定是密钥长度是一万个比特，第二个假定呢，就是说。仅有的就是蛮力攻击。就是注意这个我们设计的一个对称密码，是我们设计的一个对称密码。首先。它只存在蛮力攻击，那么也就是说，我蛮力攻击的时间复杂度是多少？$2^{10000}$ 那么这个密码算法对于我们今天而言，这样来感性认识而言，这是个绝对很非常非常顶级安全的密码算法。
但是我们说，对于无条件计算资源的敌手而言，这就不是一个。困难，问题很简单。那我们就。我们就准备 $2^{10000}$。这么多台电脑，每一台电脑它就只做一个点运算，对不对，我们蛮力攻击的时候嘛，他就只需要去验证一个密钥是吧。假设对于我们具有无限计算资源的这个敌手，假设这个敌手有 $2^{10000}$ 的计算机可以用的话，每台计算机只需要检查密钥空间当中的一个密钥，是不是一步，我就完成了，就找到，就可以找到正确的密钥了，就没密钥了。蛮力攻击，所以说大家就**可以这有蛮力攻击的，或者无条件安全远远。对安全性的要求非常苛刻的**。

是吧，因为像这种呢，对**于这个无无无限计算资源的敌手而言。根本不安全**，


>信息论安全，我们再给出另外一个等价的描述，更直白的描述。就是就是对于。无限计算资源的这个敌手。无限计算资源的介绍。就是对于拥有无限计算资源的敌手。对于。拥有。无限计算资源的敌手。我说他这个敌手从。**从密文获取不到明文的任何信息**。（等价于无条件安全）


一次一密乱码本。只要你的这个密钥流当中，每个啊，或者换句话说就是你的密钥流只使用一次。密钥流只使用一次，就意味着你们每个比特每个密钥比特密钥流当中每个比特使用一次嘛，那么，那这个一次一密乱码本它就是完美安全。完美安全或者无条件安全，或者说信息论安全的。那那也就意味着我在讲每一个比特的时候，再加 $X_0$，这个比特的时候，我这个 $S_0$ 是一个用 $X_0$ 去加密，用 $X$ 在 $X_1$ 这个比特位的时候，用 $S_1$ 密钥流当中，$S_1$ 这个比特位就加密，按照你的条件只使用一次，不能复用，那也就是说你的明文有多长，密钥流就要有多长，而且每一个比特位它都是独立的，因为你要求它是真随机。
每个比特位是不是都独立的，所以我们从这个角度来看，也这个我们也没办法去解这个方程。这教材讲的这个例子是说，假设我们把每个比特位加密的过程，把它列成方程，对，$Y_0$ 就是这个密文的比第一个比特位，$Y_1$ 就是密文的第第二个比特位，这是 $X_0$ 就是明文的第一个比特位 $X_1$ 就是秘文铭文的第二的比特，那么所有的明密文的就以加密过程就可以列出这样的一个方程来。那这个方程每个程当中，我们敌手只知道一个值 $Y_0$。因为密文你要放在公开的网络上去发送的，没有我们知道 $Y_0$，你想去计算 $X_0$ 和 $X_1$。要去反解 $X_0$，因为 $S_0$ 是独立的，并且随机的。是不是因此你要去反解，不管你这个方程多少个，有 $N+1$ 个方程。你都因为这个你这个等式当中有两个未知数。根本没办法去求解获得 $X_0$ 是不是？换一句话说，你通过密文你获取不到明文的哪怕一个比特的信息是吧？



