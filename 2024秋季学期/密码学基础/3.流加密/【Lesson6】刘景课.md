## LFSR：
线性反馈移位寄存器（LFSR）我们当时还没有讲它的一些相关理论。我们回忆一下线性反馈移位寄存器的工作方式。它有三个触发器，比如说我现在这个线性反馈移位寄存器，我把它叫做三度。度数为三是因为它有三个触发器，**有多少个触发器，它的度数就是多少**。这是一个简单的概念，度数也叫度。因为有三个触发器，每个触发器只能保存一个 bit 的信息，所以它的内容要么是 0 比特，要么是 1 比特。你看，那么我们这样的一个三度，这个 FF 就是触发器（Flip-Flop）。我们前面也提到过，触发器只能保存一个 bit 的信息。

我们来看它的工作方式，这个所谓的 shift（移位），你看它的表中就有一位。我来说一下主要的几个部分。第一个是触发器，第二个是反馈电路（反馈路径）。**反馈路径**是什么？我们马上来看。反馈路径就是指的你看这个地方就是反馈，这些地方你看两个触发器，这个箭头符号以及异或符号代表什么意思。所以说你看这个$FF 0$这个触发器所保存的内容和 $FF 1$ 这个触发器所保存的比特信息，两个异或以后的值赋给 $FF 2$。它是反向的，另一边是它的输出比特序列，是在这个位置输出。相对这个是前向的方向，这个是后向的方向，我们就把它叫做 feedback（反馈）。

它的工作是这样的，它是以时钟来驱动的，你看这儿有个 clock（时钟）。每一个时钟周期，它就会触发一次，比如时钟触发一次，所有的移位器的内容，这三个触发器的内容会向右移一个位置。我们来看这个图，比如说这种情况，向右移一位，那这个 FF 0 所保存的比特是不是就输出了？但是向右移位就等于它就输出了，输出在这个位置，你看这是 S 0。那 S 1 就填充到 FF 0 上来了，S 2 就填充到 FF 1 上来了，这就是移位（shift）。

然后呢，左边 FF 0，由于它的内容已经移位到了 FF 1 了，那它是不是空了？那空出来的值由什么来填充呢？也就是由我们当前的 FF 0 所保存的 S 0 和 S 1 异或以后的值来填充它。我们可以这样来表达，因为所有的都已经移位了，现在我们 FF 2 所保存的内容叫 S 3。S 3 就等于现在因为 S 2 已经移位到这儿了，S 1 已经移到这个位置，S 0 已经输出了，所以最左边这个触发器，它的内容为空了。那它现在要填充的内容，我们就把它叫做 S 3。S 3 现在来看是不是就应该等于 S 0 异或 S 1？是不是 S 3 就应该是等于 S 0 异或 S 1？这两个触发器的内容，异或然后来填充最左端的这一个。所以是不是就是这样？

我们来复习一下，假设我们要看右边的这个图，我们右边这个列表的表格，我们来看一看它的**输出序列**。假设我们最开始这三个触发器保存的内容是 0、0、1，那我们来看时钟，第一个时钟周期到了的时候，那是不是我们整体的三个比特要向右移一个位置，那么相应的这个 0 就输出了，0 就已经没有保存的地方，它就输出了。那就相当于我们这儿的 S 0 一样，它就输出了，然后 1 和 0 是不是就移位到右边来了？分别向右移了一个位置，然后呢，这个位置由什么填充呢？是由上一个时钟周期的 FF 0 所保存的比特跟 FF 1 所保存的比特按位异或。是不是就等于 0 跟 0 异或就等于 0？所以填充出来的是不是就是0？

再来看第二个时钟周期，第二个时钟周期整个的 0、1、0 是不是向右移位，0 又输出了。右边的这个 0 有输出，然后呢，0 和 1 整体移位到这个位置来了。这边的这个位置又空出来了，最左边的这个触发器它空闲了，我们就用上一个时钟周期的 FF 0 和 FF 1 保存的 0 和 1 异或就等于 1，所以这个时候填充过来的是不是最左端的，那其他的内容就是 1。所以啊，最右端的我们来看最右端的这个 FF 0 所保存的内容，随着每一个时钟周期，它是不是就输出了？这就相当于我们的输出序列就是最右边的这一列，0、0、1、0、1、1、1、0、0，对不对？是这样的就输出了这个序列。

那么我们随着时钟周期，我们一直我们的时钟周期可以无限进行，是不是它就无限地输出比特序列了？而且它的硬件实现非常高效。它就是专门用来做硬件实现的，所以你看它这个是不是就可以源源不断地输出比特序列了？是源源不断的。

但是我们说这个线性反馈移位寄存器它有一个**周期**，它输出一个是有周期的，我们来看一看我们教材上怎么说的。它实际上它的周期应该是七个比特。每输出七个比特它就要重复。我们来看看我们的课件，你看它实际上每输出七个比特。我们这儿呢，就是我们的课件上面是指输出了九个比特。实际上再下来它就要循环了，一到这个下面的这个从第七个开始，0、0，它又要循环 0、0、1、0、1、1、1，它就会这样的是吧？就是这样的。它的周期循环周期。所以虽然说，老师它是可以无限输出，但是你看它**输出的比特位是循环的**。只要你循环每七个比特，它就开始循环。所以肯定这个作为密码使用是不行的。因为你的这个我们待会儿要说，老师那它不能作为密码使用。

最大的这个，它的每一个时钟，每一次**循环的序列长度**应该是多少？下面我们很感兴趣这个问题了。实际上这个线性反馈移位寄存器的最大输出长度应该是 $2^M - 1$，比如说它的度数为 M，我们这地方，比如说我们假定它线性反馈移位寄存器的度数，我们用一个字母 M 来表示的话，那么它的最大输出长度是 $2^M - 1$。刚好你看这个地方这三个是三个度数为三嘛，$2^3 - 1$ 就等于 7。

但不是说每一种这个配置都能达到这一要求的，我只要改变你的反馈路径，路径一改变的话，它可能线性反馈移位寄存器能够达到最大输出长度。要满足什么样的条件，它能够达到最大输出长度呢？最大输出长度是 $2^M - 1$。

那也就说老师，那我现在这个 M，我这个度数足够长，我输出的序列就长了，那我这个度数可以设置成 60、80，对不对？这样就 $2^{60} - 1$，这就非常大的一个数字。因为我们知道 $2^{20}$ 就是一兆，$2^{30}$ 是一个 G，那这个是远大于一个很大的天文数字。所以实际上现实实践当中，我们真正的用来设计我们的流密码的时候，我们的 M 就会非常大，会非常大，我们会看这样的实例。好了，老师我们现在清楚了，那今天我们通过这个，我相信我已经把线性反馈移位寄存器的工作原理讲得很清楚了。

### 一般形式：
下面我们来看它的一般形式。老师你不是要现在我们要研究它的一般形式，要研究这个线性反馈移位寄存器的很多的性质，比如什么时候它能达到最大输出长度，反馈路径要怎么样配置它能够达到最大输出长度。这就是我们感兴趣的一些问题。你看我们，我看我们这个教材上有没有这样的例子。我记得好像是有这样的例子。

好，我们再讲完以后，我们再来这个，我们讲它的一般形式，讲完我们再来看他的这个例子。这个一般形式下，我们就可以把这个线性反馈移位寄存器的一般的数学形式是这样的。你看比如说老师你这个地方呢，我可以看成就相当于这有个开关，这个地方这个开关打开，那么这个地方就不进行异或运算。你说二就不。这个地方嘛，这两个开关都打开，它都来 F 1 和 F 0 的内容都参与异或运算。所以你看我是不是可以这样概括成一个一般形式，中间的这一个圆圈，这就代表相当于是一个开关的逻辑开关，实际上我们说它就是一个模 2 的乘法运算。模 2 的乘法运算，就相当于我们的逻辑开关，为什么我们待会儿看。

好，你看我们这样，我们说实际上那这个开关呢，我们说它。横上这个地方，这个中间我们省略了一个运算法，它是模 2 的**乘法运算**。是吧，这个每个 PM 跟 SSM 啊，就每个 PI 跟一个每个一样都它的区有可能要么是 0，要么是 1 是吧。所以说他那么。那么按照这个的一般表达式来说，比如说我现在 P 0 等于 1，是不是就相当于我这边呢？F 0 它是参与了异或运算的，那这个是这个地方的开关就闭合了，闭合了，因为它是 P 0 等于 1 嘛，就有 B 和 1，就是也就是说 S 0 就会要参与到反馈路径当中的异或运算呢，是吧。比如说现在我不想让 S 2 S 1 它这个内容参与到我们的异或运算当中来，那我就把 P 设置为 0 就完了，一项就没有了。是吧，整个这一项因为它的系数 1，我们把 P 成一个系数的话，B 等于 0，就代表这个开关已经被打开了，是吧？打开了这一个 de 1 S 1，因为 P 等于 0。模 2 乘法还是等于 0。箱子就没有了，就意味着，这个 S 1 没有参与到异或运算来是吧，所以很简单，如果按照这样的表达式来写，我们来看一看如何来写我们的这个。来这个。我们按一般形式来表达我们这个。这个最简单的例子，是不是我们就可以写成就像刚才老师讲到的，那是不是就像我们，我们是不是就可以写成这种。我们把这个事稍微展开一点来写，是不就相当于 S 3，等于我们按照我们的一般形式来写，它是右边是最低项，那我们就把这项写在右边来，S 0。还乘上一个 0，这个 P 0 实际上就是等于 1 的，是吧，这个 P 0 是等于 1 的是吧？所以我们这个地方就相当于我们就乘上一个 1 吧，就相当于是吧，乘上一个 1，再加上因为这个地方这个也是不闭合的 1 这个开关也是闭合的，我们用一般形式来代入，S 1 是不是也乘上一个 1。再加上这个地方是模 2 加法运算，我们特别写一下模 2，再加上一个 S 2。这个地方就是乘上 0，是不是因为这个地方呢，S 2 没有参与到这个异或运算当中来是吧。这个开关相当于打开了，这条路径被断开。是吧，被断开了，他已经没办法参与到异或运算，所以这个地方就相当于等于 0 了嘛，是啊，我们按照刚才我们的一般的表达，直接就是所谓的我们这个位置上，就是所谓的 P 0 系数 P 0，P 1，P 2。是不是很容易，所以这样我们就概括出了他的线性反馈移位寄存器的一般形式。一般形式，我们才能，我们才能在一般形式上来研究它的一般的性质，是不是。


好，我们来看一看，他说实际上我们这个这个密码学家，他的研究线性反馈移位寄存器的时候呢，它同时又把这个线性反馈移位寄存器，给它表达成为一个。**多项式**
我们本来是 P 0 S 0 P 1 这相加相加的，我们现在把这个所有的 S 0 S 1 以及 SM 点 1 把它丢掉，用一个多项式的。次数来表达。这个地方我就用 X 的 0 次方，这个 S，这个 S 0 的位置，SS 1 的位置，我就用 X 的 1 次方来替代，变成了一个多项式呢，应该就是这样的一个多项式嘛，有没有就变成一个多项式了。那由于它是这个这个地方呢，我们最高的我们可以写到 XX 的 M 次方这样的一个多项式，这样的一个多项式。一个 PX，也就是说对应的，刚才我们的这个线性反馈移位寄存器的一般形式，它对应着一个多项式。一个多项式，就是这样的一个多项式。

我们说线性反馈移位寄存器由线性反馈移位寄存器生成的序列，它能够他这个是一个最能够达到最大序列长度的一个充分必要条件是它对应的这个多项式必须是一个**本原多项式**，你看一下又回到我们的。数学啊，我们的这个线性代数了。本原多项式是他充分必要条件，也就是说啊，我们现在给他点单 LFSR 就是我们的线性反馈移位寄存器的首字母缩写嘛，它具有具备具有最大输出长度的充分必要条件。最大输出长度。它最大输出长度我们知道的就是 $2^M - 1$ 嘛。本原多项式就是指的首先必须一个条件都多项式，首先他要满足的一个最基本条件，它必须是不可约的多项式，对不可约多项式就是指的，它不能拆分成比它次数更低的为子多项式，结合子多项的只多项是不能够把它拆分成多个的，比它次数更低的多项式。

相乘不像是之前是吧。这个就好像我们的数数一样嘛，我们的数是不能够拆分，除了 0 和 1 以外，他没有其他的工作，这个这个其他的这个因子是吧，那我们这个地方就相当于，它存在比它次数低的。因子。也就是指的次数更低的。不像是求求情嘛。的成绩嘛。A，就是不可约首先必须是不可约的，本原多项式，首先是不可约，其实他还要满足其他的一些性质，我们在这个地方就不说了。大家了解的就是指的首先他必须是不可约的，所以你看本原多项式，欧尼米尔就是多项式的意思，这个地方因为涉及到数学，又

## 安全性质：
第一个比较重要的事是单个的线性反馈移位寄存器产生的输出序列是**高度可预测**的。Highly predict。那我们说待会我们来看一看，他说如果说一个度数为 M 的线性反馈移位寄存器的，它的输出中有 2 M 的比特输出，我都是知道的话，都知道的话，那么这个反馈的这个 Co 的系数系数。就通过求解一个线性的方程组。当然不一定它的解是唯一的，但是只要它的矩阵是存在逆的。系数矩阵是存，视为逆，有存在逆运算的话，它就有唯一的解，是不是？具体来求，还可以有高斯消元法等等来求解，对这个线性方程组。这些都是已知数，对，每一个总共有 2 M 个，这些 ssi，每个 SI，你知道我现在。缓解 P 0 一直到 PM 减 1 这些是未知数是吧，我去求解它就非常容易，就是求解线性的方程组嘛。

第二条就是说：你看它是我们刚才分析了，它是对什么来说，是易受什么人们的攻击，易受已知明文攻击，刚才老师的分析，他是不是就对于我们的已知明文攻击，它是脆弱的？

上述这个原因，许现在的很多的流密码，它是用到的多个线性反馈移位寄存器的组合，并且在组合的时候一定是要非线性的组合才行，这要强调我们，所以这个地方的 combination 组合组合一定是非线性的组合。


## Salsa 20
好，那下面我们先来看看第一个。它是一系列的，软件实现非常高效的，我们叫做 software efficient 的。一个家族，它不是一个，它是一个家族，因为它还有好几种，但我们要介绍，它是基于三种非常简单的运算。我们为什么要跟大家介绍 Salsa 20，是因为待会我们会看到它的实现非常简单，利用到它所基于的运算，非常非常简单的三种运算。
### 基础运算
一种是三十二比特的模加法运算，也就是说三十二位的数，我把它换成一个整数。整数相加，再模上 $2^{32}$，叫做三十二比特的模加法运算。比如说我们这个 $A + B$，每个都是三十二个比特的。我把它换成整数了，这也是三十二个比特的。那我们相加以后，比如就等于 $C$，然后我再模上一个三十二比特的最大整数，代表整数是多少？是不是 $2^{32}$？

还有一种运算，旋转 rotation。旋转或者置换，旋转 rotation。按照一个中心点来旋转，

还有就是异或运算，你看它所依赖的就是这样很简单的三种运算。所以我们联合起来把它叫做 ARX。或简称叫做 ARX。

### 安全性分析
只要是基于这三种运算设计出的流密码，我们都把它叫做 ARX。Salsa 20，它实际上并不困难，我们待会儿看它的设计过程并不困难。就比较简单，我们来一起学习就会好，实际上呢。到今天为止，我们对这个 Salsa 20 也**没有找到比蛮力攻击更有效的攻击手段**。没有比蛮力攻击更好的也找不到，那我们刚前面说了，我们对于对称加密而言，如果你都找不到比蛮力攻击更有效的攻击手段，那我们就说这个流密码，这个分组密码就是安全的。

### 简介：
就是安全是吧，所以到今天为止，那么原始的，我们待会儿要讲的就是原始的 Salsa 20，它是有二十轮的。所以我们把它叫做 Salsa 20/20。实际上它还有两种变种，二十轮简化到了十二轮，我们就叫做 Salsa 20/12。还有一个简化到八轮的，很简单了，那大家从字面上来看也是，老师二十轮肯定计算开销更大，如果把它简化到八轮的话，计算开销就更小了，它运算的速度或者它的吞吐量，加密的吞吐量就更高了。

### 流程：
Salsa 20 的核心就是一个函数，函数它是接受 $512$ 比特的输入，然后呢，输出 $512$ 比特。这样，那它的输入是包含哪些呢？一个密钥 $k$，待会我们要看到一个临时值，以及一个块的序列号。Block number，也比如说我要加密第一个数据块的时候，我这个 block number 就是零，以五百一十二比特为单元，把你要加密的消息分割成一个一个的五百一十二比特的块。
'
说我要加密第一个五百一十二比特的，那我这个 block number 就为零，第二个的五百一十二比特的这个数据块，我就这是我的 block number 就为一是吧，这么递增嘛。好，然后呢，它就成一个一这个它就能够产生以五百一十二比特为单位的，一系列的这个块儿，对不对，就能够产生一个五百一十二比特的密钥流的块。好，那么既然如此，我清楚，老师，那我们要加密一个明文，比如说 $M$ 要加密 $M$ 这个消息的时候呢，对，假设现在用 $M$ 呢，是 $L$ 个字节的话，那我就通过这个 Salsa 20，先跟一个密钥流，跟你这个 $L$ 一样长，你看对不对。

因为它有两个输入，我们这儿只写了两个输入，一个就是 $k$，另外一个 $N$ 是指的临时值。另外一个呢，就是你在加密哪个块的时候，你就输入对应的 block number 嘛，就完了，然后我们再展开那异或这解密肯定也是一样的，很简单对不对，你同样的这个密文跟你的同样的这个密钥流异或就把明文恢复出来这个流密码就是这样设计的，密码就是这样对吧，它的核心就是伪随机数发生器。

Salsa 20 加密算法的核心在于其密钥流的生成过程，该过程通过一个 512 比特到 512 比特的函数实现。算法的内部状态被组织成一个 4 x 4 的矩阵，每个单元格代表一个 32 比特的字（word），总共 16 个字，即 512 比特。在加密启动时，初始状态由密钥、流位置（块号）、临时值（nonce）和常量填充构成。密钥为 256 比特，分为 8 个字；流位置和临时值各占 64 比特，分别拆分为 2 个字；常量占 4 个字，总计 16 个字填满矩阵。矩阵的填充顺序为：对角线填充常量，随后按顺序填充密钥、临时值、流位置和剩余的密钥字节。

Salsa 20 的核心运算是一个称为四分之一轮函数（Quarter Round Function, QR）的操作，它涉及模加法、旋转和异或三种基本运算。QR 函数接受四个 32 比特的字作为输入，通过一系列运算更新这些字的值。每一轮加密由四次 QR 函数调用组成，分别作用于矩阵的列（奇数轮）或行（偶数轮）。整个加密过程共进行 **20 轮**（或 10 个双轮，double round），每轮调用四次 QR 函数。

其中我们的一次 QR 函数由下面的四个部分组成：
1. $b' = b \oplus \text{ROTL}((a + d) \mod 2^{32}, 7)$  
2. $c' = c \oplus \text{ROTL}((b' + a) \mod 2^{32}, 9)$  
3. $d' = d \oplus \text{ROTL}((c' + b') \mod 2^{32}, 13)$  
4. $a' = a \oplus \text{ROTL}((d' + c') \mod 2^{32}, 18)$

在加密的最后一步，初始状态与经过 20 轮运算后的输出进行按字的模 2^32 加法运算，以确保算法的不可逆性，防止密钥泄露。这一步骤是 Salsa 20 算法安全性设计的关键，尽管教材中未明确提及，但它对于保护密钥的机密性至关重要。通过这一系列精心设计的运算，Salsa 20 能够生成高质量的密钥流，用于加密和解密操作。