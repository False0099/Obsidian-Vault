## 朴素算法：
### 1. 密钥生成：
1. 选择一个大素数 $p$,并选择 $g$ 为 $p$ 的生成元，即 $g$ 是群 $\mathbb{Z}_p^*$ 中的一个元素，其阶是 $p-1$,即
$$g^{p-1}\equiv1\pmod p。$$
2. 选择一个私钥 $x\in[1,p-2]$ (一个随机整数)。这个私钥必须保密。

3. 计算公钥 $y:$
$$y=g^x\pmod{p}$$
公钥 $y$ 可以公开，私钥 $x$ 必须保密。
密钥对是：
1. 私钥 $x$
2. 公钥 $(p,g,y)$
### 签名过程：
设待签消息为 m, 签名者选择随机数 $k\in_RZ_{p^{\prime}\text{;计算：}}^*$$$\begin{aligned}&r\equiv g^k(mod\:p)\\&s\equiv[h(m)-xr]k^{-1}(mod\:(p-1))\end{aligned}$$
其中 $k^{-1}$ 表示我们的 k 对于我们的 $p-1$ 的逆元。

则对消息 m 的数字签名为 (r, s), 其中 h 为安全的 Hash 函数

### 验证过程：
签名接收者 B 收到消息 m 和签名 (r, s)后，首先计算 h (m), 然后验证下列等式是否成立
注意到，无论是签名还是加密，都绕不开一个重要的元素 $y^{r}$。
这一个元素可以说是数字签名算法中最重要的部分。因为这一个部分，满足 $y$ 是一个
$$y^rr^s\equiv g^{h(m)}(mod\mathrm{~}p)$$

如等式成立，则签名有效；否则，签名无效。


## 完全破解：
如果签名者复用了随机数 k, 那么攻击者就可以轻而易举地计算出私钥。具体的原理如下：
假设目前有两个签名都是使用同一个随机数进行签名的。那么我们有

$$r\equiv g^{k}\bmod p\\s_{1}\equiv(m_{1}-dr)k^{-1}\bmod p-1\\r\equiv g^{k}\bmod p\\s_{2}\equiv(m_{2}-dr)k^{-1}\bmod p-1$$

进而有

$$s_1k\equiv m_1-dr\bmod p-1\\s_2k\equiv m_2-dr\bmod p-1$$

两式相减

$$k(s_1-s_2)\equiv m_1-m_2\bmod p-1$$

这里，$s_1,s_2,m_1,m_2,p-1$ 均已知，所以我们可以很容易算出 k。当然，如果
$gcd(s_1-s_2,p-1)!=1$ 的话，可能会存在多个解，这时我们只需要多试一试。进而，我们可
以根据 s 的计算方法得到私钥 d, 如下

## 通用伪造签名：
攻击条件 १

## 原理

如果消息 $m$ 没有取哈希，或者消息 $m$ 没有指定消息格式的情况下攻击成立。
在攻击者知道了某个人 Alice 的公钥之后，他可以**伪造 Alice 的签名**信息。具体原理如下：
这里我们假设，Alice 的公钥为 {p}, g, y}。攻击者可以按照如下方式伪造

1. 选择整数 $i,j$,其中 $gcd(j,p-1)=1$

2. 计算签名，$r\equiv g^iy^j$ mod $p,s\equiv-rj^{-1}$ mod $p-1$

3. 计算消息，$m\equiv si\bmod p-1$

那么此时生成的签名与消息就是可以被正常通过验证，具体推导如下：
$y^rr^s\equiv g^{dr}g^{is}y^{js}\equiv g^{dr}g^{djs}g^{is}\equiv g^{dr+s(i+dj)}\equiv g^{dr}g^{-rj^{-1}(i+dj)}\equiv g^{dr-dr-rij^{-1}}\equiv g^{si}$ mod $p$
又由于消息 m 的构造方式，所以

$$g^{si}\equiv g^m\bmod p-1$$ 需要注意的是，攻击者可以伪造通过签名验证的消息，但是他却无法伪造**指定格式**的消息。而且，一旦消息进行了哈希操作，这一攻击就不再可行。

