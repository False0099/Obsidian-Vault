## 朴素算法：
### 1. 密钥生成：
1. 选择一个大素数 $p$,并选择 $g$ 为 $p$ 的生成元，即 $g$ 是群 $\mathbb{Z}_p^*$ 中的一个元素，其阶是 $p-1$,即
$$g^{p-1}\equiv1\pmod p。$$
2. 选择一个私钥 $x\in[1,p-2]$ (一个随机整数)。这个私钥必须保密。

3. 计算公钥 $y:$
$$y=g^x\pmod{p}$$
公钥 $y$ 可以公开，私钥 $x$ 必须保密。
密钥对是：
1. 私钥 $x$
2. 公钥 $(p,g,y)$
### 签名过程：
设待签消息为 m, 签名者选择随机数 $k\in_RZ_{p^{\prime}\text{;计算：}}^*$$$\begin{aligned}&r\equiv g^k(mod\:p)\\&s\equiv[h(m)-xr]k^{-1}(mod\:(p-1))\end{aligned}$$
其中 $k^{-1}$ 表示我们的 k 对于我们的 $p-1$ 的逆元。

则对消息 m 的数字签名为 (r, s), 其中 h 为安全的 Hash 函数

对于签名过程，我们从下面的角度理解：
1. **可以被验证**，这一点要求我们给出的 `key,rand` 要求在验证的式子中以一个**可计算形式给出**，并且要求这一个可计算的形式是一个**单向函数**，于是显然在 Elgamma 体制中，应该采用 $g^{r}$ 的方法进行处理。

2. 要求**不能伪造**，这就要求我们的 $key,rand$ 之间要以一定的形式耦合起来，不能两者拆分，否则因为我们前面的**可验证性**，我们的可以通过公开的信息就去伪造身份，显然不可取。

3. 要求我们**能够构造出来**，即对于一切一切的 $H(m)$，都是可以签名的，这一点就让狗屎构造 $g^{H(m)}=g^{key*r}$ 这一种验证方法失效。~~给你糖丸了~~

因此，对于我们的第一点可以被验证，我们显然和我们的第二点结合起来，要求我们的各个验证的 `key,rand` 必须以或者大部分情况**必须与**$g^{x}$ 结合起来，因此，我们最后的形式也是类似于这样的。

于是，我们根据我们的第二点要求，我们的当中必须包含项：
$g^{kg^{r}}$，同时由于我们的第三点要求，我们还需要一些随机性用于构造，因此我们有了另外一项 $g^{rs}$。因此，我们就完成了我们的消息签名算法中最最最最重要的设计部分。


### 验证过程：
验证过程根据我们的设计，其实是 trival 的。跟着算就行了
签名接收者 B 收到消息 m 和签名 (r, s)后，首先计算 h (m), 然后验证下列等式是否成立
注意到，无论是签名还是加密，都绕不开一个重要的元素 $y^{r}$。
这一个元素可以说是数字签名算法中最重要的部分。因为这一个部分，满足 $y$ 是一个
$$y^rr^s\equiv g^{h(m)}(mod\mathrm{~}p)$$

如等式成立，则签名有效；否则，签名无效。


## 完全破解：
如果签名者复用了随机数 k, 那么攻击者就可以轻而易举地计算出私钥。具体的原理如下：假设目前有两个签名都是使用同一个随机数进行签名的。那么我们有，那么这个时候，我们的未知量就变成了一个，可以通过发送**不同的信息，得到二元二次方程**，之后再去求解即可。

$$r\equiv g^{k}\bmod p\\s_{1}\equiv(m_{1}-dr)k^{-1}\bmod p-1\\r\equiv g^{k}\bmod p\\s_{2}\equiv(m_{2}-dr)k^{-1}\bmod p-1$$

进而有

$$s_1k\equiv m_1-dr\bmod p-1\\s_2k\equiv m_2-dr\bmod p-1$$

两式相减

$$k(s_1-s_2)\equiv m_1-m_2\bmod p-1$$

这里，$s_1,s_2,m_1,m_2,p-1$ 均已知，所以我们可以很容易算出 k。当然，如果
$gcd(s_1-s_2,p-1)!=1$ 的话，可能会存在多个解，这时我们只需要多试一试。进而，我们可
以根据 s 的计算方法得到私钥 d, 如下

## 通用伪造签名：
攻击条件 १

## 原理

如果消息 $m$ 没有取哈希，或者消息 $m$ 没有指定消息格式的情况下攻击成立。
在攻击者知道了某个人 Alice 的公钥之后，他可以**伪造 Alice 的签名**信息。具体原理如下：
这里我们假设，Alice 的公钥为 {p}, g, y}。攻击者可以按照如下方式伪造

1. 选择整数 $i,j$,其中 $gcd(j,p-1)=1$

2. 计算签名，$r\equiv g^iy^j$ mod $p,s\equiv-rj^{-1}$ mod $p-1$

3. 计算消息，$m\equiv si\bmod p-1$

那么此时生成的签名与消息就是可以被正常通过验证，具体推导如下：
$y^rr^s\equiv g^{dr}g^{is}y^{js}\equiv g^{dr}g^{djs}g^{is}\equiv g^{dr+s(i+dj)}\equiv g^{dr}g^{-rj^{-1}(i+dj)}\equiv g^{dr-dr-rij^{-1}}\equiv g^{si}$ mod $p$
又由于消息 m 的构造方式，所以

$$g^{si}\equiv g^m\bmod p-1$$ 需要注意的是，攻击者可以伪造通过签名验证的消息，但是他却无法伪造**指定格式**的消息。而且，一旦消息进行了哈希操作，这一攻击就不再可行。

