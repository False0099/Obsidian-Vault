今天我们将讲解哈希函数（Hash Function）的第十一章内容。在接下来的四节课中，我们将分别讲解对称密码和密钥管理。第十三章的内容是第四十九章，而第十二章的后量子密码部分我们将不涉及。现在，我们开始讲解第十一章——哈希函数。

哈希函数在中文中有多种译法，如“散列函数”或“哈希函数”，而在英文中只有“Hash Function”这一种表述。哈希函数是密码学中非常重要的一个密码原语，我们称之为“密码原语”。在本章中，我们将学习为什么需要哈希函数，它的基本原理是什么，以及它的安全属性或安全需求。接下来，我们将重点讲解哈希函数的算法原理及其广泛应用。

首先，我们回顾一下之前学习过的数字签名算法。在数字签名算法中，消息的长度不应超过模数的大小。例如，如果模数是 2048 比特，那么消息的长度也不应超过 2048 比特。然而，在实际应用中，我们需要签名的数据往往远超过 2048 比特。如果使用教科书式的 RSA 算法或 ElGamal 签名算法，我们需要将消息划分为多个分组，每个分组的大小小于 2048 比特，然后分别对每个分组进行签名。

这种签名方式类似于加密算法中的 ECB（电子密码本）模式。然而，这种签名方式存在三个严重的缺点：

1. **计算开销大**：在数字签名中，使用 RSA 算法时需要进行模指数运算。如果消息被划分为 $N$ 个分组，那么需要进行 $N$ 次模指数运算，计算开销非常大。例如，如果我们要对一个 10 GB 的游戏软件进行签名，将其划分为多个 2048 比特的分组，计算开销将非常巨大。

2. **存储开销大**：每个 2048 比特的消息分组对应一个 2048 比特的签名，因此签名的存储开销也非常大。例如，对一个 100 GB 的软件进行签名，签名的存储开销也将达到 100 GB，这在实际应用中是不可行的。

3. **安全问题**：由于消息被划分为多个分组并分别签名，攻击者可以交换这些分组的顺序，接收方无法验证消息的顺序是否被篡改。此外，攻击者还可以删除或替换某些分组，导致接收方无法检测到消息的完整性。

为了解决这些问题，我们可以使用哈希函数。哈希函数能够将任意长度的消息压缩为固定长度的消息摘要（Message Digest）或消息指纹（Message Fingerprint）。例如，SHA-256 哈希函数可以将任意长度的消息压缩为 256 比特的消息摘要。然后，我们只需对消息摘要进行签名，而不是对整个消息进行签名。这样，计算开销和存储开销都大大降低，同时也避免了消息分组带来的安全问题。

哈希函数的作用类似于一个压缩工具，能够将任意长度的消息压缩为固定长度的输出。例如，输入可以是 $N$ 比特的消息，输出则是固定长度的消息摘要，如 256 比特。然后，我们可以使用教科书式的 RSA 算法对消息摘要进行签名，生成一个短小的签名信息 $S$。在传输过程中，消息 $X$ 和签名 $S$ 一起发送，接收方使用验证函数对签名进行验证。

使用哈希函数后，我们只需对 256 比特的消息摘要进行一次模指数运算，而不是对多个 2048 比特的分组进行多次模指数运算，计算开销大大降低。此外，签名的存储开销也显著减少，因为签名的大小仅为 256 比特，而不是与消息长度相同。

在数字签名中，哈希函数的使用还提供了三个重要的安全目标：

1. **消息认证（Message Authentication）**：接收方可以验证消息的来源，确保消息是由发送方签名的。
2. **消息完整性（Message Integrity）**：接收方可以验证消息在传输过程中未被篡改。
3. **不可否认性（Non-Repudiation）**：发送方无法否认其发送的消息，因为只有发送方持有私钥，能够生成有效的签名。

接下来，我们讨论哈希函数的安全性质。哈希函数必须满足以下三个安全需求：

1. **单向性（One-Wayness）**：给定哈希值 $H(X)$，计算原像 $X$ 在计算上是不可行的。即，无法从哈希值反推出原始消息。
2. **抗第二原像攻击（Second Preimage Resistance）**：给定消息 $X_1$ 和其哈希值 $H(X_1)$，找到另一个消息 $X_2$ 使得 $H(X_1) = H(X_2)$ 在计算上是不可行的。
3. **抗碰撞攻击（Collision Resistance）**：找到两个不同的消息 $X_1$ 和 $X_2$，使得 $H(X_1) = H(X_2)$ 在计算上是不可行的。

这些安全性质确保了哈希函数在密码学应用中的安全性。例如，在数字签名中，如果哈希函数不满足抗第二原像攻击，攻击者可以找到一个与原始消息具有相同哈希值的消息，从而篡改签名内容而不被检测到。

此外，哈希函数还面临一种称为“生日攻击”（Birthday Attack）的威胁。生日攻击基于生日悖论，即在 23 个人中，至少有两个人生日相同的概率超过 50%。类似地，对于哈希函数，攻击者可以通过计算大约 $2^{n/2}$ 个消息的哈希值，找到两个具有相同哈希值的消息，其中 $n$ 是哈希值的比特长度。因此，为了抵御生日攻击，哈希值的长度应足够长，通常建议使用 256 比特的哈希值。

总结来说，哈希函数在密码学中扮演着至关重要的角色，特别是在数字签名和消息完整性验证中。通过满足单向性、抗第二原像攻击和抗碰撞攻击等安全性质，哈希函数能够有效保障密码学应用的安全性。

---

以上为修改后的文段，确保了书面化表达，修正了可能的错别字和语序问题，并严格遵循了不简略、不缩写的要求。


以下是修改后的文段，修正了可能的错别字和语序不通畅的部分，并使其更加书面化，公式已用$包裹，未进行任何简略或缩写：

---

哈希函数的构造方法可以分为两大类。第一类是基于分组密码的构造方法，虽然在现实中应用不广泛，但具有一定的理论价值。早期的哈希算法确实基于分组密码设计。第二类则是专门设计的哈希函数，应用更为广泛。接下来，我们将从第二类开始讲解。

首先，我们来看基于分组密码的哈希函数构造方法。以 Merkle-Damgård（MD）构造为例，假设我们使用 AES 加密函数 $E$ 作为基础。AES 加密函数 $E$ 接受两个输入：明文和密钥。假设我们使用 AES-128，密钥长度为 128 比特，分组长度也是 128 比特。因此，输入的分组长度 $B$ 为128比特。

在构造哈希函数时，我们将消息 $X$ 划分为 $N$ 个 128 比特的分组，分别为 $X_1, X_2, \ldots, X_N$。每个分组 $X_i$ 作为明文输入到 AES 加密函数 $E$ 中。此外，加密函数还需要一个密钥 $K$，该密钥由上一次的哈希值 $H_{i-1}$ 生成。假设 $H_{i-1}$ 的长度为 128 比特，经过一个压缩函数 $G$ 处理后，生成 128 比特的密钥 $K$，输入到 AES 加密函数中。

加密函数的输出为 128 比特的密文，该密文与明文分组 $X_i$ 进行异或运算，生成中间哈希值 $H_i$。对于第一个分组 $X_1$，初始哈希值 $H_0$ 是一个固定的常数，通常设置为全零或其他固定值。经过 $N$ 轮迭代后，最终的哈希值 $H_N$ 即为消息 $X$ 的哈希值。

需要注意的是，如果中间哈希值 $H_{i-1}$ 的长度大于 128 比特，则需要通过压缩函数 $G$ 将其压缩为 128 比特，才能作为密钥输入到 AES 加密函数中。因此，压缩函数 $G$ 的作用是将长于 128 比特的中间哈希值压缩为128比特。

然而，使用 AES-128 构造的哈希函数并不安全。根据生日攻击，对于 128 比特的哈希值，找到碰撞的计算复杂度为 $2^{64}$，远低于计算安全性的门槛值 $2^{80}$。因此，使用 AES-128 构造的哈希函数在实际应用中是不安全的。

接下来，我们介绍专门设计的哈希函数，即 MD 4 家族。MD 4 是由 Rivest 设计的，后续基于 MD 4 又发展出了 MD 5、SHA-1、SHA-2 等算法。MD 5 的输出长度为 128 比特，但由于其抗碰撞性较弱，已被证明存在碰撞。2004 年，中国密码学家王晓云教授成功找到了 MD 5 的碰撞，标志着 MD5不再安全。

SHA-1 是 MD 5 的后续版本，输出长度为 160 比特，但也已被找到碰撞。目前广泛使用的是 SHA-2 系列，包括 SHA-224、SHA-256、SHA-384 和 SHA-512 等。SHA-256 的输出长度为 256 比特，能够有效抵御生日攻击，计算复杂度为 $2^{128}$，远高于安全门槛值 $2^{80}$。

SHA-2 系列基于 Merkle-Damgård 迭代结构构造。消息首先被划分为 512 比特的分组，每个分组经过 64 轮压缩函数处理后，生成 256 比特的中间哈希值。最终，经过多轮迭代后，输出 256 比特的哈希值。

SHA-3 是新一代的哈希函数，采用海绵结构（Sponge Construction）设计，与 MD 4 家族的 Merkle-Damgård 结构不同。SHA-3 的设计更加灵活，能够抵御更多的攻击类型。

总结来说，哈希函数的构造方法主要分为基于分组密码的构造和专门设计的哈希函数。基于分组密码的构造方法虽然具有一定的理论价值，但在实际应用中存在安全性问题。专门设计的哈希函数，如 SHA-2 系列，能够提供更高的安全性，广泛应用于密码学领域。

---

以上为修改后的文段，确保了书面化表达，修正了可能的错别字和语序问题，并严格遵循了不简略、不缩写的要求。