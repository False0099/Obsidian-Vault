>对于传统的，直接计算数字签名的时候，至少有三个缺点：
>1. 计算开销大
>1. 通信开销，存储开销大
>2. 安全问题

>于是，可以先计算消息摘要，然后再对消息摘要签名。hash 之后，我们可以得到一个摘要，这一个摘要就可以快速的得到最终的答案。

Hash 函数与加密函数不同的是， Hash 函数并不直接使用密钥，它仅是输入消息的函数。Hash 函数 H 的输入是可变大小的消息 M，输出 h 是  
固定大小的 Hash 码

## 定义：
1. 哈希函数将任意长的数据 $M$ 变换为定长的码 $h$,记为 $h=Hash(M)$。一般来说，$h$ 的长度小于原数据 $M$ 的长度。因此，哈希函数是一种**压缩变换**。

安全目标：
1. 单向性：对于任意哈希值 h，想要找到满足 H(x)=h 的 x 在计算上不可行。称 x 是 h 的原像。由 h=H(x)求出 x，称为原像攻击。如果 Hash 函数具有单向性，则称其为是抗原像攻击的。设 h 码长度为 n，且 Hash 函数是等概分布的，则对任意输入 x 产生的 H(x)恰好为 h 的概率是 $1/2^n$。因此穷举攻击对于单向性求解的复杂度为 $O( 2^n)$

2. 抗弱碰撞性：对于任意消息 x,找到满足另一消息 y,满足 H(x)=H(y),在计算上不可行。否则，攻击者可以截获报文 M 及其 H(M)，并找出另一报文 M′使得 $H(M')$ = $H(M)$。这样攻击者可用 M′去冒充 M，而收方不能发现。

3. 抗强碰撞性：找到任意一对满足 H(x)=H(y)的消息 x 和 y 在计算上不可行。找到任何满足 H(x)=H(y)的偶对(x， y)在计算上是不可行的。如果攻击者能够自己选择消息给签名者 A 签名，并能够找到一对不同的消息 x,x，使得 H (x)=H (x’)，那么攻击者先让 A 对 x 签名，然后就伪造出 x 的合法签名。

![[Pasted image 20241224213557.png]]

![[Pasted image 20241224213833.png]]

## 使用方式：
![[Pasted image 20241228162143.png]]

## 生日攻击：
在密码学中，生日攻击利用的是概率论中的生日问题原理，即在一个足够大的集合中随机选择元素，会比预期更快地找到重复的元素。对于哈希函数，这意味着找到两个不同的输入，它们产生相同的哈希输出（即哈希碰撞）的概率比直觉上认为的要高。

如果哈希函数的输出是 $n$ 位长, 那么输出空间的总大小是 $2^n$ 。根据生日悖论, 找到至少一对具有相同哈希值的不同输入的概率接近 $50\%$ 需要大约 $1.2\sqrt{2^n}$ 次尝试, 即大约 $2^{n/2}$ 次尝试。

生日攻击通常用于破坏具有固定长度输出的加密哈希函数，如 MD 5 或 SHA-1。通过这种攻击，攻击者可以生成两个具有相同哈希值的不同文档，这在数字签名和证书验证中可能导致安全问题。

## 类型：
根据 Hash 函数的压缩函数的结构不同，可将其分为以下三种类型。
1. 压缩函数迭代型的 Hash 函数
压缩函数由一些简单的非线性函数和线性函数组成。对一个数据分组的处理中用压缩函数多次**迭代压缩**。如果输入数据很长，将其分成一系列的数据分组，在各个数据分组之间再进行迭代处理。
目前广泛应用的主要是这种类型的 Hash 函数。中国商用密码 SM 3 和美国 NIST 的 SHA-3, 都是这种类型的 Hash 函数。

2. 基于对称密码的 Hash 函数
对称密码已经十分成熟，可以利用它设计 Hash 函数。安全性和数据处理速度取决于所使用的对称密码。目前有许多强分组密码，都可设计 Hash 函数。基于序列密码设计 Hash 函数较少。 ZUC 的 MAC 是一个例子。

3. 基于数学困难问题的 Hash 函数：
已经找到大量的困难问题， NP 问题和 NPC 问题。基于困难问题设计出许多公钥密码，也可以设计 Hash 函数。具体地: 1. 基于困难问题设计构成压缩函数 2.对输入数据进行迭代压缩处理 3.最后产生出 Hash 码。


## 迭代哈希一般模型：
目前使用的大多数哈希函数如 MD5，SHA) 其结构都是迭代型的，如图6-5所示。其中函数的输《M 被分为 L 个分组 $Y_0,Y_1,\cdots,Y_{L-1}$,每一个分组的长度为 b 比特，最后一个分组的长度不够的话，需对其德填充。最后一个分组中还包括整个函数输入的长度值，这样一来，将使得敌手的攻击更为困难，即敌手若想成功地产生假冒的消息，就必需保证假冒消息的哈希值与原消息的哈希值相同，而且假冒消息的长度也要与原消息的长度相等。

![[Pasted image 20241224221347.png]]

### 分组：
将输入 M 分为 L-1个大小为 b 位的分组:
M0  ， M1， M2， …， ML-2  
填充：若第L-1个分组不足b位，则将其填充为b位。  
附加：再附加上一个表示输入长度的分组。
填充和附加之后，共 L 个大小为 b 位的分组。 M0 ，M1，M2，…，ML-2，ML-1  

由于输入中包含长度，所以攻击者必须找出**具有相同 Hash 值且长度相等**的两条报文，或者找出两条长度不等但加入报文长度后 Hash。

### 压缩：
压缩函数由一些简单的非线性和线性函数组成。如果输入数据很长，将其分成一系列的数据分组 $M_{0}，M_{1}，M_{2}，…，M_{L-1}$ ，对数据进行两层迭代压缩处理：对一个数据分组 Mi 的处理中用压缩函数多次迭代压缩。在各个数据分组之间再进行迭代压缩处理。


