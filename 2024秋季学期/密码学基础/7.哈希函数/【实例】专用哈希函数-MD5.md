>注意，MD 5 哈希函数已经不安全，一般的 MD5 的碰撞都可以在如下网上获取到 https://www.cmd5.com/ ， http://www.ttmd5.com/ 。同时，SHA 1 也已经不安全，已经可以构造出两个有着相同 hash 值的 pdf 文件

## T 表生成：
对于在我们的哈希的轮函数中，我们可能涉及到我们的 $T$ 表，对于 $T$ 表，我们考虑怎么使用，对于我们的 64 的元素，我们对于第 $i$ 个元素，他对应的 $T[i]=2^{32}*\sin(i)$。

## 函数：
$F$ 函数，实质上就是一个位运算函数，例如：我们的输入有三个 $x,y,z$，三个输入都是（），我们最后 $F$ 函数的输出应该是 $x\land y\lor(\neg x)\land z$。

$G$ 函数，也是一个位运算函数，定义为：$G(x,y,z)=(x \land z\lor y) \land (\neg z)$

$H$ 函数，定义为：$ H(x,y,z)=x\oplus y\oplus z$

$I$ 函数，定义为: $I(x,y,z)=x\oplus(y\lor (\neg z))$ 



MD5算法采用图6-5描述的迭代型哈希函数的一般结构，如图6-6所示。算法的输入为任意长的消息(图中为 K 比特) .分为512比特长的分组，输出为128比特的消息摘要。
![[Pasted image 20241228163044.png]]

## 消息填充：
首先，将我们的输入数据转换为**十六进制数据**。

对消息填充，使得其比特长在**模512下为448**，即填充后消息的长度为512的某一倍数减64，留出的64比特备第2步使用。填充方式是固定的：第1位为1，其后各位皆为0。

之后，我们需要获取**消息的长度**，填充到我们的末尾 64 位置，按照**小端序方式填充**。即人类书写方法的 reverse。

![[Pasted image 20241228164658.png]]

![[Pasted image 20241228164721.png]]

![[Pasted image 20241228164741.png]]
 

## 消息分组：
前两步执行完后、消息的长度为512的倍数(设为 L 倍),则可将消息表示为分组长为512的一系列分组 $\gamma_0,\gamma_1,\cdots,Y_{L-1}$ 。而每一分组又可表示为16个32比特长的字，则消息中的总字数为 $N=L\times16,因此消息又可按字表示为 M[0,\cdots,N-1]$。


## 缓冲区初始化：
(3)对 MD 缓冲区初始化算法使用128比特长的缓冲区以存储中间结果和最终哈希值，缓冲区可表示为四个32比特长的寄存器(A,B,C,D),每个寄存器都以小端方式存储数据，其初值取为(以存储方式)A=01234567, B=89ABCDEF,C=FEDCBA98,D=76543210,实际上为67452301,EFCDAB89,98BADCFE,10325476。

## 分组处理：

(4)以分组为单位对消息进行处理每一分组 $Y_\pi(q=0,\cdots,L-1)$
都经一压缩函数 $H_{\mathrm{моs}}$ 处理。$H_\mathrm{MDS}$ 是算法的核心，其中又
有 4 轮处理过程，如图 6-7 所示。
![[Pasted image 20241228163453.png]]
其中我们的 $IV$ 就是我们之前经过处理的缓冲区。

## 压缩函数：

处理过程可总结如下：
$$\begin{aligned}&CV_{0}=IV\\&CV_{q+1}=CV_{q}+RF_{l}[Y_{q},RF_{H}[Y_{q},RF_{G}[Y_{q},RF_{F}[Y_{q},CV_{q}]]]]\\&MD=CV_{L}\\\end{aligned}$$
其中 IV 是步骤(3)所取的缓冲区 ABCD 的初值，$Y_q$ 是消息的第 q 个512比特长的分组，L 是消息经过步骤(1)和步骤(2) 处理后的分组数，$CV_q$ 为处理消息的第 q 个分组时输入的链接变量(即前一个压缩函数的输出), $RF_x$ 为使用基本逻辑函数 x 的轮函数，+为对应字的模 2 $^{32}$ 加法，MD 为最终的哈希值



## 安全性：
Rivest 猜想作为128比特长的哈希值来说，MD5的强度达到了最大，比如说找出具有相同哈希值的两个消息需执行 $o$ (2 $^{64})$ 次运算，而寻找具有给定哈希值的一个消息需要执行 $(O_{12}^{[\mathrm{m},\mathrm{m},\mathrm{m}]}$ 次运算。然而，2004年，仙东天学王小云等成功找出了 MD5的碰撞，发生碰撞的消息是由两个1024比特长的串 $M$、$N_i$ 构成，设消息 $M\|N_i$ 的碰撞是 $M^\prime\|N_i^{\prime}$,在 IBM P690上找 $^\prime M$ 和 $M^\prime$ 花费时间大约一小时，找出 $M$ 和 $M^{\prime}$ 后，则只需15秒至5分钟就可找出 $N_i$ 和 $N_i^{\prime}$。

