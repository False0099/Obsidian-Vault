## 朴素算法
### 密钥生成：

· 选择两个大素数 $p$ 和 $q$,计算它们的乘积 $n=p\times q$, $n$ 用作公钥和私钥的一部分。

· 计算 $\varphi(n)=(p-1)(q-1)$,这是欧拉函数。

·选择一个整数 $e$,满足 $1<e<\varphi(n)$ 且 $e$ 与 $\varphi(n)$ 互质。通常选取 $e=65537$ (一个常用的公开指数)。

· 计算私钥 $d$,使得 $d\times e\equiv1\left({\mathrm{mod}}\varphi(n)\right)$。即 $d$ 是 $e$ 的模 $\varphi(n)$ 逆元。这样，生成了一个公钥 $(e,n)$ 和私钥 $(d,n)$ 。

### 签名算法：

假设发送者要签署一条消息 $M$。过程如下：
· 消息摘要：首先，通过哈希函数 (例如 SHA-256)对消息 $M$ 进行哈希处理，得到消息的摘要$H(M)$。
· 签名生成：使用发送者的私钥 $d$ 对消息摘要进行加密，得到数字签名 $S$,即$$S=H(M)^d\pmod{n}$$
其中 $H(M)$ 是消息的哈希值，$d$ 是私钥，$n$ 是公私钥对中的公钥模数。签名 $S$ 就是这个经过加密的消息摘要，它与原始消息 $M$ 绑定在一起，作为数字签名一起发送。

###  签名验证
接收者收到消息 $M$ 和数字签名 $S$ 后，进行签名验证：
>消息摘要：接收者同样对消息 $M$ 使用相同的哈希函数计算消息摘要 $H(M)$。

>签名解密：接收者使用发送者的公钥 $e$ 对数字签名 $S$ 进行解密，得到签名生成时使用的原始消息摘要：
$$H(M)'=S^e\pmod{n}$$其中，$S$ 是签名，$e$ 是公钥，$n$ 是公钥中的模数。

>验证：如果接收者计算的消息摘要 $H(M)$ 和解密得到的 $H(M)^{\prime}$ 相同，说明签名有效，验证通过。反之，如果不相同，则签名无效。


### 安全性分析：
注意到，上述的算法是不安全的，存在**伪造攻击**，假设 `Bob` 生成了一个公司要对，其中 $K_{pr}=d$, $K_{\pu{ b }}=(n,e)$。

我们存在中间人 `O`,我们选择一个**签名过后的信息** $s$,计算 $x=s^{e}\text{ mod n}$。也就是说，我们可以只知道我们的 $(n,e)$ 和部分的信息 $s$，就可以取伪造信息。虽然信息的内容可能是**无意义的**。



## 更安全的算法：
我们需要对于我们的信息进行**填充**，先对我们的消息进行填充。广泛应用的是**概率签名方案**，简称为 `PSS`.这一种算法又叫做 RSA-PSS 方案。
>注意，上述方案不影响 RSA，只影响 RSA 的**加密部分**。
### RSA-PSS 方案：
首先，我们有一个任意长度的消息：记为 $M$,之后，我们队内容进行**哈希**，之后变为一个长度为 $d$ 的部分。

之后，对**哈希后的内容进行替换**，在前面添加一些常信息，并在后方添加随机数。这一份信息记为 $M'$

对于 $M'$ 信息，再去进行哈希函数，得到我们的 $H$,直接输出为编码后的消息。

编码消息的**另一个部分**，由 $H$,与一个掩码生成函数 `mask generation function`。与我们的另一个 `padding+salt` 进行异或，得到我们的掩码部分。


![[Pasted image 20241209115110.png]]

#### 步骤1：计算消息的哈希值
1. 对消息 M 计算其哈希值 H(M)，常用的哈希函数包括 SHA-256、SHA-512等。
$$H(M)=\mathrm{Hash}(M)$$

#### 步骤二：生成随机盐值
>RSA-PSS 要求使用随机数 (盐值)来填充消息哈希，确保每次签名生成的结果都是不同的。这是 RSA-PSS 的关键，防止攻击者通过分析签名推算其他签名。

1. 生成一个大小为 $k-1-$ HashLen 位的随机盐值 $r$,其中 $k$ 是模数 $n$ 的比特长度，HashLem 是哈希函数输出的比特长度 (例如，SHA-256 的输出长度为 256 位)。

2. 填充这个随机盐值 $r$ 到消息摘要的后方，并且在我们的签名方案的前方填充一个固定的Padding。使得签名具有不可预测性。

$$
M'=Padding_{1}+H(M)+salt
$$

#### 步骤三：构造输入消息块：
将消息的哈希值 $H(M)$ 和随机盐值 $r$ 结合起来，构造一个新的数据块，这个数据块将被签名。这个步骤使用 RSA-PSS 的填充函数 (PSS Padding Function) 进行。

构造的步骤如下：
1. 对哈希值和盐值进行组合，形成一个新的消息块 $M^{\prime}$,并将其填充成固定长度。
$$
DB=padding_{2}+salt
$$

2. 对于之前的哈希值，再次进行处理：
$$
H=H(M')
$$

3. 通过掩码生成函数（MGF），生成一个掩码
$$
Mask=MGF(H)
$$

4. 最终我们的信息就可以通过下面的方法进行处理：
$$
M=Mask\oplus DB+H
$$

### 签名认证：


![[Pasted image 20241209115420.png]]

### RSA-FDH 数字签名算法:
我们不直接对我们的消息进行签名，我们直接对我们的消息的哈希值进行签名，这样可以保证被签名的内容难以被伪造。