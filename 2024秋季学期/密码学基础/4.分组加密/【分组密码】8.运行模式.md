我们前面的内容都只研究了我们的**一组数据的情况**，我们的运行模式就是介绍我们**多组数据运行时候，应该怎么处理**。
>分组加密会将明文消息划分为固定大小的块，每块明文分别在密钥控制下加密为密文。当然并不是每个消息都是相应块大小的整数倍，所以我们可能需要进行填充。

分组加密不仅可以用来加密，还可以用来进行伪随机数发生器，消息鉴别码，哈希算法。甚至其他的密码协议。

## 字节填充：
现在我们要把信息填充到 8 的倍数个字节，还得能无歧义地恢复。PKCS #5 就是用来干这个事的。它的规则是：
· 若原文长度不是 8 的倍数，则设其模 8 为 p, 在消息后面填充 (8-p) 个 (8-p).
· 若原文长度是 8 的倍数，则往消息后面填充 8 个 \x 08 .为什么原文长度已经是 8 的倍数时，还要进行填充？这是为了消除歧义。假设信息本来就是 hello\xes\xeandang , 长度为 8，如果不再填充，解码时可能就认为原文是“hello”.要解码 PKCS #5 填充的数据，解码器直接去看整个数据的最后一个字节 x, 抛弃掉末尾 x 位就得到了原文，这是快速且无歧义的。



## ECB 模式（电子密码本）：

ECB 模式全称为电子密码本模式（Electronic codebook）。

我们每一轮使用的**密钥不变，采用的加密方式不变**，这一种方法是安全性不够安全的的，这一种方法，**不能够隐蔽明文的统计规律和结构规律**。如果我们知道了我们采用这样的内容，相同的密文对应相同的明文。相同的明文映射为相同的密文。
![[Pasted image 20241216105313.png]]
因此，对于采用 ECB 模式的加密，我们可能采用一种**身份伪造攻击**。
![[Pasted image 20241230214555.png]]

优点在于错误不会扩散，可以并行化运算

## CBC 模式（分组连接）：
安全的原因在于我们是**概率加密**，我们相同的信息加密道德内容是**不同的**。

CBC 全称为**密文块链接** (Cipher-block chaining) 模式，CBC（Cipher-block chaining，密码块链接）模式需要一个初始向量 IV. 加密过程中，先把 IV 与第一块明文混合，再交由 DES 加密；对于下一块，其 IV 采用这一块的加密结果。这里
 · IV 不要求保密
 · IV 必须是不可预测的，而且要保证完整性。

CBC 模式适用于对文件进行加密，特别是对于那些需要较高安全性的文件。例如，企业的机密文档、个人的重要数据等。通过使用 CBC 模式，可以有效地保护文件的内容不被未经授权的人访问。

该模式种，我们引入了一个**初始向量 IV**，作为我们的数据进行处理加密。用来**消除我们的原本数据的特征信息**，相当于引入了一个**非线性运算**。

假设 $e()$ 表示分组大小为 $b$ 的分组密码，$x_{i},y_{i}$ 表示长度为 $b$ 的明文和密文， $IV$ 表示长度为 b 的 nonce。那么我们的加密遵循下面的规则，这种规则下，我们选择影响明文，让**明文之间互相影响**：
$$\begin{aligned}&y_1=e_k(x_1\oplus IV)\\&y_i=e_k(x_i\oplus y_{i-1}),\quad i\geq2\\&x_1=e_k^{-1}(y_1)\otimes IV\\&x_i=e_k^{-1}(y_i)\oplus y_{i-1},\quad i\geq2\end{aligned}$$

因此，对于我们的这一种方法，我们在实际的传输中，要求我们的**IV**是一个双方都清楚的值，这个的实现可以通过某一个计数器，也可以通过某一个**可靠的信道**进行传输。也可以通过 $D-H$ 算法进行传输、。

遗憾的是，我们的内容不能**预处理，不能并行计算**，单个比特错误会延展。

### 字节反转攻击

原理
字节反转的原理十分简单，我们观察解密过程可以发现如下特性：
· IV 向量影响第一个明文分组
·第 n 个密文分组可以影响第 n+1 个明文分组

假设第 $n$ 个密文分组为 $C_n$,解密后的第 $n$ 个明文分组为为 $P_n$。然后 
$P_{n+1}=C_n$ xor $f(C_{n+1})$。其中 $f$ 函数为图中的 Block Cipher Decryption。

对于某个信息已知的原文和密文，然后我们可以修改第 $n$ 个密文块 $C_{n}$ 为 $C_n$ xor $P_{n+1}$ xor $A_\mathrm{}$。然后再对这条密文进行解密，那么解密后的第 $n$ 个明文快将会变成 $A_{\text{。}}$

![[Pasted image 20241216111230.png]]

注意在加密时，明文中的微小改变会导致其后的全部密文块发生改变，而在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化，而解密时，密文中一位的改变只会导致其对应的明文块完全改变和下一个明文块中对应位发生改变，不会影响到其它明文的内容。

此攻击方法的精髓在于：通过损坏密文字节来改变明文字节。（注：借助 CBC 内部的模式）借由此可以绕过过滤器，或者改变用户权限提升至管理员，又或者改变应用程序预期明文以尽猥琐之事。



### 应用：
利用 CBC 进行完整性验证：
![[Pasted image 20241117235322.png]]

## OFB（输出反馈）
OFB 全称为输出反馈模式（Output feedback），其反馈内容是分组加密后的内容而不是密文。我们的思想是，将我们的**分组密码中引入流密码**。它将分组密码算法中的密钥作为一个**伪随机数生成器**，生成与明文长度相同的**密钥流**，然后将明文与密钥流进行异或操作得到密文。

也就是将我们的原本的 CFB 模式中的输出**只当作一个密钥**，然后再去与明文进行异或操作得到最终结果，

好处是在于，相较于 CBC，可以进行**预先处理了**，即使不知道明文是什么，我们也可以通过预处理的方法得到加密需要的密钥

![[Pasted image 20241230221635.png]]


>初始化：首先选择一个初始向量（Initialization Vector，IV），它与密钥一起作为输入，送入分组密码算法进行加密。加密后的结果作为第一个密钥流块。

>加密过程：对于每个明文块，将上一次加密后的结果（即密钥流块）再次送入分组密码算法进行加密，得到新的密钥流块。然后将**明文块与密钥流块**进行异或操作，得到密文块。相比之下，迭代的内容，增加了**密文块**。


>解密过程：解密过程与加密过程类似，只是将异或操作的顺序颠倒过来。对于每个密文块，将上一次加密后的结果（即密钥流块）再次送入分组密码算法进行加密，得到新的密钥流块。然后将密文块与密钥流块进行异或操作，得到明文块。图3-4所示。

![[Pasted image 20241216111425.png]]


加密 (第一个分组): $s_1= e_k( IV)$,且 $y_1=s_1\oplus x_1$
加密 (一般分组): $s_i= e_k( s_{i- 1})$,且 $y_i=s_i\oplus x_i,i\geq2$
解密 (第一个分组): $s_1=e_k(IV)$,且 $x_1=s_1\oplus y_1$
解密 (一般分组): $s_i= e_k( s_{i- 1})$, 且 $x_i= s_i\oplus y_i$, $i\geq 2$


![[Pasted image 20241118084058.png]]




## CFB（密码反馈）：
CFB（Cipher feedback，密文反馈）是一种接近于**流密码**的工作模式。它不用 DES 加密明文，而是把 **DES 作为伪随机数生成器**，把 IV 作为种子。这样就可以从 IV 和指定的 key 生成字节流，然后把明文与这个字节流异或。

CFB 模式中，每次加密明文的一个字节。故 CFB 模式不需要添加Padding. 工作流程如下：
![[Pasted image 20241219104254.png]]

加密过程中，维护了一个寄存器 `reg` ，长度为 64-bit，初始值为 IV. 每次对明文的一个字节进行加密时，把这个 `reg` 交给 DES 加密，生成一个 64-bit 的结果 `K`；然后把 `K` 的高 8-bit 与明文的这一个字节异或，得到了一个字节的密文。接下来，把这个 8-bit 密文补充到移位寄存器 `reg` 的最右边，抛弃 `reg` 此前的高 8 位。


## 计数器模式 (CTR）：

计数器模式可以看做是 OFB 模式的简化版本，其输入是由计数器来更新，即将加密函数看作是一个**密钥流产生器**，利用固定密钥 $k$ 对自然数序列 $1,2,3,\ldots,n,\ldots$ 加密，将得到的**密文分组序列看作密钥流序列**，按加法密码的方式与明文分组逐位异或。

利用这种方式可以产生伪随机数序列，其伪随机特性远比计算机产生的随机数的性质好。
如图所示，加密前首先对计数器进行初始化，然后在密钥的控制下，加密计数器的内容，得到密
文，作为加密明文的密钥。根据明文分组，将计数器顺序+1, 来产生加密的密钥。

假设 $e$ ()是一个分组大小为 $b$ 的分组密码，$x_i$ 和 $y_i$ 表示长度为 $b$ 的位字符串。初始值 $IV$ 和计数器 $CTR_i$ 的连接表示为 $(IV\|CTR_i)$,也是一个长度为 $b$的位字符串。

加密：$y_i=e_k(IV\parallel CTR_i)\oplus x_i,i\geq1$
解密：$x_i= e_k( IV\parallel CTR_i) \oplus y_i$, $i\geq 1$

![[Pasted image 20241117235449.png]]


