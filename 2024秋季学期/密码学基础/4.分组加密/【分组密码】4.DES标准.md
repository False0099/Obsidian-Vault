## 参数：
DES 的功能是：给定一个 64 位的明文和一个 64 位的密钥，即要求分组中每一组的大小中的每一位都必须是一个长度为 64bit 的明文。最后，DES输出一个 64 位的密文。这个密文可以用相同的密钥解密。
>所谓“64位的密钥”，其实里面只有56位在起作用。剩余的位可以直接丢弃，或者当作奇偶校验位。也就是说，DES**分组长度**为 64bit，**密钥长度**为 56bit，

DES 算法通常下面的几个阶段：

>密钥扩展：输入64位密钥，扩展成16轮的轮密钥 K1, K2,…,K16


>轮变换：每一轮核心运算，输入右分组(32位), 轮密钥(48位)，输出32位


>加解密：输入明文64位，进行一次初始置换 IP，对置换后的数据 X0分成左右两半 L0与 R0，利用轮函数 f 实施16次轮变换，得到 L16与 R16，最后进行逆初始置换 IP-1，得到密文64位

>DES的加密和解密几乎一样，不同之处在于加密时输入是明文，子密钥使用顺序为K1,…,K16；解密时输入是密文，子密钥使用顺序为K16,…,K1。


![[Pasted image 20241219095812.png]]

## 初始置换 IP 层
在初始置换 IP 层，我们需要将 64bit 的输入分成 8bit 和 8bit 的结和，其中前面的 8bit，作为我们的横坐标，后面的 8bit 作为我们的纵坐标，我们根据对应的内容，找到对应的数字是多少，就能得到我们的置换。


## 轮函数层（轮变换）：
>对于十六轮论结构，首先我们由之前的 Feistel 密码结构可以知道，存在一个表达式：
$$
\begin{align}
L_{i+1}=R_{i} \\
R_{i+1}=L_{i}\oplus F(R_{i-1},k_{i})
\end{align}
$$
那么其中我们的 $F$ 又有下面的几个部分组成：
>F=E 扩展+异或+S 盒+P 置换

### F 函数（神经网络）设计：
通过**观察我们的加密轮结构可以知道**，我们的 F 函数整体上应该实现一个 $32bit\to32bit$ 的加密函数，同时我们的**密钥**长度为 $48$ bit，我们可以通过神经网络的框架来描述：
![[Pasted image 20241219100920.png]]
#### E 扩展层：
输入：E 扩展层接受一个长度为 32bit 的明文
输出：输出一个长度为 48 bit 的密文

我们 F 函数在我们的设计如下所示：我们的 F 函数接受一个 32 比特的输入作为铭文，然后同时接受一个 48 位的密钥作为密钥输入。这里，E 扩展层的实现，可以理解为使用了一个映射表，将输入中的某些数据按照特定规则输出即可。

>我们存在一个映射表，可以指定我们最终的的 48 位比特中的每一位来自于我们的哪一个原先位置。就完成了我们的对应的映射。

#### 异或层：
输入：经过 E 扩展后的 48bit 数据，48bit 长的密钥
输出：48bit 数据

将我们的扩展后的数据和我们的密钥进行按位异或，得到一个新的 48 比特的数据（confusion 操作）

#### S 盒层：
输入：48bit 数据
输出：32bit

S 盒的实现本质上还是一个**替换表**

将新的 48 比特的数据分为 8 个部分，每一个部分都是 6 比特。然后我们通过我们的一个 `S盒`，输出一个 4 比特的输出。（confusion 操作）（**需要了解的细节**）
![[Pasted image 20241219102318.png]]

>每一个映射表都包括我们的 $4*16$ 的网格，我们将我们的 6 比特分为下面的几个部分，我们将我们的头尾拼接后的十进制数字作为我们的**横坐标**，我们的剩余部分拼接后转换为十进制数作为我们的**纵坐标**。然后我们查询我们的对应的 $S$ 盒来得到我们的对应的映射。其实也就是构造了一个 6 位数字到 4 比特数字的映射。我们**每一个 S 盒的映射表都不同**，设6比特输入为x = x1x2x3x4x5x6，令i = x1x6，j = x2x3x4x5，则矩阵的(i,j)位置即为对应的输出

> S 盒设计能够抵御我们的**差分密码攻击**，因为我们的 S 盒设计的时候，我们的原输出一旦有一个位置发生变换，就会让我们的结果产生**两个 bit 的位置变换**。并且这两个 bit 的位置不安欢是对应的多个盒子。

根据我们的一个特殊的**内部置换**，重新将我们的 32 位数据输出出来作为我们的最终答案。（比特 permutation 来实现我们的 diffusion）。

## 密钥调度：
可以看到整个算法分为两大部分——迭代加密（左边的 16 轮迭代操作），以及密钥调度（右边生成子密钥的算法）。

所谓密钥调度，就是**从一把 64-bit 的主钥匙，得到 16 把 48-bit 的子钥匙**，然后把这些子钥匙用于迭代加密。那么，如何从一把主钥匙得到 16 把子钥匙呢？

1. 从 64-bit 的主钥匙里面选取特定的 56 位，这一步通过一个 **置换函数 PC 1**，将 64bit 的内容转换为 48bit 的内容。其余的位就没用了。于是我们现在手上有了一个 56 位的布尔数组。把它分成左、右两个半密钥，它们都是 28-bit 的布尔数组。

2. 左、右两个半密钥都左旋（也就是循环左移。整个数组往左移，左边弹出去了的东西补到最右边去）一定位数，这个左移的位数也是指定的。有些轮次是 1 位，有些轮次是 2 位。

3. 把左、右半密钥拼起来，再做一个**置换函数 PC 2**，将 56bit 的内容转换为 48bit 的内容。就得到了这一轮生成的子密钥。这个置换是从 56-bit 的数组里面选取指定的 48 位。所以现在每一轮都可以生成一个 48 位的子密钥。（注意，步骤 3 并不改变左右半密钥）。

4. 重复 步骤 2、步骤 3 一共 16 次，于是得到了 16 个 48-bit 的子密钥。

现在我们手上有了 16 把子密钥。遂开始加密：
1. 输入的明文（长度为 64 的布尔数组）做一个置换(IP置换)。仍然得到 64-bit 的数组（不然就丢失信息了！）
2. 把得到的数组拆成左、右两半边。每边是 32 位长度。
3. 每一轮迭代，都是接收一组 `L, R`，返回 `L', R'` ，作为下一轮迭代的 `L, R` . 迭代过程如下：  
    L′=RR′=L⊕F(R,subkey)其中 F 函数（称为轮函数）是整个算法的核心，功能是：以一个子密钥，加密 32-bit 的信息。
4. 利用之前得到的 16 个子密钥，执行步骤 3 一共 16 次。
5. 将最终的 R 与 L 拼接，再做一次置换(FP 置换)，即得到密文。
![[Pasted image 20240930150739.png]]

### 密码调度算法：
我们接下来将要研究，我们是如何根据我们的长度为 64 bit 的密钥，生成我们的所有总共 16 把长度为 64 位的子密钥的。我们可以通过下面的方法来进行处理：

首先，我们采用“选择置换”，从 64 位 key 中选出 56 位，我们把这 56 位叫做 `PC-1` (选择置换 1)

之后，我们将我们的 56 位从中间截取，分为两个 28 位的密钥，之后，我们每一轮再把左、右半密钥旋转几位，再用我们的 `PC-2` 方法来构造子密钥：

最后，我们就能根据我们的 `PC-2` 来构造出 16 个长度为 48 位的二进制密钥。

## 破解
遗憾的是，我们额 DES 是不安全的，因为他的密钥长度太短了，完全支持我们的直接破解。而为了让我们的密码变得安全，我们应该考虑下面的方法：
1. 3 DES
2. AES

```cpp
#include <bits/stdc++.h>
using namespace std;
// 定义PC1_L和PC1_R的置换表
const vector<int> pc1_l = {57, 49, 41, 33, 25, 17, 9,
                           1, 58, 50, 42, 34, 26, 18,
                           10, 2, 59, 51, 43, 35, 27,
                           19, 11, 3, 60, 52, 44, 36};
const vector<int> pc1_r = {63, 55, 47, 39, 31, 23, 15,
                           7, 62, 54, 46, 38, 30, 22,
                           14, 6, 61, 53, 45, 37, 29,
                           21, 13, 5, 28, 20, 12, 4};

void print_Vec(vector<int> vec){
    for(auto u:vec){
        cout<<u<<" ";
    }
    cout<<endl;
    cout<<endl;
}
// 定义PC1函数
pair<vector<int>,vector<int>> PC1(const vector<int> &key){
    assert(key.size()==64);
    vector<int> left;
    vector<int> right;
    for(int i=0;i<28;i++){
        left.push_back(key[pc1_l[i]-1]);
    }
    for(int i=0;i<28;i++){
        right.push_back(key[pc1_r[i]-1]);
    }
    return make_pair(left,right);
}
pair<string,string> PC1(const string &key){
    assert(key.size()==64);
    string left;
    string right;
    for(int i=0;i<28;i++){
        left.push_back(key[pc1_l[i]-1]);
    }
    for(int i=0;i<28;i++){
        right.push_back(key[pc1_r[i]-1]);
    }
    return make_pair(left,right);
}
vector<int> LeftRotate(vector<int> l,int offset){
    vector<int> r;
    r=l;
    rotate(begin(r),begin(r)+offset,end(r));
    return r;
}
vector<int> PC2(vector<int> l,vector<int> r){
    for(auto u:r){
        l.push_back(u);
    }
    vector<int> arr={   14, 17, 11, 24, 1, 5,
                        3, 28, 15, 6, 21, 10,
                        23, 19, 12, 4, 26, 8,
                        16, 7, 27, 20, 13, 2,
                        41, 52, 31, 37, 47, 55,
                        30, 40, 51, 45, 33, 48,
                        44, 49, 39, 56, 34, 53,
                        46, 42, 50, 36, 29, 32};
    vector<int> res;

    for(int i=0;i<arr.size();i++){

        res.push_back(l[arr[i]-1]);

    }

    //cerr<<res.size()<<endl;

    return res;

}

vector<vector<int>> genKey(vector<int> &key){

    auto [l,r]=PC1(key);

//    print_Vec(l);

    vector<int> off={1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};

    vector<vector<int>> res_Keys;

    for(int i=0;i<off.size();i++){

        l=LeftRotate(l,off[i]);

        //print_Vec(l);

        r=LeftRotate(r,off[i]);

        res_Keys.push_back(PC2(l,r));

    }

    return res_Keys;

}

void AES(vector<int> plain,vector<int> key,string method){

}

int main() {

    string s = "0110011110111000010000000111010100010111010111100011111111110011";

    vector<int> t;

    for(auto u:s){

        t.push_back(u-'0');

    }

//    cout << "Binary string: " << s << endl;

  

//    bitset<64> a(s);

  

    auto u=genKey(t);

    for(auto v:u){

        assert(v.size()==48);

        print_Vec(v);

    }

    return 0;

}
```

