我们的 AES 标准，扩展了我们的原来的 DES 标准中的单个分组的大小，我们原本的 DES 输入是 64 比特，现在我们的输入为 128 比特。

并且，我们的**密钥长度是可变的**，如果我们的密钥长度为 128 对应 4 轮迭代，192 对应 12 轮迭代，256 对应 14 轮迭代。

我们的这一个既包括我们的扩散，也包括我们的混淆运算。
## 基本架构：
![[Pasted image 20241118001327.png]]
我们的对应的内容就是我们的一轮的内容。
我们其中，我们的 Key Addition 层就是将我们的铭文和我们的对应的密钥进行混肴，从而混淆我们的最终结果和我们的对应的内容产生错误。之后，我们还有我们的 `Byte Substitution` 层，该层是一个非线性层，从而**防止我们的对应的内容被我们破解**。

接下来是扩散层，在扩散层中，我们一般使用我们的扩散增，通过我们的行移位，列混淆来将我们的一个字符的变化，扩展到我们的若干字符的变换。以分组长度和密钥长度均为 128 bit 为例

## 输入排列：
·将 128 bit 的分组分为 16 个字节，并排成 4 乘 4 的矩阵
$$\begin{bmatrix}b_0&b_4&b_8&b_{12}\\b_1&b_5&b_9&b_{13}\\b_2&b_6&b_{10}&b_{14}\\b_3&b_7&b_{11}&b_{15}\end{bmatrix}$$
$•$ 每一列为一个字 (word), 即 4 字节
## 密钥白化：
在现代密码学中，密钥白化（Key Whitening）是一种增强密码算法安全性的技术。它的核心思想是在复杂操作之前和之后引入可逆操作（通常为异或运算）。从而增加攻击者进行分析和推测的难度。也就是我们的**以密钥加结尾，以密钥加结束**。

引入我们的密钥白化的原因，是因为我们如果没有我们的密钥白化，我们可能会导致我们可以根据我们的对应的字节替换或者我们的行变化**没有任何意义**，因为这一个运算的过程是**公开且可逆的**。


## 字节替代层：
我们的字节替代层，输入是一个字节，也就是 8bit 的数据，在我们的 AES 中，我们的所有的 S 盒都是相同的，我们的对应的替换孙发中，我们的替换原则是，根据我们的**输入的字节**找到一个对应的 $GF(2^{m})$ 关系下的逆元，然后在对这一个逆元隐形线性变换，最后等价于得到一个**替换表**。实现从**一个字节到另一个字节的映射**，这一个背后的数学原理是 $2^{8}$ 下每一个字节对应的乘法逆元。目的是为了混淆**密钥与密文的特征**。

```
63 7c 77 7b f2 6b 6f c5 30 01 67 2b fe d7 ab 76 
ca 82 c9 7d fa 59 47 f0 ad d4 a2 af 9c a4 72 c0 
b7 fd 93 26 36 3f f7 cc 34 a5 e5 f1 71 d8 31 15 
04 c7 23 c3 18 96 05 9a 07 12 80 e2 eb 27 b2 75 
09 83 2c 1a 1b 6e 5a a0 52 3b d6 b3 29 e3 2f 84 
53 d1 00 ed 20 fc b1 5b 6a cb be 39 4a 4c 58 cf 
d0 ef aa fb 43 4d 33 85 45 f9 02 7f 50 3c 9f a8 
51 a3 40 8f 92 9d 38 f5 bc b6 da 21 10 ff f3 d2 
cd 0c 13 ec 5f 97 44 17 c4 a7 7e 3d 64 5d 19 73 
60 81 4f dc 22 2a 90 88 46 ee b8 14 de 5e 0b db 
e0 32 3a 0a 49 06 24 5c c2 d3 ac 62 91 95 e4 79 
e7 c8 37 6d 8d d5 4e a9 6c 56 f4 ea 65 7a ae 08 
ba 78 25 2e 1c a6 b4 c6 e8 dd 74 1f 4b bd 8b 8a 
70 3e b5 66 48 03 f6 0e 61 35 57 b9 86 c1 1d 9e 
e1 f8 98 11 69 d9 8e 94 9b 1e 87 e9 ce 55 28 df 
8c a1 89 0d bf e6 42 68 41 99 2d 0f b0 54 bb 16 
```

## 列行移位：
之后，我们将我们得到的结果按照我们的列方式排列，我们的第一列表示我们的行移位。
```
b0 b4
b1..
b2...
b3...
```

之后，按照下面的规则来进行变换：
1. 第一行循环左移 0 位
2. 第二行循环左移 1 位
3. 第三行循环左移 2 位
4. 第四行循环左移 3 位

将我们按位移动后的字节按照我们的原本的顺序重新进行操作。我们就可以得到我们的最终的结果。



## 列混淆：
我们的列混淆我们在我们以为后，我们利用我们的 $GF(2^{8})$ 中的对应的矩阵乘法来进行对应的变化。其中我们的矩阵的元素表示一个**多项式**，我们的矩阵的右侧也表示一个 **多项式**。将输入的 $4*4$ 的矩阵左乘一个给定的 $4*4$ 矩阵
![[Pasted image 20241220010728.png]]

我们将我们的对应的元素相乘后，就能够得到我们的每一列的最终的结果，我们的对应的 $GF(2^{8})$ 中的矩阵乘法也是显然的。一样的，我们进行了混淆之后，我们进行了一个输入字节变换，所有的输出字节都会发生变换。
![[Pasted image 20241220012338.png]]

![[Pasted image 20241220012454.png]]

![[Pasted image 20241220012504.png]]

![[Pasted image 20241220012528.png]]


## 轮密钥加：
将我们的最后输出的 $4\times4$ 矩阵与一个密钥矩阵进行一个**按列加**操作，即根据每一列的结果进行按位异或操作。

## 密钥编排：
我们根据我们的输入的不同 (128/192/256)比特，来生成不同对的密钥，128-11.192-13，256-15。 

假设输入位 128 比特的 AES，那么我们就应该以字为单位（32 bit）。

我们首先将我们的原来的密钥按照下面的规则来生成下一轮的密钥，我们记从左向右的输入为 $W[0],W[1],W[2],W[3]$。那么这个时候，我们就有：
![[Pasted image 20241220011233.png]]


$$
\begin{align}
&W[4]=W[0]\oplus g(W[3]) \\
&W[5]=W[0]\oplus W[1] \\
&W[6]=W[1]\oplus W[2]; \\
&W[7]=W[2]\oplus W[3];
\end{align}
$$

其中我们的 $g$ 函数如下：

字循环：将我们输入的每一个字循环左移一个字节，即将输入字[b 0, b 1, b 2, b 3]变为[b 1, b 2, b 3, b 0]。
![[Pasted image 20241220011831.png]]

字节代换：对于我们的字循环的结果，再去经过一个 S 盒进行字节代换。
![[Pasted image 20241220011905.png]]

轮常量异或：对于第一个字节的处理，我们需要把我们的替换后的字节，和一个 RC（Round Content），即每一轮的轮常数进行操作。
![[Pasted image 20241220011949.png]]



我们每一轮的论上述都是对应一个多项式在 $GF(2^8)$ 意义下的结果。从而**去除我们的输出结果的对称性**。（）



这样进行一轮，我们就得到了一个密钥，然后我们进行 N 轮，就可以得到 N 个密钥。
![[Pasted image 20241219140358.png]]
## 解密运算：
我们加密当中因为我们的每一个运算都是可逆的。因此，我们只需要对于我们的每一个运算都去求逆。
我们原本的最后一轮的内容要放到我们的第一轮去进行处理。注意，因为我们一开始的加密中，我们的最后一轮是没有**列混淆的**，所以我们不需要去进行我们的逆列混淆

其中，我们字节替换的逆运算相对来说比较复杂，我们原本的方法是 $y=Linear(inv(x))$。现在，我们要求我们的对应的逆映射表，我们就应该有：
$x=inv((Linear^{-1}(y)))$。

或者我们直接编排成一个查找表即可。

同时，针对 AES，我们还添加了部分硬件指令，从而在处理器级别上加快我们的查找速度。