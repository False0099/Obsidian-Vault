	## 朴素算法：
数字签名算法（DSA）是基于离散对数问题的签名方案，广泛用于确保消息的完整性和来源。它利用离散对数的困难性来实现签名的安全性。
### 密钥生成：
1. 选择一个大素数 $p$ 和生成元 $g$,使得 $g$ 是 $p$ 的一个生成元。选择 $p$ 和 $g$ 需要满足特定的条件：

>生成元 $g$ 必须满足能够生成群中所有元素的条件。
>1.  $g^x\left(\mathrm{mod}p\right)$ (对于 $x=1,2,3,\ldots,p-1$)应该涵盖整个群 $G$,也就是对于所有 $1\leq x<p$, $g^x\left(\mathrm{mod}p\right)$ 不会重复。
>2. 为了使生成元 $g$ 可以生成群 $G$ 中的所有元素，生成元的阶必须是 $p-1$。即，必须满足：$$g^{p-1}\equiv1\pmod{p}$$这意味着 $g$ 的所有幂次，直到 $p-1$,才会覆盖群中的所有元素。$g$ 的阶是 $p-1$,是群的大小的最小因数。


2.  随机选择一个私钥 $x$,其中 $x$ 是小于 $p-1$ 的整数。
3.  计算公钥 $y=g^x\pmod p.$
4. 输出公钥 $(p,g,y)$ 和私钥 $x$。

### 加密步骤：
1. 选择一个随机数 $k$,该随机数应小于 $p-1$,并且保证 $k$ 不与 $p-1$ 互质

2. 对于一个消息，首先将消息表示为整数 $m$,计算密文的第一部分：$c_1=g^k\pmod{p}$。

4. 计算密文的第二个部分：$c_2=m\cdot y^k\pmod{p}$这里，$y^k\left(\mathrm{mod}p\right)$ 是公钥 $y$ 和随机数 $k$ 的幂次。该值与消息 $m$ 结合生成密文。

这个时候结果的密文为：$(c_{1},c_{2})$。

### 3. 解密过程：
>解密过程利用了一个点，已知 $x$ 的前提下，求加密方的 $k$ 是简单的。这个是可以

1. 计算 $s=c_1^x\pmod p$

使用私钥 $x$ 计算 $s=c_1^x\left({\mathrm{mod}}p\right)$。这里，$c_1$ 是密文的第一部分，私钥 $x$ 是已知的。由于 $c_1=g^k\left({\mathrm{mod}}p\right)$,因此$c_1^x=(g^k)^x=g^{kx}\left({\mathrm{mod}}p\right)$。
 
 2. 计算 $s^{-1}:$
· 计算 $s$ 的模逆元 $s^{-1}$,即找到一个 $s^{-1}$ 使得：
$$s\cdot s^{-1}\equiv1\pmod{p}$$

3. 恢复原始消息 $m:$
使用 $s^{-1}$ 来恢复原始消息 $m$,通过计算$$m=c_2\cdot s^{-1}\pmod{p}$$由于 $c_2=m\cdot y^k\left(\mathrm{mod}p\right)$,即 $c_2=m\cdot(g^x)^k\left(\mathrm{mod}p\right)$,通过计算 $m=c_2\cdot s^{-1}$ 可以恢复出原始的消息。

