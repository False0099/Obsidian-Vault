**在 python3 中，我们的每一个对象，都有标识 (id), 类型（type）, 值 (value)标识**。其中，我们的标识可以通过我们的 `id()` 获得，我们的类型可以通过 `type()` 获得，我们的值可以通过 `print()`。

我们可以通过 `is` 运算符，判断我们的两个变量是不是指向同一个对象。==判断我们的元素是不是相同



## 创建方法：
方法一：直接写一个实例：
```
a=123
a='abc'
a=1+2j
```

方法二：调用对应的类方法：
```
a=int(12)
a=complex(1,2)
```

## 传值传引用问题：
### 不可变结构（传值）
![[Pasted image 20240503233013.png]]


![[Pasted image 20240503233118.png]]

证明方法：我们通过 `print(id(a)),print(id(b)),print(id(c))` 来取看我们的是否是正确的。

在我们的 python 的赋值中，我们可以这么理解，我们真正的**值**是占用内存的，而我们复制的时候，是吧我们的这一个**值**的对应的**地址给了我们的变量**。
![[Pasted image 20240503233303.png]]




### 可变结构（传址）
![[Pasted image 20240503233436.png]]

![[Pasted image 20240503233747.png]]

![[Pasted image 20240503234108.png]]

![[Pasted image 20240503234504.png]]
![[Pasted image 20240503234520.png]]

注意到，我们这个时候，因为我们的**b**是一个**不可变**的，所以这个时候，我们遵循的规则是：


## 拷贝问题：
![[Pasted image 20240504215235.png]]


![[Pasted image 20240504215307.png]]

![[Pasted image 20240504215315.png]]

我们注意到，只有第一种方式得到的 list 是相同的，这是因为：我们的 2 和 3 本质上都是创建了一个新的列表。

其中，我们引入 copy 包的时候，我们使用深拷贝的时候，和我们的结果是不一样的：
![[Pasted image 20240504215517.png]]
![[Pasted image 20240504215526.png]]

其中，我们的**深拷贝就是创建了一个新的对象**，我们的浅拷贝就是沿用我们的原来的对象。

我们可能存在的问题就有：
![[Pasted image 20240504215858.png]]

## 数字
我们在 python 中的数字包括有：整数，浮点数，复数三种类型的数字，
### 整数：
我们的 python 中的整数具有无限精度，默认情况下为十进制，需要转换为其他进制的时候，需要特殊声明
```
0b11011;
0o777665
0xabca
97
```

### 浮点：
```
1.78e2
```

### 复数：
```
2+3j
```

## 布尔类型：
只有 True, False 两种值，支持 or and not 运算
## 字符串：
字符串是 Python 中的一种不可变序列，使用一个字符串的格式化操作来讲要输出的变量按照需要的格式进行输出，并加上了相关文字。
·字符串可以用单引号’或者双引号”括起来。
·与 C 语言类似，转义字符为反斜杠丶。
·如果一个字符串中想要禁用转义符号，则前面加 r，如 `r'C:\Windows'`,
·多行字符串可以使用三个但单引号或三个双引号来包裹。

**三个单/双引号包括的情况下，我们输入的回车换行也会被包含进来**。

注意，我们写在我们的函数内部的以三个引号靠头的叫做函数字符串，可以通过：
```
print(f.__doc__)
```
来调用

### 字符串相关运算：
```
+（拼接字符串）
*（重复字符串）
[:]（取出一个子字符串）
in（判断是不是一个子字符串）
r(原始字符串)
```

### 字符串取子串操作：
语法格式：
`a[start:end:step]`


**左取右不取**。
`a[2:5：step]`,取我们的下表为 `2-4` 的子串
`a[:-1]`,去我们的下表为 `0-len-1` 的子串
**注意，我们的字符串是一个不可变的序列，我们的字符串不支持元素赋值操作**。

### 字符串拼接：
直接对应的位置直接加起来即可。

### 格式化输出：
`print("xxxxx%d,%d",%(aaa,bbb))`

## 类型转换：
```
int(x,base=10) 数字或者字符串按照base进制来转换为整数
print(int('0b0101010101010101',base=2))
print(int('0x0101010101010101',base=16))

float(x)  数字或者字符串转换为float类
hex(x)   整数转换为以0x前缀的十六进制字符串
oct(x)  整数转换为以0o前缀的八进制字符串
bin(x)  整数转换为以0b前缀的八进制字符串

str(x)  将x转换为字符串
ord(x)  将单个字符转换为整数
chr(x)  将整数转换为单个字符
```



## 列表：
我们的列表类似于我们的其他语言当中的数组，我们在我们的列表中，支持我们的循环构造。

在我们的列表中，我们的列表是一个**可变序列**。

我们的列表中，我们的每一项之间，**可以不是一个相同的元素类型**。

### 列表构造：
```
[]---表示空列表
[1,2,3]---表示有一个列表了
[x**2 for x in range(start,end,step)] 用列表递推式够减
list(k)//只能创建大小为k的空列表
list(range(1,4))//创建范围为1,4的列表
```

### 列表添加
```
a=[]+[];
a.append()---只能添加一个元素
```

## 字典：
我们字典要求我们的 key 是一个**不可变的元素**，例如我们的字符串，数字，socket。