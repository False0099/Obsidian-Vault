## 视图特点：
我们的视图是一个虚表，是从一个或者几个表格导出的。
我们的视图只存放数据的定义，不存放对应视图的数据
表中的数据发生变化，视图中查询出来的数据也发生对应的变化。

## 视图操作：
### 建立视图：
```
create view 视图名
as
某一个查询语句
```

**注意：**
1. 组成我们的视图的属性列名字，全部省略或者全部指定。
2. 子查询不允许排序，或者 distinct 子句
3. RDBMS 执行创建语句时，只是把视图的**定义**存储在我们的硬盘当中，并不执行当中的语句。
4. 在对视图查询时，其实是在查询基本表
5. 我们可以通过我们的 check option 来保证我们在插入或者删除更新的时候，**保证我们的完整性**。例如：
```
create view 111
as
select 
from 
where
with check option
```

这个时候，我们在**修改删除**的时候，会自动加 `sdepth='is'` 的条件。

2. 多表格视图：
我们建立了一个信息系选修了 1 号课程的学生试图：

```
create view on is_si
as 
select student.sno,sname,grade
from student,sc
where sdept='is' and student.sno=sc.sno and sc.cno=1
```

**其实我们的视图的建立就是变相的考察我们的 sql 查询语句，当然，我们的视图的数据也可以来自于我们的其他的视图。**。


3. 带有表达式的视图：
```
create view on is_si
as 
select student.sno,student.sno-1
fron student
```

我们这样，就可以将我们的对应的语句转换为我们的一个数据来源。

### 删除视图：
1. 级联删除
```
drop view 视图名 cascade
```
我们使用级联删除后，我们会把我们的视图的定义，以及所有我们**从这个视图导出的属性**给删除，**不会删除我们的表格**。

### 查询视图：
在我们查询视图的时候，我们都是按照我们查询我们的表格的类似的语法来进行我们的查询即可。

### 视图的更新：
我们在更新我们的视图的时候，将会转换为我们的对实际表格的操作，为了防止我们的视图更新时出错，我们一定要添加我们的 `with check option` 选项。
![[Pasted image 20240626204538.png]]

### 视图数据的删除
我们对于我们的视图删除的语法类似于我们的正常的对于我们的表格的操作，我们让给我们的 `DBMS` 转换成对应的真实的操作。

### 试图更新：
**有些视图时不能更新的**，因为我们的**视图的更新不能唯一的对应到我们的相应基本表的更新**。包括但不限于（使用了聚合函数，）
![[Pasted image 20240626204659.png]]


## 视图与安全
我们的视图对于我们的安全性的作用在于下面的两个点：
1. 把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的保护。
2. 间接的支持存取谓词的用户权限定义，也就是说王平只能检索计算机系的信息，系主任只可以查看增删改查某一个学生的所有权限。

例如：我们可以通过下面的定义：
```
create view test01
as
select *
from student
where sdept='cs'
```
查询所有的计算机系的学生，然后再把我们的对应信息授予给我们的用户：
```
grant select
on test01
to 王平
```

