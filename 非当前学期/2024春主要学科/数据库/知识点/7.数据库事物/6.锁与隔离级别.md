1. READUNCOMMITTED：未提交读
–在该方式下，当前事务**不需要申请任何类型的封锁**，因而可能会‘读’到未提交的修改结果
–禁止一个事务以该方式去执行对数据的‘写’操作，以避免‘写’冲突现象。


2. READCOMMITTED：提交读
–在‘**读’数据对象 A 之前**需要先申请对数据对象 A 的‘**共享性**’封锁，在‘**读’操作执行结束之后立即释放该封锁**。（**不等待到我们的事物提交就去释放**，可能会导致我们的幻读或者我们的不可重复读）
–以避免读取未提交的修改结果。

3. READREPEATABLE：可重复读
–在‘**读’数据对象**A之前需要先申请对数据对象A的‘**共享性’封锁**，并将该封锁**维持到当前事务的结束**。
–可以避免其它的并发事务对当前事务正在使用的数据对象的修改。

4. SERIALIZABLE：可序列化(可串行化)
–并发事务以一种可串行化的调度策略实现其并发执行，以避免它们相互之间的干扰现象。为了保证我们的可序列化，我们需要进入我们的**谓词锁**。
![[Pasted image 20240630172753.png]]

谓词锁的实现代价很高,谓词的数量远远比对象的数量大
谓词之间的关系极其复杂。

## 封锁等级：
表格含义如下：对于我们的每一种隔离等级，我们应该采用什么方式的隔离等级，并且我们对于我们的读锁，我们应该采用什么样的等级，什么样的类型。
![[Pasted image 20240627164628.png]]

对于上面的表格，我们的左侧表示我们期望达到的**隔离等级**，我们的上方表示我们**准备的锁的中嘞**，其中我们的谓词锁就是我们的最后一个**predicate**锁，我们的表格中的数据表示我们的对应的**类型是什么**。


