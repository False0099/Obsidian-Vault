## 事物调度
调度的定义为：一个或多个事务的**重要操作(action)的序列**
![[Pasted image 20240630115738.png]]

我们调度的目标是：让我们的所有的程序都是交叉并行，最后让我们的**效果等同于我们的串行**。于是，我们就有下面的几种调度分类方法：
1. 串行调度：
是指多个事务依序串行执行，且只有当一个事务的所有操作执行完后，才执行另一个事务的所用操作。这一种方法一定是能够保证我们的**正确性**，但是我们的效率很低。
![[Pasted image 20240630115755.png]]

2. 并发调度：
是指利用分时的方法同时处理多个事务；也就是说，我们在两个事物之间可以**任意的插入**新的时间和问题。
![[Pasted image 20240630115809.png]]
那么我们一个可行的序列就是：
```
R1(A,50),R1(B,50),操作A,操作B
```
我们的下面的序列就是不可行的：
```
操作A，读取数据，操作B
```
因为我们读取到的数据是一个不稳定的状态。

3. 可恢复调度：

事务的恢复：**一个事务失败了，应该能够撤消该事务对数据库的影响**。如果有其它事务读取了失败事务写入的数据，则该事务也应该撤消。对于每对事务 T1与 T2，如果 T2读取了 T1所写的数据，则 T1必须先于 T2提交。

考虑什么样的事物是不可恢复的，**如果我们的有一个事物被 commit 的时候，我们认为用常规的方法是不可恢复的**。
![[Pasted image 20240625141420.png]]

这个时候，为了**保证能够进行回滚操作**，而安排的执行序列，就叫做我们的**可恢复调度**。

#### 无级联调度
我们的级联调度，也就是说，对于没对事物 $T_{1}$,和 $T_{2}$,如果 $T_{2}$ 读取了我们的 $T_{1}$ 所写的数据，则 $T_{1}$ 必须在 $T_{2}$ 读取之前提交。

## 调度的正确性：
我们判断一个调度是否是正确的，也就是说我们的调度能否**保证我们的数据库处于抑制状态**。
**任意的串行执行都是正确的**。任何的穿行操作都能保证我们的数据库处于**一致状态**。
但是我们的并行则不然，多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行执行这些事务时的结果相同，称这种调度策略为可串行化调度。我们的调度可能会产生四种问题：
脏写（修改丢失）
脏读（读未提交数据）
不可重复读（前后两次读结果不同）
幻读（读到了我们的中途插入的数据，涉及到插入删除，**没有插入删除不会有幻读**）
### 等价调度：
如果我们的两个调度在任意数据库实例上的效果都相同，则这两个调度等价。
![[Pasted image 20240630120502.png]]

