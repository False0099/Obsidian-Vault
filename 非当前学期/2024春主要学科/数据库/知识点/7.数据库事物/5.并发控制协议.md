## 基于锁的并发控制协议
我们通过我们的锁来保护我们的数据库对象，事务 $T_i$ 只有获得了对象 $A$ 的锁，才能读或写 $A$,如果事务 $\tau_i$ 请求了对象 $A$ 的锁，但并未获得，则 $T_i$ 开始等待，直至获得 A 的锁为止。
如果事务 $T_i$ 已经获得了对象 $A$ 的锁，则在 $T_i$ 完成对 $A$ 的操作
后，$T_i$ 必须释放 $A$ 的锁我们的锁，
我们就可以通过我们的锁原语来控制我们的事务的执行顺序。
![[Pasted image 20240630131334.png]]

也就是采用一定程度的策略来考虑我们怎么去处理我们的每一个事务。也就是我们的**数据库关系系统**怎么实现我们的隔离级别。我们的私用是采用**锁**，标记我们的某一个数据是**独占的**。
## 封锁：
### 前提：
我们使用封锁计数的前提，就是在一个事务访问数据库中的数据时，必须先获得被访问的数据对象上的封锁，以保证数据访问操作的正确性和一致性。

### 作用：
封锁就是事物 T 在对某个数据对象操作之前，先向系统发出我们的请求，对其加锁，加锁后事物 T 就对该数据有了一定的控制，在事物 T 释放它的锁之前，其他的事物不能使用这一个数据对象。


### 类型：
我们的常用的封锁类型有两种：**排他锁**（X 锁，写锁），**共享锁** (S 锁，读锁)

排它锁（X 锁）只有当数据对象 A 没有被其它事务封锁时，事务 T 才能在数据对象 A 上施加‘X 锁’；如果事务 T 对数据对象 A 施加了’X 锁’，则其它任何事务都不能在数据对象 A 上再施加任何类型的封锁。（因此，我们的排他锁也叫做**写锁**）。

如果一个事务 T 申请在数据对象 A 上施加‘X 锁’并得到满足，则：事务 T 自身可以对数据对象 A 作读、写操作，而**其它事务则被禁止访问数据对象 A**也就是说，我们**只允许事物 T 访问我们的内容**。

这样可以让事务 T 独占该数据对象 A，从而保证了事务 T 对数据对象 A 的访问操作的正确性和一致性。

条件：如果数据对象 A 没有被其它事务封锁，或者其它事务仅仅以‘S 锁’的方式来封锁数据对象 A 时，事务 T 才能在数据对象 A 上施加‘S 锁’；

共享锁（S）如果一个事务 T 申请在数据对象 A 上施加‘S 锁’并得到满足，则：事务 T 可以对‘读’数据对象 A，但不能‘写’数据对象 A，不同事务所申请的‘S 锁’可以共存于同一个数据对象 A 上，从而保证了多个事务可以同时‘读’数据对象 A,在持有封锁的事务释放数据对象 A 上的所有‘S 锁’之前，任何事务都不能‘写’数据对象 A。**我们可以感性理解我们的共享锁是 read 锁**。

通过我们的当前的方式，我们就可以直接获取我们的最终的结果是多少。


## 相容矩阵：
![[Pasted image 20240625161354.png]]

这一个矩阵能够反映我们的矩阵之间的关系，包括我们怎么样能够获取我们的矩阵，怎么样能够。注意，我们的这里的前提条件是**其他事物持有的**。

如果对象 $A$ 上有事务 $T_i$ 加的共享锁，则事务 $T_j$ 还可以对 $A$ 加共享锁，但不可以对 A 加互斥锁。否则产生读-写冲突

如果对象 $A$ 上有事务 $T_i$ 加的互斥锁，则事务 $T_j$ 对 $A$ 既不能加共享锁，也不能加互斥锁。否则产生写-读冲突或写-写冲突



## 合适事物：
但是，我们并不是**加锁后就是保证正确的了**，因为我们可能会因为我们的错误加锁解锁顺序而破坏我们的对应的性质。例如：
![[Pasted image 20240630131717.png]]

如果一个事务在访问数据库中的数据对象 A 之前按照要求申请对 A 的封锁，在操作结束后释放 A 上的封锁，这种事务被称为合适事务。‘合适事务’是保证并发事务的正确执行的基本条件。

## 两阶段锁 (2-pharse-lock)
一个事务里面，分为加锁(lock)阶段和解锁(unlock)阶段,也即所有的 lock 操作都在 unlock 操作之前,如下图所示:
![[Pasted image 20240625162530.png]]
每一个事物的执行分为两个阶段：
增长阶段 (Growing Phase)：事务向锁管理器 (lock manager)请求需要的锁
萎缩阶段 (Shrinking Phase)：事务释放它获得的锁，但不能再请求加锁

我们的两阶段所要求我们满足下面的规则：
1. 在我们的事物 $T_{i}$ 想要读取一个数据之前，我们需要给我们的数据添加一个 $RL$ 锁。同理，我们想要写入一个数据之前，我们需要给我们的数据添加一个 $WL$ 锁。
2. 如果我们在上锁的时候，已经发生了冲突，（根据我们的相容矩阵）那么我们就等待直到我们满足我们的上锁条件，没有冲突锁。我们有冲突**当且仅当**我们有一个冲突锁。
3. 在我们执行完成后，我们要解锁我们的锁，调度程序必须确保在（释放锁）后不能再次（获取新锁）（**两阶段**）我们把这两个阶段叫做我们的**锁的增长阶段**和我们的**所得释放阶段**。**我们的一个锁一旦开始释放，就不能再去申请**。

通过我们的两阶段，我们就可以保证我们的程序之间能够互斥进行，**消除我们的环路**。也就是说，我们必须**一次性申请我们的所有的资源**，属于我们的死锁的避免。
![[Pasted image 20240630132053.png]]

## 加锁定理（Locking Theorem）：
如果所有的事物都**遵守我们得 2 PL**，正常情况下的事务操作不管如何去调度，一定是**可串行化**的。

**注意，我们默认我们的加锁是只有在我们的所有事物都已经结束后，才回去进行我们的解锁**。

#### 短期锁
我们的短期锁，就是表明我们的执行相关的存取操作，**操作结束后就释放**。

#### 长期锁
我们的长期所为了保证我们的正确性，要求**保持到事物提交位置，我们的事物才能被释放**。

## 缺点：
我们的两阶段加锁可能的问题是：导致我们的程序的死锁，或者我们的级联终止。![[Pasted image 20240630132204.png]]

