支持可串行化隔离级别的 DBMS 实施 (enforce)的都是**冲突可串行化**。冲突可串行化比一般可串行化的**条件更严**。冲突可串行化更便于在 DBMS 中实施。
## 冲突：
如果两个操作满足以下三个条件，则这两个操作冲突
。这两个操作属于**不同的事务**。这两个操作涉及**相同的对象**。这两个操作中**至少有一个操作是写**。
例如：
我们在我们的序列前后同时出现两个写程序，我们就是我们写-写冲突。造成了我峨嵋你的脏写。
![[Pasted image 20240630121911.png]]
我们的序列前后有 `写-读`，这个时候，我们就造成了我们的读写冲突，从而造成我们的脏读
![[Pasted image 20240630122027.png]]

我们的序列前后出现了 `读-写-读`，这个时候，我们就造成了我们的不可重复度冲突，从而造成我们的不可重复度
![[Pasted image 20240630122117.png]]

于是，我们就希望能够找到一个**序列**，使得我们能够在并行的同时，还能保证我们的**读写-写写冲突不发生**。

### 冲突等价
两个调度冲突等价 (conflict equivalent), 如果
。这两个调度涉及相同事务的相同操作
。每一对冲突的操作在两个调度中的顺序都相同
![[Pasted image 20240630122233.png]] 
## 可串行化：
#### 定义：
如果一个调度冲突等价于一个串行调度, 则该调度是冲突可串行化调度，则该调度是一个可串行化调度。或者我们也可以这样定义：如果通过将调度 S 中不同事务中的非冲突操作交换顺序可以将 S 转换为一个串行调度，则 S 是一个冲突可串行化调度。
![[Pasted image 20240630122419.png]]
当然，在某些情况下，我们的并发事务不需要严格的隔离，弱隔离可以帮助我们解决我们的问题
#### 前驱（优先）图：
节点:  S 中的事务 $T_{i}$ 
弧:  如果我们的事物 $T_{i}$ 和 $T_{j}$ 之间存在一条边，档期仅当我们的 $T_{i}$ 与我们的 $T_{j}$ 时间存在一个冲突动作，并且我们的 $T_{i}$ 的时间要早于我们的 $T_{j}$ .  
![[Pasted image 20240630123152.png]]

#### 可串行化判定
判定定理：我们将我们的可串行化序列转换为我们的**可串行化图**，如果我们的**可串行化图**是一个无环图，那么我们就认为我们的这一个调度是一个可串行化调度。如果我们的事物对应的前驱图中如果存在环,   S 不是冲突可串行的, 否则, S 是冲突可串行的。也就是说我们的事物可以串行化调度当且仅当我们的前驱图是无环的。

并且我们的**顶点的拓扑排序就是我们的一个等价的穿行调度**。

1. $R_{1}(A)$: 事物 $T_{i}$ 对数据项 $A$ 进行一次读操作，**对应于我们的 select 语句**，以行为单位
2. $W_{i}(A)$: 事物 $T_{i}$ 对数据项 A 进行一次写操作，**对应于我们的 update 语句**，以行为单位
3. 保证我们的 $R$ 和 $W$ 都是原子性的操作，我们的读操作或者写操作必须是一气呵成的。
4. 同时，我们需要保证多个 $T_{i}$ 进行交叉，要求我们的调度结果等价于我们的串行化的结果。
![[Pasted image 20240630122723.png]]

![[Pasted image 20240630122808.png]]
### 前趋图画法




