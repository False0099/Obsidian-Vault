## 错误调度的问题：
### 丢失修改（少）
我们的丢失修改，指我们的两个事物 $T_{1},T_{2}$ 读入同一个数据并且修改，$T_{2}$ 提交的结果覆盖了 $T_{1}$ 提交的结果，导致 $T_{1}$ 修改的结果丢失。

![[Pasted image 20240625135343.png]]

这一种问题在于，我们**读入数据应该在我们的修改数据之后灾区进行**。
![[Pasted image 20240625145816.png]]


### 读脏数据 (dirty read)
（**读取了一个回滚前的错误数据**），或者我们也可以认为我们读取了一个（**没有上传的数据**）。（我们只需要要求我么必须上传后再去读）

通常，我们的事物对我们的一个进行修改后，我们的事物**插销回滚**，导致我们的数据不相同。

例如：
1. T 1 修改某一个数据，并将其写入磁盘当中
2. 事物 $T_{2}$ 读取某一个数据，由于某种原因撤销了，
3. 这是 $T_{1}$ 已经对修改过的数据 

### 不可重复读（Not repeatable Read）
**读的结果随着时间的不同而不同**，这一种在我们限制了只能读取已经提交也是不够的，我们**还需要在我们的两次读取之间不能有修改**。

事务 T 2 读取某一数据后，事务 T 1 对其做了修改，当 T 2 再次读取该数据时，得到与前次不同的值.
![[Pasted image 20240625150409.png]]
不可重复读是指我们在 $T_{1}$ 读取数据后，$T_{2}$ 执行更新操作，使得我们的 $T_{1}$ 无法再复现前一次的读取结果，我们的不可重复读包括我们的下面的操作：
1. 事物 $T_{1}$ 读取某一个数据后，事物 $T_{2}$ 对其进行了修改，当事物再次读取该数据时，得到与前一次不同的值。
![[Pasted image 20240625135632.png]]


### 发生幻想 (Phantom Read)
事务 T2按一定条件读取了某些数据后，事务 T1插入了一些满足这些条件的数据，当 T2再次**按相同条件读取数据时，发现多了一些记录**。（这一点是因为我们的**SQL 锁机制而产生的**，因此我们只能够通过我们的串行化来实现）

2. 事物 $T_{1}$ 读取某一个数据后，$T_{2}$ 对其进行了删除，当我们的事物 $T_{1}$ 再去读取该数据时，发现那些记录神秘的消失了。
3. 事物 $T_{1}$ 读取某一个数据后，$T_{2}$ 插入了一些数据，当我们的事物 $T_{1}$ 再去读取该数据时，发现出现了新的神秘数据。
![[Pasted image 20240625150426.png]]

## 隔离性级别：
这一种约束**必须有我们的用户去添加**。

1. Serializable: 一个调度的执行必须等价于一个串行调度的结果（对应于我们的丢失修改，通过**中断实现**）
2. repeatable read：**只允许读取已提交的记录**，并要求一个事务对同一记录的**两次读取之间，其它事务不能对该记录进行更新**（对应于我们的不可重复读），上了一个 $X$ 锁
3. read committed：**只允许读取已提交的记录**，但不要求可重复读（SQL Server 默认级别，解决我们的**读脏数据**），上了一个 $S$ 锁
4. read uncommitted ：允许读取未提交的记录，没有上锁
![[Pasted image 20240625151019.png]]
#### 创建语句：
```
set transaction isolation level serializable/repeatable read/read uncommitted
```
#### read uncommitted 级别
在这种级别下，未提交的事物修改对于其他事物是可见的，也就是说我们**只有在全是读**的情况下，这一种方法才是正确的并行的。
![[Pasted image 20240630121000.png]]


显然，这样的会导致我们的大量的**脏读，不可重复读，幻读**。上述一场都会出现，我们就需要自己判断脏读等。
#### read committed 级别
与上一个隔离级别相比，我们只有在一个事物提交过后，我们才能看见他修改之后，我们的数据是多少？但是我们还是可以看见其他已体检事物的修改。
![[Pasted image 20240630121146.png]]
![[Pasted image 20240630121301.png]]

于是在这一个级别下，我们就**不可能出现脏读**现象，但是我们仍然会出现我们的**幻读和不可重复读**。


#### repeatable read 情况：
如果一个事务不修改对象 X 的值，则该事务在任何时候读到的 X 值都等于事务启动时读到的 X 值。（**MYSQL 的默认隔离级别**）
![[Pasted image 20240630121445.png]]

![[Pasted image 20240630121603.png]]

在这种情况下，我们显然不会有**可重复读，脏读**，但是我们仍然可能会出线我们的**幻读**。

#### 严格串行化：
![[Pasted image 20240630172443.png]]

![[Pasted image 20240625151528.png]]

在我们的这一种情况下，我么不会出现任何的问题。