## 逻辑结构：
从**逻辑上讲**，我们的索引数据包括两个部分：索引键值和对应的指针或者 rowid，或者叫做我们的 RID, 行指针。(指示我们的存储位置)
例如：
![[Pasted image 20240629133209.png]]
我们这里 1.2 数据模型就是一个索引，我们后面的 14 就是我们的行指针，rowid, RID. 同时为了我们的快速查找，我们的**索引键值应该是有序**地。  

偶们的基本表中的行和创建的索引是存储在存储器中，当他
们本访问的时候，将被读入到内存中，（内存是易失性存储器，磁盘是非易失性存储器。）而**我们把内容从我们的硬盘中读入**，也就是一次 `I/O` 过程，我们需要的时间代价是很大的。**RID，ROWID，行指针**。

## 物理结构：
在我们的物理结构上，为了是按我们的索引结构，我们采用我们的 B+树来进行操作，也就是通过我们的 B+树来实现我们的 map，同样，我们也可能会用我们的哈希表来计算（unordered_map）。我们让我们的链表内采用有序地方法来计算我们的对应的内容。

这也就是为什么我们不采用我们的二叉平衡树来进行我们的搜索。因为我们每一次可以理解为下面的伪代码：
```
u=getnode()//瓶颈
if(check()){
	goleft();
}else{
	goright();
}
```

显然，这个时间复杂度与我们的树高是成正比的，因此，我们就需要能够去优化我们的上面过程

## B 树
我们采用我们的下面的思路：我们考虑每一次读取**尽可能多的内容**，于是，我们就可以设置我们的分叉如下：
![[Pasted image 20240530200119.png]]


首先我们的 B 树满足下面的规定：
1. 我们的 B 树内部是有序地，所有的叶子节点都在同一层当中。
2. 我们的 B 树都是节点内有序地，任意的左子树都比我们的当前元素药效，右子树都更大。同时，我们假设一个结点存储了 $k$ 个下标，那么就有 $k+1$ 个叶子，以满足我们的查找需求。

### 查找过程：
第一步：我们把我们的根节点的数据读到我们的硬盘中。
第二步：我们把我们的当前元素和我们的硬盘中读取到的数据进行对比，找到我们应该进入到我们的那一个岔口当中。
第三步：以此类推，直到我们找到我们的最后的答案。

### 插入过程：
略，我不关心