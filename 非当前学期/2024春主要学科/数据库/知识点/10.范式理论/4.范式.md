我们的**范式**就是我们的符合某一个级别的关系模式的集合。关系数据库中的关系**必须满足一定的要求**，满足不同程度的范式为不同范式。

## 规范化：
我们的规范化指的是：低一级的范式模式，通过模式分解，转换为若干个高一级范式关系模式集合的过程。


## 第二范式：
我们的第二范式就是要求：我们的**满足第一范式的条件下**，**不存在属性对于主键的部分函数依赖**。也就是说，我们不能通过我们的函数依赖的子集推导出我们的最终函数依赖。


换句话说，我们函数依赖关系的右侧，不能有主键。左侧的部分不能是任何一个键的子集的部分。也就是说我们**主键中要够唯一决定我们的所有的信息**。

对于我们的一个依赖关系（$X\to A$），我们要求（二选一）（假设我们的 A 是一个单项）才能说明我们的这一个关系**符合第二范式**：
1. $A$ 是一个不在 $X$ 中的单一属性且是非主属性（**不包含在任何一个候选码中的属性**称为非主属性）
2. $X$ 不是 $T$ 的任何键 $K$ 的真子集。（a->bc/b->c）, 那么我们的 $(b\to c)$ 满足我们的要求。

如果我们的一个关系**不符合**第二范式，我们应该有：
1. 我们的 A 是一个在 $X$ 中的单一属性，或者我们的 $A$ 是一个主属性
2. 我们的 $X$ 是一个键 $K$ 的真子集。

例如：假设我们有一个表格 $\{a,b,c,e,d,f\}$,并且有下面的两条依赖关系 $\{a,b\to c,e,d\},\{b\to f\}$。那么显然，我们原本表格的键应该是 $\{a,b\}$，显然，我们的关系 $2$ 是我们不符合要求的部分，因为我们的关系 2 中，我们有 $b$ 是我们的键的真子集，并且我们的 A 是一个我们将其拿出来，将他创建一个新的表格。表格一部分维护我们的不符合的关系，另一个部分维护我们的表格删除右侧的部分。

例如：我们存在一个学生信息表，有学号，学生姓名，学生年龄，家庭住址，成绩，课程号来作为我们的一个表格，这个表格就是不符合我们的第二范式的，因为我们只通过我们的学号是不能决定我们的所有信息，我们的乘积不能由我们的学号直接决定。也就是说，我们的元素只依赖于我们主键的一部分。

#### 判断方式：
第二范式（2NF）要求实体的**所有非主属性完全依赖于主关键字**。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。
![[Pasted image 20240630225646.png]]


#### 不满足第二范式表格的缺点：
这样做，我们的问题就是：我们的修改问题，安全性问题，
1. 插入异常 （插入一个新的学生，没有选课，学生的信息就无法插入），
2. 删除异常（当我们推掉我们的所有课程的时候，我们也会把我们的个人信息给删除），
3. 更新异常（我们在更新的时候，我们很难维护我们的数据的一致性，因为我们存在着大量的荣誉）

#### 解决方案：
我们将我们的**部分依赖的函数关系**拆分为两个表格，其中我们的子集关系是一个表格，我们的非自己关系有构成一个表格。同时，我们还需要在我们的**两个之间创立一个连接**。
![[Pasted image 20240627205134.png]]

条件：对给定的 $X\to A$, $A$ 是一个非主属性，并且我们的 $X$ 是我们的表格的键的非空子集。

分解：我们把我们的表格分解为 $T_{1}=(XA),T_{2}=(U-A)$。其中我们第一个表格的主键为 $X$,第二个表格的主键为 $W$ 并且我们的 X 是一个外键。

## 第三范式：
加入一个关系的模式满足我们的第二范式，并且我们不存在属性对于主键的传递依赖。

例如：我们有一个雇员信息表，一个是雇员编号，薪资等级，最终薪水。其中我们的雇员编号是我们的主键。这个时候，我们的薪资等级和最终薪水显然都是依赖于我们的雇员编号。**但是我们的三者之间存在传递依赖**，例如：我们的雇员编号决定我们的薪资等级，我们的薪资等级决定我们的最终薪水。**这样的表格不满足我们的第三范式**

要求：假设我们有依赖关系 $X\to A$,那么我们就要求（三选一）：
1. 我们的 $X_{0}\to A$ 是一个平凡依赖
2. $X$ 是原表格 $T$ 的超键
3. **这一个关系**右侧的部分减去**这一个关系**左侧的部分，每一个属性均包含于表格 T 的一个候选键中。（是一个主属性）也就是说，我们运行我们的下面的语句存在 $a\to\{b,c,d\}$，其中我们的 $c$ 是我们的一个
#### 判断条件：
第三范式是指：**非主键列必须直接依赖于主键**，不能存在传递依赖（优化发生在以单主键或联合主键为主键的表，只是非主属性间存在依赖）
![[Pasted image 20240630225744.png]]


#### 不满足的缺点：
1. 插入异常：
	当我们每一个员工的工资子别还没有确定的时候，我们的每一个员工的对应的薪资就没有办法录入。
2. 删除异常：
	当我们只有一个人拿第三级工资，我们删除了着一个人之后，我们怎么知道以后拿第三季工资的对照关系应该事多少呢？
 3. 更新异常：
	 在我们发生数据异常的时候，我们很难去维护我们的数据一致性，我们的对应的对照关系可能会产生错误。我们每一次，一旦有重复，我们就要把我们的元素进行拆分。

#### 解决方法：
也就是把我们的**传递依赖**分解为我们两个部分，两个部分各自形成一个表，例如我们有 $a\to b,b\to c$，我们就吧原表格拆分为：$a\to b$, $b\to c$ 这两个表格。



## BCNF 范式：
我们 BCNF 范式相较于我们的第三范式，我们的差别只在于：
我们的要求更严格了。我们是不允许我们的逃逸的，就在于我们的第三条。我们定义如下：
设关系模式 $R<U,F>\in3NF$,若 $X\to Y$ 中我们的 $X$ 一定是我们的某一个**候选键**，我们就认为这一个范式满足我们的 $BCNF$ 范式。

### 性质：
1. 所有的非主属性都必须函数依赖于我们的**候选码**
2. 所有的**主属性**也必须完全函数依赖于每个不包含它的候选码
3. 没有任何属性完全函数依赖于非候选码的任何一组属性。 


![[Pasted image 20240627210255.png]]


![[Pasted image 20240627210441.png]]

![[Pasted image 20240627210638.png]]