对于一个模式的分解应该是多种多样的，但是分解后的模式和必须和原模式**等价**，而我们的**等价**，具体来说就是要形成下面的三种不同的定义：
1. 分解具有无损连接性
2. 分解要保持函数依赖
3. 分解既要具有无损连接性，又要保持函数依赖
![[Pasted image 20240630101638.png]]
我们以下面的表格为例进行我们的后续说明：
![[Pasted image 20240628002943.png]]


**无损分解，但是丢失函数依赖**的分解示例：
（存在插入删除异常）
![[Pasted image 20240628003224.png]]

完美的分解：既满足无损分解，又满足不丢失函数依赖：
![[Pasted image 20240628003508.png]]


## 无损分解：
在我们获得了我们的最小覆盖集合后，我们就完全呃结束了吗？显然没有，我们还需要考虑下面的因素：我们需要考虑**分解时候，我们的属性不能丢失**并且，我们**通过我们的连接运算后，能够还原出我们的原表格**。

而也是因为我们的**无损分解**，才要求我们在没有包含所有候选键的情况下，需要去添加我们的候选键。

通过我们的无损分解，我们才能保留我们的俩个张表格进行连接运算后的结果等于我们的原始表格。

省流：只有无损分解+保留函数依赖（我们的表格合并后，我们的函数依赖没有减少，也不会增加）同时成立时，我们才认为我们的分解时正确的。也就是我们的**连接依赖**。
术语：无损分解，保留函数依赖：
### 定义：
我们的无损分解存在两个前提条件：
1. 我们的两个表格的标题合并后能还原出来原来的所有的数据，**不会多数据，也不会少数据**。
2. 函数依赖被保留，也就是说，我们要在满足第一个条件的情况下，还需要去满足： $Head(T_{1})\land Head(T_{2})\to T_{1} \{or\}Head(T_{1})\land Head(T_{2})\to T_{2}$（**这一个限制条件保证了我们的元素不会重复产生**）

也就是说，我们存在一种拆分方法，能够把我们的元素拆分为两个表格，并且两个表格进行连接操作后，能够完美还原我们的原始表格即可。


例如：
1. $F=\{A\to B\},T_{1}(A,B),T_{2}(A,C)$ 是否是一个无损分解？
答案：是，我们的共有属性 $A$ 能够函数决定我们的 $B$,因此，我们的该分解是一个无损分解。**但是这一种分解出现了一种问题，就是我们的候选键同时出现在了一个表格当中**

2. $F=\{A\to C,B\to C\},T_{1}(A,B),T_{2}(A,C)$
答案：是：我们的共有属性 $A$ 能够函数决定我们的 C，因此，我们的该分解决定了我们的 $T_{2}$,因此该分解是一个无损分解。**但是我们的这一个分解中出现的问题是，我们的候选键同时出现在了一个表格当中**。

3. $F=\{A\to B\},T_{1}(A,B),T_{2}(B,C)$
答案：否，我们的共有属性 B 及不能够决定我们的表格 $T_{1}$,也不能够决定我们的表格 $T_{2}$,因此我们的这一个分解不是我们的一个无损分解。**这一个分解中出现的问题是，我们的候选键没有同时出现在一个表格当中**。

4. $F=\{A\to B,B\to C\},T_{1}(A,C),T_{2}(B,C)$
答案：否，我们的共有属性 C 不能够决定我们的 $T_{1}$,也不能够决定我们的 $T_{2}$.

5. $F=\{A\to B,B\to C,A\to D,D\to C\},T_{1}(A,B),T_{2}(A,C),T_{3}(A,D)$
答案：是，我们的 $T_{1}$ 和 $T_{2}$ 是一个无损分解，而两者的联合和我们的 $T_{3}$ 又可以构成一个无损分解。

#### 判断方法：
也就是说，我们的无损分解具有下面的性质：我们分解之后，两表的交集，必须能够确定其中一个表的标题（主键），其中我们的表可以是**原始表**，也可以是**原始表格进行若干轮连接运算后得到的新的表格**。应该有至少一个表格包括我们的候选键。也就是说，我们需要把我们的原始表格的候选键，并且我们要保证每一个表是否与某个表有至少一个相同属性。

### 判断方法：
（注意，我们再找函数依赖判断的时候，我们的**顺序**对我们的分解结果有很大的影响，我们一定要先把我们的**函数依赖**按照谁多谁先来的方法进行**动态排序**，或者为了保险起见，我们进行**两次更新**）
第一步：我们画出我们的 $n\times k$ 矩阵，其中我们的 $n$ 指的是我们分解出来的若干个模式，我们的 $k$ 指的是我们原来的图表当中的元素属性。
![[Pasted image 20240630103013.png]]

第二步：先进性**初步填表**，也就是说，我们现在每一个表里按照如下的规则填表：如果我们的对应的格子在我们的左侧出现，那么我们就把对应的位置设置为 $a_{k}$，否则我们把对应的位置设置为 $b_{ij}$

第三步：填表完成后，我们考虑我们怎么去进行我们的后续处理，我们从我们的原本题目中的函数依赖中, 形如 $X\to Y$ 取出一个，在我们的 $X$ 中找相同分量的行，然后把这些行都替换为 $min(b_{ij})$,当然，其中如果有 $a$ 的话，直接替换为 $a$ 即可

第四步：查看我们最后的表格中是否有一行全都是我们的 $a_{1},\dots a_{n}$,如果有，那么就说我们**是无损分解**，否则说明**不是无损分解**。
![[Pasted image 20240630103631.png]]

## 保持函数依赖
我们的保持函数依赖，就是说我们原本在我们的分解过后的各个表的函数依赖，经过我们的合并之后，我们仍然可以得到我们的全部的函数依赖。
而我们判断我们一个函数是否保持了我们的函数依赖，我们可以通过我们的下面的方法来进行判断：
$$\mathbf{F}\:\equiv\:\prod_{R_{1}}(\mathbf{F})\cup\prod_{R_{2}}(\mathbf{F})\cup\cdots\prod_{R_{1}}(\mathbf{F})$$
$\prod_{R_{i}}(\mathbf{F})=\{\mathbf{X}\longrightarrow\mathbf{Y}|\mathbf{X}\longrightarrow\mathbf{Y}\in\mathbf{F}^{+}\wedge\mathbf{X}\mathbf{Y}\subseteq\mathbf{R}_{i}\}$

(1) F 的闭包在 Ri 上的投影，原因在于函数依赖的逻辑蕴含
 
$(2)计算\prod_{R_i}(F)$ 的方法：

对于 Ri 的任意一个属性真子集 X，计算 $X_F^+$ 对于任意一个属性 $\widehat{Y}\notin X$,且 $\Upsilon\in X_F^+$,那么 $\mathbf{X}\to\mathbf{Y}$ 在 Ri 中成立。也就是说，我们枚举我们的每一个原本的**函数闭包**的元素，看这一个元素是否在我们的这一个分解中出现了。

![[Pasted image 20240630102031.png]]
### 二元无损分解：
设 $\rho=(\mathbb{R}1,\mathbb{R}2)$ 是 R 的一个分解，F 是 R 上的函数
依赖集，分解 ρ 具有无损连接性的充分必要条件是：也就是说，**两个关系的交集能够决定我们的某一个表格**。
$R1\cap R2\to(R1-R2)\in F^{+}$
或 R 1 $\cap\mathbb{R}2\to(\mathbb{R}2-\mathbb{R}1)\in\mathbb{F}^+$
