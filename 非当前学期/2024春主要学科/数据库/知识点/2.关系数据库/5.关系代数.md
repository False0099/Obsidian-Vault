
操作应该满足下面的性质：
1. 完备的
2. 唯一的
3. 安全的

我们再研究一个运算的时候，要研究下面几个方面：第一我们每一个运算的功能是什么，第二：我们的每一个功能是否是完备的？也就是我们用我们的操作叠加能否支持我们的所有的运用 ？

对于我们的数据库，我们的一个重点就是我们的运算能否支撑我们的所有应用。集合运算+自然关系运算。（集合运算不会破坏表格的结构内容，自然关系运算会皮换我们的，并交差运算保留“原子性”）

## 兼容表：
如果对于我们的两个表格 S 和 R，我们有两个表格的标题要相同，$Head(R)=Head(S)$，也就是我们**列数**，**含义，定义**要相同，**取值范围**也要相同。

## 集合运算：
并，交，差：只有我们的**兼容表**才能进行我们的集合运算。而我们进行并操作后的表格结构保持不变。

笛卡尔积：拼接操作，我们把原来的每一行当作是一个完整的信息，然后再去把两个**拼接**在一起。
## 选择运算：
选择运算相当于给定我们我们的限制条件是什么。

$\sigma$: 选择运算，用于选择我们的表格中符合相应关系的行。相当于 sql 语句中的 `where`。

例如：
$\sigma_{salary>800}$ 就是选择我们的表格中工资大于 800 的所有行是那些。

## 投影运算 （默认不去重）：
$\prod$: 投影运算，用于选择我们的行中对应的列，相当于我们 sql 语句中的 `select`.（过滤语句）


例如：
$\prod_{name,salary}(\sigma_{salary>800})$ 就相当于选择我们的 salary 大于 800 的所有行，并且展示这些行的 name 和 salary 数据。

## 除法运算：

## 并运算：
$\lor$: 并运算，用于选择我们的同时满足条件的两个集合的并集。

例如：
略，太简单。
![[Pasted image 20240326124301.png]]


## 笛卡尔积：
笛卡尔积在没有限制的情况下没有实际意义，只有我们限制了两边的集合后，笛卡尔积才有真实意义。
![[Pasted image 20240326124417.png]]

## 自然连接：
自然连接相当于找到我们的 $A$ 表和 $B$ 表中满足属性相同的笛卡尔积。

自然连接属于一类优化运算，我们采用自然连接运算的主要目的是能够优化我们的元素之间的计算。省去我们对于边的描述。而我们的所有自然连接都可以通过我们的笛卡尔乘积来进行等价表述的。

$\bowtie$: 自然链接运算，自动查询两张连接表中**所有**相同的字段。等同于 sql 当中的 `NATURAL JOIN`.
规则：我们要有共有列，并且我们的共有列上的取值相同的。那么我们就把我们的两个表格拼接在一起，并且去除我们的多余的部分，

特例：
没有共有属性：退化为我们的**乘积运算**。$(a_{1},a_{2}),(b_{1},b_{2})\to(a_{1},a_{2},b_{1},b_{2})$

全都是公共属性：退化为进行**交运算**
$(a_{1},a_{2},a_{3}),(a_{1},a_{2},a_{3})\to(a_{1},a_{2},a_{3})$，并且结果式两者进行叫运算
![[Pasted image 20240312141311.png]]

![[Pasted image 20240326125329.png]]



![[Pasted image 20240326125215.png]]


求解步骤：
1. 找共有列
2. 找共有列上取值相同的部分
3. 然后我们对我们选取出来的有取值相同的部分，进行笛卡尔积后合并为我们的新的表格。

Eg:
2.7.8 get names of customers who order at least one product costing $0.50.

![[Pasted image 20240312142214.png]]

![[Pasted image 20240312142218.png]]
等于：
![[Pasted image 20240312142235.png]]

等于：
![[Pasted image 20240312142245.png]]


我们可以把我们的上述要求分成三个部分：
1. 我们价值为 0.5 的商品有哪些
![[Pasted image 20240312142413.png]]
2. 购买了这些商品的用户的 id 号是什么
![[Pasted image 20240312142419.png]]
3. 这些顾客的姓名是什么
![[Pasted image 20240312142427.png]]


## 除法运算 ：
除法运算是我们笛卡尔运算的一个逆运算，但要注意，我们的除法运算相当于是做一个带余除法，我们的剩余预想就是不能够完全由我们的笛卡尔乘积表示的元素。

除法的含义是：
**那结果就是在被除数中，/同时/满足除数表中所有条件的学生信息，但没有除数中的字段的新表**


设关系 R 除以关系 S 的结果为关系 T，则 T 包含所有在 R 但不在 S 中的属性及其值，且 T 的元素与 S 的元组的所有组合都在 R 中。
![[Pasted image 20240326125909.png]]


![[Pasted image 20240326130612.png]]

我们的手算除法运算可以分为下面的几个步骤：

第一步：计算参与运算的两个表格标题的共有属性所构成的集合，标记为 Y

第二步：在表格一中，我们找与 Y 无关的属性，并判断这些属性有多少个取值。取值集合记为 `A`,其中我们找到这个集合对应于 Y 的映像集（也就是我们这个取 A 中的某个值是，我们的 A 对应的取值是那些），例如：$Y_{a_{1}}={(B_{1},c_{2}),(b_{2},c_{3}),(b_{2},c_{1})}$
$Ya_{2}=(b_{3},c_{7})$, $Y_{a_{3}}=(b_{4},c_{6})$ , $Y_{a_{4}}=(b_{6},c_{6})$。

第三步：同理，在我们的表格二中，我们找与 Y 无关的属性，并将其对应的取值集合记为 B ($(b_{1},c_{2}),(b_{2},c_{1}),(b_{2},c_{3})$)

第四步：将我们的 $S_{B}$ 与我们的 $Y_{a_{i}}$ 进行比较，满足 $Y_{a_{i}}\geq S_{B}$ 则 $a_{i}$ 包含在 $\frac{R}{S}$ 的表格中。

例如：与顾客 $c{0}6$ 购买了相同的商品的所有顾客的顾客号。
我们考虑：我们的集合等于我们的所有顾客减去我们没有任何商品和 $c06$ 相同的顾客。

我们考虑先找到顾客 $c_{006}$ 购买的所有商品构成的集合 A，筛选的语句如下：`(O where cid=c006)[pid]`,

然后我们的被除数，就是我们的订单中的所有元素：记为 `(O)[pid,cid]`

注意，我们这里是要先找到我们的除法，找到我们的对应主键，再去进行我们的选择操作。因为我们的**除法会把我们的多余的元素给删除掉**，只留下我们的关键怨怒。


