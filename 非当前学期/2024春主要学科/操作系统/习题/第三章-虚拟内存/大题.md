## 页面置换：
![[Pasted image 20240628135053.png]]

我们的方法是通过我们的下面的表格，我们的**第一行表示我们的页面走向序列**，我们的**第一列表示我们的块号**，我们的对应的每一个方格内表示**在这个序列下，我们的最终样子是什么样**。最后，我们就可以生成下面的方法：

### OPT 算法：
我们的 OPT 算法就是，每一次找到我们的当前页面中**最远的没出现过的那一个元素，把这一个元素替换**。
![[YCR3MNNN42HCSBR5C@B3_[Y.jpg]]

### FIFO 算法
![[T0OS@A%OU))G4B6W{{@TQXV_tmb.jpg]]

### LRU 算法：
我们每次淘汰的页面是**最近最久没有使用的页面**，也就是**选择现有页面中 $t$ 值最大的**，也就是最靠左的那一个。也就是说，我们从当前位置**向前扫描**，找到**最后一个出现的元素是哪个**，九八那一个元素替换掉。
![[3LK5A$K7M1P0{2YR03XT7X6_tmb.jpg]]

这一种算法**性能最接近最佳置换算法**，但是我们的**开销要求很大**。



### 时钟置换算法：
简单 CLOCK 算法：我们为我们的每一个页面设置一个访问位，再将内存中的页面都通过连接或者指针连接成一个循环页面。当某页被访问时，其位置置为 1.

简单的 CLOCK 算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为 O 的页面，因此简单的 CLOCK 算法选择一个淘汰页面最多会经过两轮扫描)



（找到第一个为 0 的页面，然后把这一个页面淘汰，新页面换进来置为 1，并且**每一次扫描过后，就把对应的位置异或**。）
## 地址映射
![[Pasted image 20240621173014.png]]

![[Pasted image 20240621173641.png]]
第零：求页表的页框号：
我们的页表的页框号，而可以通过**逻辑地址**的前面位置，来得到我们的**下标**。

第一：求页表的物理地址 
我们要求我们的页表的物理地址一，我们可以转换为求我们的页表项距离我们的起始地址有多少也页表项。**这一个可以根据我们的虚拟地址的页表项得到**。那么我们就能知道，我们的这一个位置距离我们的**起始地址的距离是 32 B**，因为我们的一个物理地址占用的大小是**4 B**。
![[Pasted image 20240621174055.png]]
![[Pasted image 20240621174006.png]]


第二：求物理地址：
我们直到我们的**逻辑地址到我们的物理地址的转换**，那么如果我们是**连续存放的**，那么我们只用接着我们的规律去地推即可。
	
![[Pasted image 20240621174151.png]]


![[Pasted image 20240623142519.png]]
