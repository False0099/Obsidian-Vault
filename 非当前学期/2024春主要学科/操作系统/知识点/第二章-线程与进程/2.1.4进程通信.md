进程是我们的分配系统资源的单位，因此我们的各个进程之间的内存地址空间是**相互独立**的。因此，我们的**进程 A**是不能直接访问**进程 B**的对应的内存的。
![[Pasted image 20240417145910.png]]
也因此，我们一个进程如果想要访问另一个进程，那么我们这个时候我们进程之间的通信，就需要通过我们的**操作系统**来进行协调。

## 共享存储（共享内存）
我们的思路是：让我们的进程 $P$ 和进程 $Q$ 都申请出一块共有的区域作为我们的共享存储区，然后我们如果要进行数据交换，都去通过这一个共享存储区即可。同时，我们需要通过我们的**PV 操作**来进行我们的内存共享。
![[Pasted image 20240417150012.png]]

![[Pasted image 20240417150048.png]]

同时，我们需要保证我们各个进程对于我们的共享区的访问时互斥的。（进程的同步与互斥）

同时，我们这一种通信方式又可以分为下面的两类：
基于存储区的共享：操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式。

基于数据结构的共享：比如共享空间里只能放一个长度为 10 的数组。这种共享方式速度慢、限制多，是一种低级通信方式。
![[Pasted image 20240507192929.png]]

## 消息传递：
进程间的数据交换以格式化的信息为单位，进程通过操作系统提供的“**发送消息/接收消息**”两个原语进行数据交换。这种方式频闭了我们的通信的实现细节，**当前比较常用的一种方式**。该机制能够较好的支持我们的分布式系统等等。

当然，我们的消息传递也可以再细分为直接通信方式和简介通信方式两种，我们的间接通信方式就是要把我们的信息放在我们的**邮箱**，然后又把我们的**邮箱**转发给别人。

![[Pasted image 20240417150614.png]]

## 管道通信
我们的管道通信类似于我们的**水管**，我们的数据只能由**一端写入我们的另一端，是单向的**。我们创建一小段缓冲区，这一个**缓冲区**（内存）用来存储我们的消息。类似于我们的 IO 设备。（这一段缓冲区可以是匿名的也可以是命名的）

在我们的操作系统中，我们的实现是通过我们的一个**Pipe**文件，我们操作系统每一次会新开一个**Pipe**文件，我们每一次可以向我们的这一个**Pipe**文件中写一个数据。我们的另一端也会从我们的 **Pipe**读取一个数据。
![[Pasted image 20240423202250.png]]
