## 临界区互斥实现方法：
### 单标志法：
我们采用我们的一个标志，用于指示允许进入临界区的进程编号，该算法可以保证每次只允许一个进程进入临界区，但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也无法进入临界区。

算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。
![[Pasted image 20240429205754.png]]

可能存在的问题：有的程序占着茅坑不拉屎，一半天都不去访问我们的冲突资源，或者不需要去访问冲突资源。

例如：如果我们的 $P_{0}$ 顺利进入并离开，我们这个时候标志位跳为 $1$，但我们的 1 一直处于阻塞状态。而这个时候我们想要再去运行 $P_{0}$ ，也无法实现。
(为什么是不等号，而是等号？)
```
0:while(turn==0); 访问冲突资源； turn=1;等待;
1:while(turn==1); 访问冲突资源； turn=0;等待;
```

### 双标志先检查法：
算法思想：设置一个布尔型数组 flag[],数组中各个元素用来标记各进程想**进入临界区的意愿**，比如“flag[O]=ture”意味着 O 号进程 PO 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 flag[i]设为 true,之后开始访问临界区。


```
0进程:while(flag[1]);1
flag[0]=true;3
0访问冲突资源;
flag[0]=false;

1进程:while(flag[0]);2
flag[1]=true;4
1访问冲突资源;
flag[1]=false;
```

![[Pasted image 20240429210446.png]]

### 双表示后检查法：
我们考虑怎么修改我们的双标志先检查法，我们发现，我们错误的原因是，我们检查完后就进行赋值了，这会导致我们可能存在错误。
我们一种显然的修改方法是，如果我们这个进程的状态修改，应该在我们的一开始就去进行，之后，我们再去让我们的元素去执行我们的后续操作。这样，我们就不会因为我们的执行顺序问题，而导致我们的最后产生错误。

我们这里相当于我们先上锁后检查，这种方法可以避免我们的同时访问，但也存在着一定的问题，例如，我们同时给我们两个都上了锁，然后我们就一个也访问不了
```
flag[i]=true;1 
while(flag[j]);4
临界区；
flag[i]=false;

flag[j]=true;2
while(flag[i]);3
临界区；
flag[j]=false;
```
![[Pasted image 20240429210610.png]]

### Peterson's Algorithm

![[Pasted image 20240429210654.png]]

过程：
当我们的程序想要访问我们的临界资源是，首先会让我们的 `flag[i]=true`，然后再把我们的 turn 修改为对方的。
之后我们的程序进行观察，如果对面没用，我们直接进，如果对面的在用，我们就观察上面的字条（turn）是谁。如果 turn 是自己，那么我们就直接进去，否则我们就接着观察。

为了解决我们的双表示后检查法中可能存在的死锁问题，我们重新引入了我们的 `turn` 来所谓我们的检查的依据，我们写出的伪代码如下所示：
```
flag[i]=true,turn=j;
while(flag[j]&&turn==j);
处理冲突资源;
flag[i]=false;

flag[j]=true,turn=i;
while(flag[i]&&turn==i);
处理冲突资源;
flag[j]=false;
```
