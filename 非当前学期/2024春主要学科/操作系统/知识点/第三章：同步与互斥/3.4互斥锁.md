## 互斥锁
我们的互斥锁是一种我们判断是否冲突的方式，在上文中，因为我们只存在两个元素，所以我们使用我们的 `flag[i]` 和我们的 `turn` 是合理的，但如果我们的元素个数扩展到我们的 $\mathbb{N}$ 个，那么我们的上面的开销就过大了。
此时，我们可以仿照上面的思想，构造出我们的互斥锁，我们只有抢到我们的锁的人，才能够去处理我们的相关操作。否则，我们就不能去进行相关的操作。**一个进程再进入临界区的时候，我们获得我们的锁，在退出临界区的时候，我们释放我们的锁**。
```
int status=1
void lock（）{
retry:
	int got=atomic_xchg(&status,0);
	if(got!=1){
		retry;
	}
}
void unlock(){
	xchg(&status,1);
}
```

当我们的互斥锁为打开的时候，我们的每一个进程都有可能去处理我们的互斥资源，当我们的互斥锁为关闭的时候，我们除了正在运行的那一个，都不能去处理我们的互斥资源。

我们的一个互斥锁包括两种操作：获得和我们的删除。互斥锁的只要问题在于我们的忙等待，当有一个进程在临界区当中的时候，任何其他进程在进入时，必须连续调用我们的 `acquire`。
```text
acquire(){
	while(!avalible);
	turn=i;
	avalible=false;
}
release(){
	avalible=true;
}
```

