## 信号量锁
用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。

信号量其实就是一个变量 (可以是一个整数，也可以是更复杂的记录型变量), 可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。

原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”,因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。

我们的信号量，在某种意义上，可以视作一个**限制条件**。只有我们所有的限制条件都满足的时候，我们的某一个程序才能继续进行。否则，我们无法执行。

我们的一种可行的进程锁是通过我们的一个“信号量”，我们的程序对于我们的信号量会有两种对应的原语，我们的信号量只能被两个标准的原语 `wait(S)` 访问，或者被我们的 `signal(S)` 来访问。
![[Pasted image 20240502213942.png]]

## 整型信号量：

![[Pasted image 20240502214131.png]]
我们的**整形信号量**只能进行我们的操作，并且我们的对应的元素具有我们的实际意义。
在我们的具体实现中，我们的信号量可以大致的分为整形和记录行两类：
```c
int S = 1; // 整型信号量S，表示某种资源的数量

void wait(int S) { // wait原语
	while(S <= 0); // 资源数不足，循环等待
	S = S - 1; // 占用资源
}

void signal(int S) { // signal原语
	S = S + 1;	// 释放资源
}
```

但我们能够注意到，上面的整数型记录并没有能够实现我们想要实现的功能，因为我们的 `while(S<=0)` 语句会导致我们的循环等待。**没有保证我们得不到锁的时候直接不占用处理机**。处在我们的忙等阶段。

### 记录型信号量：
![[Pasted image 20240502214334.png]]

于是，我们考虑对于我们的冲突资源区域建立我们的变量，记录我们冲突资源上有哪些进程会调用，我们的冲突资源上的资源数量有多少。
```c
typedef struct {
	int value; // 某种资源的数量
	struct process *L; // 等待队列
} semaphore;

void wait(semaphore S) { // wait原语
	S.value--;
	if(S.value < 0) {
		block(S.L); // 阻塞进程
	}
}

void signal(semaphore S) { // signal原语
	S.value++;
	if(S.value <= 0) {
		wakeup(S.L); // 唤醒进程
	}
}
```

![[Pasted image 20240502214508.png]]

![[Pasted image 20240502214604.png]]


![[Pasted image 20240502214733.png]]
而通过我们的上述信号量，我们就可以实现我们进程之间的同步, 与互斥。


## 互斥实现：
我们的互斥也就是同一个时刻只能有一个元素进入到我们的临界区域中，我们可以认为我们的 mutex 表示**进入临界区的名额**。P 表示申请资源，V 表示释放资源。

**注：对于不同的资源，我们要设置不同的互斥信号量**。
```
semaphore mutex=1;
P1(){
	down(mutex)/P(mutex);
	...
	up(mutex)/V(mutex);
}
```

## 同步实现：
第一步：找到**一前一后关系**。
第二步：设置一个同步信号量**S**, 让我们的前置动作负责**释放**，后置动作负责**申请**
![[Pasted image 20240502215414.png]]

![[Pasted image 20240502215521.png]]

## 前驱后继

![[Pasted image 20240502215713.png]]


前操作之后对应得同步信号量执行 V 操作
后操作之前对相应的同步信号来执行 P 操作

### 同步
```
semaphore S=0;
P1(){
	x;
	V(S);
}
P2(){
	...
	P(S);
	y;
}
```
### 互斥：
S初始为1
先判断能否进入
然后再释放
semaphore S=1;
P1(){
	P(S);//等待S执行完
	V(S);//之后再允许其他执行
}
P2(){
	P(S);//等待S执行完
	V(S);//之后再允许其他执行
}
```

## 先后关系：
```
semaphore a1=a2=b1=b2=c=d=0;
S1(){
	
	V(a1),V(a2);//先执行S1的内容，并允许后续的内容执行
}
S2(){
	P(a1);//等待a1执行完
	v(b1),v(b2)//允许b1,b2执行
}
```

