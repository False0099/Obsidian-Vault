## 硬件处理方法：
1. 中断屏蔽方法
因为我们的每一次多线程执行本质上是通过了我们的一个中断来进行我们的多线程的。因此只要我们能够**关闭我们的中断**，我们就可以直接去中断我们的执行。
![[Pasted image 20240629192449.png]]
但是我们可能的问题是，我们的中断频闭涉及到了我们计算机的非常多的信息。关闭我们的中断会导致存在的问题。并且，我们的中断屏蔽是一个特权指令，对于普通的程序来说是无法执行的，并且对于我们多核的 CPU 也是无法执行的。

2. 硬件指令
就是把我们的原本分开的指令统一加到一起来进行我们的执行，也就是通过我们的汇编指令来限制我们的特权指令和相关的执行。
### testandsetlock
也简称为 TS 指令，我们通过我们的硬件方法，

![[Pasted image 20240429211714.png]]
具体的功能就是用一个共享变量 lock 表示我们的临界区是否加锁。
若刚开始 lock 是 false, 则 TSL 返回的 old 值为 false, while 循环条件不满足，直接跳过循环，进入临界区。若刚开始 lock 是 true, 则执行 TLS 后 old 返回的值为 true, while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。


### swap 指令
![[Pasted image 20240429211959.png]]

逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁 (记录在 old 变量上), 再将上锁标记 lock 设置为 true, 最后检查 old, 如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。

优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
缺点：**不满足“让权等待**”原则，暂时无法进入临界区的进程会占用 CPU 并循环执行 TSL 指令，从而导致“忙等”。
