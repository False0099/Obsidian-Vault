### 死锁避免：
与死锁预防不同，我们的死锁避免的思想是通过在我们的资源分配时，避免我们的资源进入到我们的不合法状态，从而让我们的系统调度合理。

所谓的合法状态，也就是我们存在一个序列，使得我们按照一定的序列来执行时，一定不会发生死锁。而我们的这个序列可以通过一定的算法计算出来。

### 银行家算法：
![[Pasted image 20240327161504.png]]



#### 变量定义
我们将我们的可利用的资源存储在一个 `Avalible[M]` 数组当中，其中每一个元素代表我们一类可用资源的数目。

最大需求矩阵 Max: $n\times m$ 矩阵，顶级进程中我们需要的资源的个数是多少。例如：$ma[i][j]$ 表示我们的程序 $i$ 需要我们的 $j$ 类资源的个数是多少。

分配矩阵 Alloc: $n\times m$ 矩阵，定义我们**已经**给每一个程序的每一个资源分配了多少个。

需求矩阵 Need：$n\times m$ 矩阵，定义我们还需要给我们的第 $i$ 个程序的第 $j$ 类资源分配多少个。

#### 分配检查
假设我们的 $Request[i]$ 表示我们第 $i$ 类需要的资源列表。之后，我们的系统按照下面的方式来进行检查：
1. 如果我们的 $Request[i]\leq Need$,那么我们就转向我们的程序二，否则认为出错
2. 如果我们的 $Request[i]\leq Avalible[j]$,那么我们就转到我们的步骤三，否则表示没有足够资源，需要等待。
3. 系统试探性的把资源分配给进程 P，并修改下面数据结构中的数值：
$Available$ $=\mathrm{Available-Request}_i$; 
$Allocation[i,j]$ = $Allocation [i, j] + \mathrm{Request}_i[ j]$
 $Need$ $[i,j]=\mathbb{Need}[i,j]-\mathbb{Request}$

#### 安全性检查
4. 系统进行安全性检查，检查执行此次分配后，系统是否处于安全状态。如果安全，我们才吧对应的元素分配，否则我们不分配。

安全性检查的思路（类似于我们的拓扑排序？）：
首先，我们的一个安全的序列一定是由另一个安全的序列转移来的，所以我们可以假设我们之前的那个安全的序列为 $q$,以及我们把我们的这些序列执行后，我们的剩余元素是哪些，以及我们手上还有的可能的资源有哪些，记为 $work$。初始时，我们设置：$Work=Avalible$,

我们每一次更新我们的安全队列，首先从我们的矩阵中找到所有的行，满足这个行需要的资源 `Need` 小于我们当前手上还有的资源.

找到我们的这一行之后，我们假设我们执行完成这一个程序，并释放分配给它的资源，$Work+=Allocation[i]$,并且把我们的这一个进程放到我们的安全队列中。

如果我们找不到我们的对应的元素，我们就