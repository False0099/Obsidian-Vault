## 概念：
在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。然而，多个进程的并发执行也带来了新的问题一死锁。所谓死锁，是指**多个进程因竞争资源而造成的一种偃局**(互相等待),若无外力作用，这些进程都将无法向前推进。

所谓死锁就是多个程序同时争夺一个资源，导致我们这个资源被限制的同时，我们的各个程序也没法执行目标代码。

例如：我们的计算机只有一个打印机和一个输入设备，而我们的两个程序都希望能够打根据我们的输入来打印。但遗憾的是，我们的一个程序控制了我们的输入，另一个程序控制了输出，这就导致了我们的死锁。

## 产生原因：
综合来看，我们死锁的产生有下面几个方面的原因：
1. 系统资源的竞争，且不可剥夺：通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。
2. 进程推进顺序不当：进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程 $\mathbb{P}_1,\mathbb{P}_2$ 分别保持了资源 $\mathbb{R}_1,\mathbb{R}_2$,而进程 P $_1$ 申请资源 $\mathbb{R}_2$、进程 $\mathbb{P}_2$ 申请资源 $\mathbb{R}_1$ 时，两者都会因为所需资源被占用而阻塞，于是导致死锁。

## 必要条件：
1. 互斥条件（我们的进程要求对所分配的资源进行排他性使用，也就是在一段时间内我们的资源只能同时给一个人使用，不能给多个人使用）
2. 不剥夺（进程获得的资源在使用完成之前，不能被其他的程序强行夺走，只能由获得该资源的程序来自己释放。我们采用的调度算法不会强行把我们的程序资源给剥夺了）
3. 请求并保持条件（进程已经保持了至少一一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但**对自己已获得的资源保持不放**。）
4. 循环等待条件（我们的等待关系构成了一个环，）
![[Pasted image 20240629200120.png]]

## 处理方法：
我们对于我们的死锁的处理根据我们的时间顺序，可以有下面的四种方法：
第一种：死锁的预防，我们可以通过在**运行程序之前**，就去把我们的死锁的四个必要条件进行**破坏**，也就是破坏我们的死锁生成的四个必要条件。

第二种：死锁的避免，如果我们不能破坏我们的四个必要条件，我们也可以考虑在我们的程序运行时，通过**找到一个不会产生死锁的序列**来避免我们的死锁的发生。

第三种：如果我们实在不行一定发生了死锁，那么我们的**后续处理**就是我们需要考虑的了，我们的后续应该包括我们的**死锁检测**，检查是我们的程序慢，还是我们已经产生了死锁。以及我们的**死锁处理**。