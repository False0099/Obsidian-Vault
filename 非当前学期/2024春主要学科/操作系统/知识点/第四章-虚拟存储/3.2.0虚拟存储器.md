我们的虚拟存储器，也就是将我们的**覆盖与交换技术**应用到我们的离散内存分配综合之后的结果。我们惊人的发现，如果我们采用我们的离散内存分配方式，我们的覆盖与交换技术可以有一个很高很好的效率。
通过虚拟存储器技术，我们可以在下面的部分得到更加好的效果：
1. 通过较小的空间去运行更大的程序：可在较小的可用内存中执行较大的用户程序，我们可以通过灵活的**交换与覆盖**，来让我们的技术得到扩大；  
2. 大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)  
3. 并发：可在内存中容纳更多程序并发执行；  
4. 易于开发：与覆盖技术比较，不必影响编程时的程序结构，因为我们的地址是**完全离散的**，我们每一次交换只是针对我们的部分内存来进行。

## 虚拟页式存储器：
系统自动地**将作业的地址空间分页**，将系统的主存空间分块，页与块等大小，在作业运行前，只把初始需要的一部分页面装入内存块里，运行中需要访问自己地址空间中的但当前不在内存的页面时产生缺页中断，由缺页中断服务程序将所需的页面调入内存，若此时**内存中没有空闲物理块安置请求调入的新页面，则系统按预定的置换策略自动选择一个或一些在内存的页面，把它们换出到外存**。

虚拟页式存储管理实际是实分页技术与虚拟存储技术相结合的产物，其分页思想与实分页是一样的。
### 硬件支持：
不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面：
· 一定容量的内存和外存。
· 页表机制 (或段表机制), 作为主要的数据结构。
· 中断机构，当用户程序要访问的部分尚未调入内存时，则产生中断。
· 地址变换机构，逻辑地址到物理地址的变换。

### 数据结构：
为实现虚拟页式存储管理:  
需要置**换技术、请求装入技术和大硬盘**支持，另外：  
页表表目需要增加**外存块号、状态位、访问位或访问字段、修改位、存取控制字段**等。

**外存块号**指出该页在外存的地址，供调入该页时用；  
**状态位**指示该页是否在内存；  
**访问位或访问字段**则是该页被访问过的标志或被访问过的次数；  
**修改位**表示该页是否被修改过；  
**存取控制字段**则是用来限制页面被安全共享的。

在添加了我们的上述变换之后，我们应该有下面的变换方法：
![[Pasted image 20240613101611.png]]



### 页面调度算法（将谁调出）:
#### 最佳置换算法：
我们的最佳置换算法是一种**只存在于理论**上的置换算法，要求我们每一次就把我们之后不会再使用，或者之后很长的时间内不会再使用的调出。
![[Pasted image 20240613102300.png]]
也就是说，我们的这一种算法是一个**离线算法**，我们必须事先得知我们的引用串，我们才能知道我们的理论最佳是多少。

#### FIFO 算法：
该种算法是按照时间顺序将我们的内存块进行排序，**根据时间顺序**来进行我们的淘汰。
![[Pasted image 20240613102558.png]]

贝拉迪异常：当为进程快分配的内存块数增大的时候，我们的缺页次数不减反增。

#### LRU（最近最久未使用）
我们将我们的每一个页表项中记录我们某一个页面的上一次调用时间 $t$,我们 **选取上一次调用时间最早的淘汰掉**

![[Pasted image 20240613102842.png]]

#### 时钟置换算法（CLOCK）
这是一种性能和开销均衡的算法

简单的 CLOCK 算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其**访问位置为1**。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为 O 的页面，因此简单的 CLOCK 算法选择一个淘汰页面最多会经过两轮扫描)

也就是说，我们淘汰的时候，找到第一个，位置为 0 的页面，淘汰掉这一个页面即可。

改进型的 CLOCK 算法，我们还考虑我们的某一个页面是否被修改过，**只有修改过的，我们才回去放回我们的内存**。

![[Pasted image 20240613103820.png]]

## 页面分配策略：
驻留集：我们的驻留集也就是请求分页管理中给进程分配的物理块的集合。在采用了驻留集的技术中，驻留集大小一般小于进程的大小。

固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变
可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即驻留集大小可变。

局部置换：发生缺页时只能选进程自己的物理块进行置换。
全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换
到外存，再分配给缺页进程。

固定分配局部置换：系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。(采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数)

可变分配全局置换：刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。

### 调入页面的策略：
1. 预调页策略：根据局部性原理，一次调入若干个相邻的页面可能比一欢调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有 50%左右。故这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分。
2. 请求调页策略:进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到,但由于每次只能调入一页,而每次调页都要磁盘操作,因此开销较大。

![[Pasted image 20240613110200.png]]

