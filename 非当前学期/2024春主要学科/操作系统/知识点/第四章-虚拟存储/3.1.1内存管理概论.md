## 装入：
我们的装入模块就是我们的经过编译处理后得到的一个 exe 文件，我们的这一个文件中的内容就是**已经处理好的二进制编码**。那么，我们如何要能够去适应我们的地质变化和我们的原先汇编语言之间的关系？

我们的思路是：通过我们的**相对地址**，考虑我们的**逻辑地址**怎么映射到我们的**物理地址**。我们就可以考虑使用我们的三种装入方法：
1. 绝对装入：加入我们已经提前知道我们的**装入地址是哪里**，那么我们直接把我们原本的汇编语言中的所有指令都修改为**正确的物理地址即可**。这一种方式只适用于单道程序，灵活性很差。
2. 可重定位装入，静态重定位，我们采用静态重定位的时候，我们通过我们的某一种**自动方法感知我们的装入地址是哪里**，然后根据我们的**装入地址去修改我们的正确的物理地址**。也就是说采用这一种方法，我们的**内存上的**地址就是最终的地址。缺点是: 要求我们一次性就要给我们的程序分配所有的内存，并且我们的地址不能够移动。
3. 动态重定位，动态运行时装入：我们在装入的时候，仍然选择装入我们的**逻辑地址**，并且同时维护一个重定位寄存器用于我们将我们的地址偏移量。最后我们再把我们的元素之间进行计算，得到实际的**物理地址**。
![[Pasted image 20240612152246.png]]


## 链接：
我们的链接也就是把我们的原本分散的各个模块组合为一个完整的模块，这一种方式叫做我们的链接。我们存在有三种链接方式。
例如，我们原本有程序：`main.c`, `math.c`,我们通过我们的编译指令 `gcc -c main.c`, `gcc -c math.c`,来后的我们的两个文件，也就是我们的 `main.o,math.o`。这一种文件是对我们的二进制代码的一种封装。当中包括我们的**机器代码 (. Text)，数据 (. Data)**.

但是，我们的这一种 `.o` 文件还是不能够执行的，因为我们当中的一些函数仍然是没有被定义实现的，也就是说，我们的编译器是不知道我们的 `printf` 函数的存在的，我们的**这两个未知函数的跳转地址就会设置为 0**，这一步需要在我们的 **连接中被修正**，这一步我们可以通过我们的**重定位表格 . Reloc**来记录方便我们的后续链接修改。

之后，我们通过我们的下面的命令：`gcc main.o math.o -o main` 之后，我们就可以生成我们需要的文件了。
### 静态链接：
在我们的程序运行之前，我们先把我们的各目标模块以及他们所需要的一个库函数连接成一个完整的可执行文件，之后不再拆开。
![[Pasted image 20240612154353.png]]

这一种连接的问题是：编译得到的文件内存很大，冗余度很高，对于我们的各个方面来说都很不好。
### 装入时连接：
将各个目标装入内存时，一边装入一边链接的链接方式。

### 运行时动态链接：
我们在程序的执行过程中需要该模块目标时，才对他进行连接，其优点是便于修改和更新，便于实现对目标模块的共享。我们的思路是：**把我们的需要共享的代码提取出来，保存成一个独立的动态链接库**。等到程序运行的时候，再把它加载到内存。
![[Pasted image 20240612154608.png]]

![[Pasted image 20240612154615.png]]

我们在实际过程中，可以通过我们的 `gcc -shared -fpic math.c -o libmath.so`,来生成我们的动态链接库，这个时候，我们只需要在编译的时候，再去用：`gcc main.c -lmath -L. -o main` 得到我们的答案。

而我们在实际的工作工程中，会采用我们的动态链接库，我们现在我们的 `.data` 中存放一个表格用于存储我们的每一个未知函数的**实际物理地址**，这个表格与我们的代码段的**偏移量是固定的**。我们每一次动态载入一个 `dll` 库，就去更新一次我们的 `got` 表。这样，就保证了我们的**数据能够被所有进程共享**。


## 内存映像
不同于存放在硬盘上的可执行程序文件，当一个程序调入内存运行时，就构成了进程的**内存映像**。我们的内存映像也就是**描述了在我们的内存当中，我们的一个进程是什么样子** 。

一个进程的内存映像，也就是我们进程涉及到的和内存相关的模块，主要有下面的几个要素，也就是说我们的一个进程在我们的内存中由下面的几个部分组成：
·代码段：即程序的**二进制代码**，代码段是只读的，可以被多个进程共享。（这一个部分时**不可修改的**）
![[Pasted image 20240629202720.png]]
·数据段：即程序**运行时加工处理的对象**，包括全局变量和静态变量。
![[Pasted image 20240629202729.png]]
·进程控制块 (PCB): 存放在系统区。操作系统通过 PCB 来控制和管理进程。

·堆：用来存放动态分配的变量。通过调用 malloc 函数动态地向高地址分配空间。
·栈：用来实现函数调用。从用户空间的最大地址往低地址方向增长。

代码段和数据段在程序调入内存时就指定了大小，而堆和栈不一样。当调用像 malloc 和 free 这样的 C 标准库函数时，堆可以在运行时动态地扩展和收缩。用户栈在程序运行期间也可以动态地扩展和收缩，每次调用一个函数，栈就会增长；从一个函数返回时，栈就会收缩。

## 内存保护：
确保每个进程都有一个单独的内存空间。内存分配前，需要保护操作系统不受用户进程的影
响，同时保护用户进程不受其他用户进程的影响。内存保护可采取两种方法：
1)在 CPU 中设置一对上、下限寄存器，存放用户作业在主存中的**下限和上限地址**，每当 CPU 要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。
2)采用重定位寄存器 (又称**基地址**寄存器)和界地址寄存器 (又称限长寄存器)来实现这种保护。重定位寄存器含最小的物理地址值，界地址寄存器含**逻辑地址的最大值**。内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元，

在这种方式下，我们是采用**基地址+偏移量**的方法来进行我们的处理的。
![[Pasted image 20240629202955.png]]

## 内存共享：
并不是所有的进程内存空间都适合共享，只有那些**只读的区域才可以共享**。可重入代码又称纯代码，是一种允许多个进程同时访问但**不允许被任何进程修改**的代码。但在实际执行时，也可以为每个进程配以局部数据区，把在执行中可能改变的部分复制到该数据区，这样，程序在执行时只需对该私有数据区中的内存进行修改，并不去改变共享的代码。

## 内存分配与回收：
存储管理方式随着操作系统的发展而发展。在操作系统由单道向多道发展时，存储管理方式便由单一连续分配发展为固定分区分配。为了能更好地适应不同大小的程序要求，又从固定分区分配发展到**动态分区分配**。为了更好地提高内存的利用率，进而从连续分配方式发展到离散分配方式——页式存储管理。引入分段存储管理的目的，主要是为了满足用户在编程和使用方面的要求，其中某些要求是其他几种存储管理方式难以满足的。
