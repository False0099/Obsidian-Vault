## 分段：
段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序段、两个子程序段、栈段和数据段组成，于是可以把这个用户进程划分为5段，每段从0开始编址，并分配一段连续的地址空间 (段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的), 其逻辑地址中段号 $S$ 与段内偏移量 $W$ 两部分组成。
![[Pasted image 20240629203339.png]]

需要注意的是，我们因为我们的**每一个段的大小时不确定的**，对一个地址我们不能直接得到那一部分是我们的段号，那一部分是我们的段内偏移量。因此我们需要直到我们的**地址+段号**才能得到我们对应的内容与我们的程序的映射关系。

## 段号
我们每一个进程都有一个逻辑空间和内存空间映射的段表，其中每一个段表项都对应进程中的一段，段表项记录该段在内存中的**起始地址和长度**
![[Pasted image 20240629203623.png]]

之后，我们就可以通过我们的段号来找到对应的信息。
![[Pasted image 20240629203643.png]]

## 地址变换机构：
分段系统的地址变换过程如图 3.16 所示。为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址 $F$ 和段表长度 $M$。从逻辑地址 $A$ 到物理地址 $E$ 之间的地址变换过程如下：
![[Pasted image 20240629203714.png]]

我们每一次从我们的逻辑地址中取出我们的前几位作为我们的段号，后面的部分作为我们的段号，后面的若干位作为我们的偏移量。

## 保护与共享：
在分段系统中，段的共享是通过两个作业的段表中相应**表项指向被共享的段的同一个物理副本**来实现的。当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。不能修改的代码称为纯代码或可重入代码 (它不属于临界资源), 这样的代码和不能修改的数据可以共享，而可修改的代码和数据不能共享。
与分页管理类似，分段管理的保护方法主要有两种：一种是**存取控制保护**，另一种是**地址越界保护**。地址越界保护将段表寄存器中的段表长度与逻辑地址中的段号比较，若**段号大于段表长度**，则产生越界中断；再将段表项中的段长和逻辑地址中的段内偏移进行比较，若**段内偏移大于段长**，也会产生越界中断。分页管理只需要判断页号是否越界，页内偏移是不可能越界的。

与页式管理不同，段式管理不能通过给出一个整数便确定对应的物理地址，因为每段的长度是不固定的，无法通过整数除法得出段号，无法通过求余得出段内偏移，所以段号和段内偏移一定要显式给出 (段号，段内偏移), 因此分段管理的地址空间是二维的。

