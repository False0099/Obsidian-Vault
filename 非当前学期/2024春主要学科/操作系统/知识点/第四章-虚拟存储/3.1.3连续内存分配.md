# 连续分配
连续分配：指为用户进程分配的必须是一个连续的内存空间  
![在这里插入图片描述](https://img-blog.csdnimg.cn/2ee9bd0a7e5443c8b5e89a9ece5e62a5.png)

### 3.1 单一连续分配
在单道程序环境下经常使用**单一连续分配**，这种方式把内存分为系统区和用户区两部分。其中系统区仅提供给 OS 使用，通常使用内存的低址部分。在用户区内存中，仅装有一道用户程序，整个内存的用户空间由该程序独占。**也就是说，我们只进行最简单的程序与内核的区分，并且限定我们一次只能执行一个程序。**

采用单一连续分配可以不采取存储器保护措施，因为在单用户环境下机器由一用户独占，不可能存在其他用户干扰的问题，同时不设置保护措施也可以节省硬件。即使出现破坏行为，也只有可能是用户程序自己破坏操作系统，OS 通过系统的再启动而重新装入内存。  
单一连续分配的实现简单，不会出现外部碎片，可以采用覆盖方式扩充内存且可以不需要内存保护措施。但是只能用于单用户单任务的 OS 中，会出现内部碎片，存储的的利用率比较低。
- 在单一连续分配方式中，内存被分为**系统区和用户区**
    - 系统区通常位于内存的低地址部分，用于存放操作系统相关数据
    - 用户区用于存放用户进程相关数据
- 内存中**只能有一道用户程序**，用户程序独占整个用户区空间
- **优点**：实现简单；**无外部碎片**；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的 PC 操作系统 MS-DOS）
- **缺点**：只能用于单用户、单任务的操作系统中；**有内部碎片**；存储器利用率极低

### 3.1 固定分区分配
当我们发展到我们的多道操作系统的时候，我们就会有希望能够同时执行多个程序的需求，**并且希望这几个程序之间互不干扰**而为此，我们也需要修改我们的对应的内存分配算法。

我们的思路是，把我们的用户空间分割成若干个大小相等的空间，每一次我们就给一个程序一个单位的空间，**也就是一个房子里住一个客户**。**每个分区中只装入一道作业**，这就形成了最早的、最简单的一种可运行多道程序的内存管理方式。

而针对着一种方式，我们提出了两种房间大小分配方法，一种是我们的分区大小相等，也就是给我们的每一个分区都配置一个相同的，这种一看就很 low。但同时，我们也有另一种技术，就是我们的分区大小不等的情况。
- 分区大小分配方法：
    - 分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合
    - 分区大小不等：增加了灵活性，可以满足不同大小的进程需求；根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）

而与此同时，为了能够解决我们的**程序之间互不干扰**这一个需求，操作系统需建立一个数据结构——**分区说明表**（数组或链表），用来说明，我们的每一个分区的大小，起始地址，以及这一个分区是否已经有一个程序，并且为实现各个分区的分配与回收做准备。 
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/7b999897202746f0b4821f696323d30e.png)
![[Pasted image 20240621150702.png]]



- 优点：实现简单，**无外部碎片**（外部碎片指我们的内存中由于太小，而无法给**任何程序分配的**内存片段）这是因为我们的每一段大小都是固定长度的
- 缺点：
    1. 用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能
    2. 会产生**内部碎片**（我们的内部碎片指已经分配出去，但是却不能够被利用的内存片段，也就是我们**占着茅坑不拉屎**），这是因为我们的固定长度不一定与我们的实际内存匹配，从而导致内存利用率低

### 3.3 动态分区分配
考虑到我们的上面的静待分区算法中的不足，就是我们的**内存的浪费**，假设我们有一个总大小为 `1MB+9MB` 的，但是如果我们的分块大小是我们的 `2MB+8MB`，那么我们就只能在同一个时刻，运行我们的一个程序，另一个程序运行不能。

但是，因为我们是静态分配的，所以我们一定可以构造出一种方法，使得我们的内存的浪费率达到我们的一个让人无法接受的值。

这个时候，哦我们就需要考虑能够动态的组织我们的内存。这种策略不会预先划分内存分区，而是根据进程的实际需要动态地为之分配内存空间，这种方式的优点是可以**尽可能使分区大小正好适合内存所需**。在实现动态分区分配时，涉及到分区分配中所用的数据结构、分区分配算法和分区的分配与回收操作这样三方面的问题。

### 数据结构：
对于我们的动态分区分配，我们仍然去对我们的分区建立一个表格，我们的这一个表格中应该包含我们的分区好，分区大小，起始地址，是否有程序几个部分来进行。**同时，我们应采用我们的链式结构，或者我们的数组结构**。

![[Pasted image 20240612164148.png]]

- 数据结构记录：
    - 空闲分区表：每个空闲分区对应一个表项，该表项包含分区号、分区大小、分区起始地址等
    - 空闲分区链：每个分区的起始部分和末尾部分，分别设置前向指针和后向指针；起始部分处还可记录分区大小等信息  
        ![在这里插入图片描述](https://img-blog.csdnimg.cn/9599f4f51f744f33bbb48983f5efe336.png)
- 选择分区时，须按照一定的**动态分区分配算法**
    1. 回收区的后面有一个相邻的空闲分区，则两个相邻的空闲分区合并为一个
    2. 回收区的前面有一个相邻的空闲分区，则两个相邻的空闲分区合并为一个
    3. 回收区的前、后各有一个相邻的空闲分区，则三个相邻的空闲分区合并为一个
    4. 回收区的前、后都没有一个相邻的空闲分区，则新增一个表项
- 动态分区分配**没有内部碎片，但有外部碎片**
    - 内部碎片：分配给某进程的内存区域中，如果有些部分没有用上
    - 外部碎片：内存中的某些空闲分区由于太小而难以利用
- 若内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求：可以通过**紧凑（拼凑，Compaction）技术**来解决外部碎片

### 动态分配算法：
#### 首次适应算法：
我们的首次适应算法就是从我们的空余的分区中，找到**第一个满足要求的分区**，然后占领着一个分区，就可以实现我们的首次适应。我们因此，需要把我们的分区进行**地址排序**，然后再去依次查看我们的元素是否满足。（从大到小排序）**也可以理解为最近适应算法**

我们的首次适应算法通常搭配：**空闲分区表**，**空闲分区链**来进行分配。
![[Pasted image 20240529151600.png]]

#### 最佳适应算法：
因为我们的分配的空间必须是一个连续的算法，我们应该**尽可能的保留我们的大空间**。最后尽肯能的让我们的容量尽可能的大。（从小到大排序）**也叫做我们的最小适应算法**

我们同样的，维护一个空闲分区连或者空闲分区表。每一次有一个新的空间进来，我们就把这一个放到我们的对应信息当中。
![[Pasted image 20240529151729.png]]

缺点：可能会留下很多的内存碎片。

#### 最坏适应算法：
我们每一次分配的时候，优先使用我们的尽可能大的空闲区，这样的话就能减少我们的碎片。也叫做**最大适应算法**

![[Pasted image 20240529152005.png]]

### 邻近适应算法：
![[Pasted image 20240529152156.png]]


![[Pasted image 20240529152312.png]]
