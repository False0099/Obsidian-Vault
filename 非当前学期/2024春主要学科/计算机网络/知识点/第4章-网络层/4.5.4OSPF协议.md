**OSPF 协议是建立在我们的网络层的协议**。

## 相关规定：
1. 代价：在我们的 OSPF 协议中，我们的代价是我们的 `100MB/s` 除以 `路由带宽`.小于 1 的记为 1，大于 1 且有小数的，舍去小数即可。
2. 链路状态：链路状态指的是，我们该节点，与哪些结点相邻，走到这些相邻结点的代价是多少。

## 链路状态更新：
OSPF 中，相邻路由器之间，通过交互**问候**分组的方式来建立和维护邻居关系。
问候分组封装在 IP 数据报中，发往组播地址：`224.0.0.5`，IP 数据报首部中的协议号字段的取值为 89，表明 IP 数据报中的载荷为 OSPF 分组。
![[Pasted image 20240605191934.png]]

我们每一次，发送问候的**发送周期为 10s**。
如果**40s**没有收到我们的邻居路由器的问候分组，则认为邻居不可达。
因此，每个路由器都会建立一个邻居表
![[Pasted image 20240605192116.png]]

## 链路状态通告：
我们任意使用 OSPF 的路由器，都会产生链路状态通告（**LSA**）, 在我们的 `LSA` 中，包含着下面两类信息：
1. 直连网络的链路状态信息，
2. 邻居路由器的链路状态信息。

## 链路状态更新分组：
链路状态通告 `LSA` 被封装在我们的链路状态更新 `LSU` 当中，采用可靠的泛洪法来进行发送。即路由器向所有的邻居路由器发送链路状态分组，（除了数据来源路由器除外）。可靠是指收到链路状态更新分组后要发送确认，收到重复的更新分组无需再次转发。

## 链路状态数据库：
我们使用 OSPF 的路由器，都需要维护一个链路状态数据库，用于存储我们的链路状态。通告 LSA。**通过各路由器洪泛发送封装有各自链路状态更新分组 LSU，各路由器的链路状态数据库 LSDB 最终将达到一致**。
![[Pasted image 20240605192716.png]]

## 最短路计算：
使用 OSPF 的各路由器，基于链路状态数据库 LSDB 进行最短路径优先计算，构建出各自到达其他路由的最短路径，即构建各自的路由表。
![[Pasted image 20240605192825.png]]


## 分组类型：
1. 问候分组：用来发现和维护邻居路由的可达性
2. 数据库描述分组：用来向邻居路由器给出自己的链路状态数据库中所有链路状态项目的摘要信息。
3. 链路状态请求分组：用来向邻居路由请求发送某些链路状态项目的详细信息。
4. 链路状态更新分组：路由器使用链路状态更新分组将其链路状态进行洪泛发送，即用洪泛发对整个系统进行更新。
5. 链路状态确认分组：对 4 的确认

## 工作过程：
1. 相邻路由器之间每隔 10s 交换一次问候分组
2. 交换问候分组后，给邻居路由器发送数据库描述分组（分享自己的**数据库信息**）
3. 接收到数据库信息后，我们的路由器会在检查后，向我们的**来源路由**发送链路状态请求分组，讲自己缺少的详细信息发送给**来源路由**。
4. 之后，我们的来源路由接收到信息后，我们就可以向我们的**发送路由**发送我们的**链路状态更新**信息。
5. 最后，我们最终达到一致后，我们就可以确认我们的链路状态分组。
6. 每当事件超过 30min 或**状态发生变化**的时候，我们就会根据我们的分组的内容，重新**洪泛发送我们的状态**。
![[Pasted image 20240605193502.png]]

## 多点接入的 OSPF 路由器
![[Pasted image 20240605193558.png]]

## OSPF 划分区域
![[Pasted image 20240605193803.png]]

