## 应用
常用于流式服务，例如我们的视频，音频。或者我们的 DNS 服务器，**无分片机制，网络层来分片**、只提供了分用复用功能，以及简单的错误校验。一般来说使用 UDP 协议的都要求**快**，比如**DNS**，

## 主要特点：
1.UDP 无须建立连接。因此 UDP 不会引入建立连接的时延。试想如果 DNS 运行在 TCP 而非 UDP 上，那么 DNS 的速度会慢很多。HTTP 使用 TCP 而非 UDP,是因为对于基于文本数据的 Web 网页来说，可靠性是至关重要的。（大约是一个 RTT）
2.无连接状态。TCP 需要在端系统中维护连按状态。此连接状态包括接收和发送缓存、拥塞控制参数和序号与确认号的参数。而 UDP 不维护连接状态，也不跟踪这些参数。因此，某些专用应用服务器使用 UDP 时，一般都能支持更多的活动客户机。
3. 分组首部开销小：TCP 有20B 的首部开销,而 UDP 仅有8B 的开销。
4. 应用层能更好地控制要发送的数据和发送时间。UDP **没有拥塞控制**，因此网络中的拥塞不会影响主机的发送效率。某些实时应用要求以稳定的速度发送，能容忍一些数据的丢失，但不允许有较大的时延，而 UDP 正好满足这些应用的需求。
5. UDP 支持一对一，一对多，多对一和多对多的通信

![[Pasted image 20240425172520.png]]


## 首部格式：
我们的 UDP 数据报包括两个部分：UDP 首部和我们的用户数据。
UDP 头部=
端口号（表明我们的传输是否有错误，16 bit）
+长度（**头部+数据段**）
+校验和（检查我们的是否有错，有错就丢弃）。

![[Pasted image 20240328142014.png]]
其中，我们的开头包括了我们的**源端口号**，`sorce Port`,我们的目标端口号；`Destination Port`，我们的用户的长度 `Length`，以及我们的校验和（只有在校验开启的时候才会被启用）。

当传输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口上交给应用进程，如图 5.3
所示。

如果接收方 UDP 发现收到的报文中的目的端口号不正确 (即不存在对应于端口号的应用进程), 那么就**丢弃该报文**，并由 **ICMP 发送**“端口不可达”差错报文给发送方。
### 校验和
在我们看到我们的 UDP 结构的时候，我们其实只有一个我们是不知道啥意思的，就是我们的校验和，这是个什么玩意儿？这个其实就是我们的一种校验机制，我们采用下面的方式来进行校验：（**计算方式**）

在计算校验和时，要在 UDP 数据报之前增加 12B 的伪首部，伪首部并不是 UDP 的真正首部。只是在计算校验和时，临时添加在 UDP 数据报的前面，得到一个**临时的 UDP 数据报**。**内容上是我们的发送方 IP 和接收方 IP**。校验和就是按照这个临时的 UDP 数据报来计算的。伪首部既不向下传送又不向上递交，而只是为了计算校验和。图5.4 给出了 UDP 数据报的伪首部各字段的内容。

发送方首先把全零放入校验和字段并添加伪首部，然后把 UDP 数据报视为许多 16 位的字串接起来。若 UDP 数据报的数据部分不是**偶数**个字节，则要在数据部分末尾**填入一个全零字节**(但此字节不发送)。然后按二进制反码计算出这些 16 位字的和，将此和的二进制反码写入校验和字段，并发送。接收方把收到的 UDP 数据报加上伪首部(如果不为偶数个字节，那么还需要补上全零字节)后，按二进制反码求这些 16 位字的和。当无差错时其结果应为全 1,否则就表明有差错出现，接收方就应该丢弃这个 UDP 数据报。
- 将数据块按16位（2字节）为一组进行累加，如果数据块长度为奇数，补一个字节的0以便凑成偶数长度。
- 累加时，如果产生溢出（超过16位），则将溢出的高位加到低位（即进行回卷处理）。
- 取累加结果的反码作为校验和。

第一步：把我们的段的内容当作十六位整数，我们一共有这样的数据一共**24**行因为我们一共有 20 B，也就是 160 bit，除以 18 位整数也就是说我们有 10 个整数。**（只包含头部）**

第二步：我们计算我们的所有整数的和，并把得到的值进行按位取反，就能够得到我们的校验和。

![[Pasted image 20240328142646.png]]

