## 可靠传输的结构：
![[Pasted image 20240607204029.png]]

## RDT 协议
### RDT 2.0（纠错）
我们的 RDT 2.0 是为了能够解决我们的传输过程中的**数据错误**问题，我们的解决思路是：
在我们的传递过程中。
1. 我们让我们的**接收方**检查我们的分组
2. 如果接收到的分组没有受到**损坏**，那么我们的接收方就给我们的发送方发送一个**ACK**，否则，我们的接收方给我们的发送方发送一个**NAK**。
3. 同一时间，我们的发送方就**等待**我们的分组信号，直到我们有一个分组信号到达。（停等协议）
4. 如果我们的发送方接收到的是我们的**ACK**, 那么我们就继续，反之，如果接收到的是**NAK**, 我们就重新发送我们的分组。
![[Pasted image 20240605200351.png]]
### RDT 2.1（序列号纠错）
注意到，在我们的**RDT 2.0**种，我们可能存在问题：我们没有考虑到我们的接收方接收到的 ACK 或者**NAK**是可能产生错误的。
对于我们的发送方，如果我们的接收到的是一个模糊不清的**ACK**或者**NAK**的时候，我们最简单的做法当然是无论如何都给我们的另一方发送我们的旧版本的数据包。但是我们的接收方不能判断我们的这一个新的数据包是**老版本或者是新版本**.

解决方法：
在我们的传送信号中添加**序列号**（Sequence Number）：发送方给每个分组增加序列号。接收方只需要检查序列号即可确定收到的分组是重传的还是新的分组。**同时序列号也解决了我们的分组重复问题**。
![[Pasted image 20240605200644.png]]

### RDT 2.2（优化纠错）
其实，我们根本不需要我们的**NAC**来确认我们的信息，我们只需要通过我们的 ACK 和我们的 SEq 即可实现我们的信息之间的传递。

接收方通过 ACK 告知我们**这一个 ACK**对应的序列号是多少。这就需要在 ACK 确认消息中显示地加入被确认分组的序列号。发送方接收到对同一个分组的两个 ACK（即**重复 ACK**）后，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组。

rdt 2.2 和 rdt 2.1 的细微变化在于，接收方此时必须包括又一个 ACK 报文所确认的分组序号，接收方此时必须检查接收到的 ACK 报文中被确认的分组序号。
![[Pasted image 20240605200705.png]]

### RDT 3.0（重传）
我们的 RDT 3.0 就是为了实现保证我们的**传输顺序**不发生改变。假定发送方传输一个数据分组，**该分组或者接收方返回对该分组的 ACK 发生了丢失，这样发送方都收不到应当到来的接收方的响应**。
我们可以分成两个部分：第一个**判断我们的顺序是否正确**，第二个**发生错误后应该怎么做**

对于我们的第一个问题，我们的思路是：增加一个新的机制**发送方等待“合理”时间**。（重传时间）

- 如果没收到 ACK，发送方重传分组。
- 如果分组或 ACK 只是延迟而不是丢失，那么重传会产生重复分组，但 rdt 2.2 中通过序列号机制已经能够处理重复分组（需要在 ACK 中显示地加入上一个被正确接收的分组序列号）。

发送方不知道是一个数据分组丢失，还是一个 ACK 丢失，或者只是该分组或 ACK 过度延迟，在所有这些情况下，发送方的动作是同样的：**重传**。在等待时间超过一定限度后，我们就会向对方重新发送一个数据包。为了实现基于时间的重传机制，需要一个**倒计数定时器（countdown timer）**。下面给出了 rdt 3.0 发送方的 FSM，而接收方的 FSM 与 rdt 2.2 完全相同。

![[Pasted image 20240605200303.png]]



rdt 3.0 已经是一个功能正确的协议，虽然采用停等协议使得该协议比较简单（只需要两个分组序列号），但性能很差，因为只有等收到了想要的 ACK，才会回到从上层接收数据的状态。如下面的例子中，假设端到端的传播延迟远大于数据分组的传输延迟，那么发送方对链路带宽的利用率是非常低的，即网络协议限制了物理资源的利用。

## 流水线复用
我们的 RDT 3.0 协议理论上可以完全的实现我们的所有的功能，但是我们的问题是我们的效率非常的低，理论最大 1 G 的链路实际传输速度只能达到 33 kb

![[Pasted image 20240425153410.png]]

流水线的核心就是：**允许在发送方没收到需要的信息时，也可以发送我们的下一条消息**。

流水线技术对可靠数据传输协议可带来如下影响：

- **必须增加序列号范围**，因为每个输送中的分组必须有一个唯一的序列号，而且也有许多个在输送中未确认的报文。
- **协议的发送方和接收方两端也许必须缓存多个分组**。发送方最低限度应当能**缓冲**那些已发送但没有确认的分组，接收方或许也需要缓存那些已正确接收的分组。

所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法：回退 N 步（Go-Back-N, **GBN**）和选择重传（Selective Repeat, **SR**）。

## GBN 协议（回退 N 帧）：
GBN=go back to N。在 GBN 协议中，允许发送方发送多个分组而不需等待确认，但它也受限于我们的**网络中的接收方的处理速度**，我们如果发送的过多，可能会导致我们的资源的浪费。
![[Pasted image 20240605200943.png]]
### 发送方：
#### 发送窗口：
我们采用 `N` 个比特来给我们的分组来进行标号，我们的序号范围应该是 $0-2^{n}-1$。我们的发送方，应该维护一个 `发送窗口Wt`，`WT` 的窗口大小应该在 $1-(2^{n}-1)$，如果超过了这一个大小就会造成**接收方无法分辨新帧和旧帧**。 在未收到接收方确认分组的情况下，发送方可以将序号落入 `WT` 内的所有数据分组连续发送出去。此时，我们的 `WT` 的取值范围可以是 2-7.

只有我们的序号落在我们的 `发送窗口WT` 范围内的数据可以进行我们的发送，其余的数据都不能进行我们的发送。

#### 接收窗口：
我们同样采用 `N` 个比特来给我们的分组进行标号，我们的序号范围应该是 $0-2^{n}-1$。我们的接收方，应该维护一个 `接收窗口`，只有正确到达接收方且五号落入 `WR` 范围内的数据分组才被接收方接收。`WR` 只能取值为 1.

我们的发送方每接收一个按需确认的确认分组，就将我们的发送窗口向前滑动一个位置，这样就有一个新的序号落入发送窗口，序号落入发送窗口内的数据分组可被继续接收发送。

#### 正常传输情况
发送方向我们的接收方连续发送我们的五个分组
![[Pasted image 20240605201758.png]]

接收方姐搜我们的分组后，窗口进行滑动，然后我们再向我们的发送方回复我们的数据。
![[Pasted image 20240605201810.png]]

此时，我们接受到对方的五个接收，我们的下方窗口也对应的移动。
![[Pasted image 20240605201817.png]]

#### 超时重传情况：
首先，我们的发送方向我们的接收方连续发送五个分组，我们的这五个分组
![[Pasted image 20240605202007.png]]

但是，我们的传输过程中，我们嫩的序号 2 对应的报文发生了传输错误。
![[Pasted image 20240605202113.png]]

此时，我们接收方接收到 0，1 分组正确，我们就会吧 2 号对应的报文以及后续的所有报文都丢弃，并向我们的发送方进行回复信息。
![[Pasted image 20240605202200.png]]

接收到了对方发送的 0，1 接收信息，我们的接收方的发送窗口就可以向前移动两格，
![[Pasted image 20240605202351.png]]


下图显示了发送方看到的 GBN 协议的序号范围，定义**基序号**（send_base）为最早的未确认分组的序号，将**下一个序号**（nextseqnum）定义为最小的未使用序号，则可将序号范围分割成 4 段。

在流水线中未确认的分组不能超过某个**最大允许数** N，**N 常被称为窗口长度**，

我们为了控制我们的**TCP**准确性，我们会在一定时间内，保证我们只采用**一个计时器**，在这一个计时器失效后，我们会**全部重传**。

![[Pasted image 20240425153501.png]]


![[Pasted image 20240428144111.png]]


![[Pasted image 20240428144505.png]]
有损坏？如果我们不是我们的期望的序号或者我们的像哟啊的答案，我们就直接回退即可。
无损坏？我们直接把我们的数据反传回去，并且修改我们的期望的序号之

![[Pasted image 20240605202558.png]]

**注意，我们的 ACK 接收时，是以我们的最大值来进行确认的，例如我们接收到 ACK 4 时，我们会直接向前移动 5 个**。

## 选择重传协议 (SR 协议）：
我们注意到，我们的回退发的代价很大，在有些情况下，我们是不可接受的，于是，我们可以考虑采用我们的选择重传协议。

选择重传的核心在于：我们收到了一定的信息后，我们不会直接去获得我们的对应的信息，而是根据我们的接受情况，选择我们需要那些新的需要发送的东西，需要再去返回什么样的信息。我们**采用一个接收窗口，接收不止一个信息**。

**在我们的协议中，我们要求我们的发送窗口和接收窗口的大小，都要满足** $\leq 2^{n-1}$。
![[Pasted image 20240607205858.png]]

## 过程：
第一步：我们的发送方向我们的接收方发送对应的数据，
![[Pasted image 20240607210019.png]]

第二步：我们的接收方考虑接收我们的数据，其中我们的二号分组就会产生数据丢失
![[Pasted image 20240607210045.png]]

第三步：这个时候，我们考虑接收我们的 0，1 并回复我们的 0，1 号确认分组，**接收窗口滑动对应距离**。接收 3 号，但是**不移动窗口**。
![[Pasted image 20240607210115.png]]

第四步：我们的发送方没收到一个连续按需窗口我们的发送方就移动我们的发送窗口。**并且发送后续的报文**。同时，我们额发送方收到我们的**非按需分组时**，我们不移动我们的滑动窗口
![[Pasted image 20240607210223.png]]


![[Pasted image 20240607210313.png]]
