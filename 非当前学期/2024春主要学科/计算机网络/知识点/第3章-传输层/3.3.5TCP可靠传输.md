1. 序号
TCP 首部的序号字段用来保证数据能有序提交给应用层，TCP 把数据视为一个无结构但有序的字节流，序号建立在传送的字节流之上，而不建立在报文段之上。

TCP 连接传送的数据流中的每个字节都编上一个序号。序号字段的值是指本报文段所发送的数据的第一个字节的序号。如图 5.9 所示。
![[Pasted image 20240702103427.png]]

2. 确立：
TCP 首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。在图 5.9 中，如果接收方 B 已收到第一个报文段，此时 B 希望收到的下一个报文段的数据是从第 3 个字节开始的，那么 B 发送给 A 的报文中的确认号字段应为 3。发送方缓存区会继续存储那些已发送但未收到确认的报文段，以便在需要时重传。
TCP 默认使用**累积确认**，即 TCP 只确认数据流中至第一个丢失字节为止的字节。例如，在图 5.9 中，接收方 B 收到了 A 发送的包含字节 0~2 及字节 6~7 的报文段。由于某种原因，B 还未收到字节 3~5 的报文段，此时 B 仍在等待字节 3 (和其后面的字节), 因此 B 到 A 的下一个报文段将确认号字段置为 3。

3. 重传：
我们在 TCP 中有两种时间会导致我们的 TCP 重传，**超时**和**冗余 ACK**。
#### 超时
TCP 每发送一个报文段，就对这个报文段设置一次计时器。计时器设置的**重传时间到期**但还未收到确认时，就要重传这一报文段。

由于 TCP 的下层是一个互联网环境，IP 数据报所选择的路由变化很大，因而传输层的往返时延的方差也很大。为了计算超时计时器的重传时间，TCP 采用一种**自适应算法**，它记录一个报文段发出的时间，以及收到相应确认的时间，这两个时间之差称为报文段的往返时间 (Round-Trip Time, RTT)。TCP 保留了 RTT 的一个**加权平均往返时间** RTTs, 它会随新测量 RTT 样本值的变化而变化。显然，超时计时器设置的超时重传时间 (Retransmission Time-Out, RTO)应**略大于** RTTs, 但也不能大太多，否则当报文段丢失时，TCP 不能很快重传，导致数据传输时延大。
##### 估计算法：
![[Pasted image 20240702111251.png]]

![[Pasted image 20240702111306.png]]

![[Pasted image 20240702111324.png]]

每当超时事件发生时，TCP 重传具有最小序号的还未被确认的报文段。只是每次 TCP 重传时都会将下一次的超时间隔设为先前值的两倍，而不是用从EstimatedRTT 和 DevRTT 推算出的值。因此，超时间隔在每次重传后会呈指数型增长。

每当定时器在另两个事件 (即收到上层应用的数据和收到 ACK)中的任意一个启动时，TimeoutInterval 由最近的EstimatedRTT 值与 DevRTT 值推算得到。
#### 冗余：
超时触发重传存在的一个问题是**超时周期往往太长**。所幸的是，发送方通常可在超时事件发生之前通过注意所谓的冗余 ACK 来较好地**检测丢包**情况。

冗余 ACK 就是再次确认某个报文段的 ACK,而发送方先前已经收到过该报文段的确认。TCP 规定当发送方收到对同一个报文段的 3 个冗余 ACK 时，就可以认为跟在这个被确认报文段之后的报文段已经丢失。就前面的例子而言，当 A 收到对于1号报文段的3个冗余 ACK 时，它可以认为2 号报文段已经丢失，这时发送方 A 可以立即对 2 号报文执行重传，这种技术通常称为快速重传。当然，冗余 ACK 还被用在**拥塞控制**中，这将在后面的内容中讨论。

### 连接管理：
连接：我们的两个**软件之间存在的**，人以为存在的连接，也就是我们的逻辑链接，不是在我们的物理上真的用一个线连接起来。也就是换句话说，我们**宏观上观察来说，两者之间的数据传输是无障碍地，任何时候都可 o (1)传输的**。

只能适用于**单播通信**，只能实现一对一的对话，不能实现一对多的对话或者说多对一的对话。

我们的每一个 TCP 连接都包括有三个阶段，连接建立，数据传送和连接释放。TCP 连接的管理就是使运输连接的建立和释放都能正常运行。

在 TCP 连接建立的过程中，要解决下面的三个问题：
1. 要使每一方能够确知对方的存在
2. 要运训双方协商一些参数
3. 能够实现对实体的资源进行分配

#### TCP 连接建立：

TCP 建立连接需要解决我们的三个问题，或者说，我们只要解决了下面的问题，我们就建立了我们的连接：
第一个：让双方都能够直到对方的存在（who）
第二个：允许双方协商一些参数（最大窗口值）
第三个：能够对于运输实体资源进行分配

TCP 的服务器建立采用我们的客户-服务器模式，主动发起连接的这一段叫做客户端 (client)，被动等待连接建立的应用进程叫做服务器（server）

TCP 建立连接的过程叫做握手：
我们的连接建立经过下面的三个步骤：也就是在我们的客户和服务端之间交换三个报文段，因而产生了 TCP 连接建立错误。

![[Pasted image 20240328151835.png]]
第一步：我们的客户机（client）的 TCP 首先向服务器发送报文段，这个特殊报文段的首部中的同步位置为 1. 同时选择一个初始序号 seq=x。这里我们的 seq 并不一定都是 1，因为我们这个时候我们可能还需要建立其他的段。Tcp 规定，SYN 报文段不能携带数据，但要消耗一个序号。这时，TCP 客户进程进入 `SYN-SENT` 状态。
![[Pasted image 20240531200008.png]]

第二步：服务器（server）的 TCP 收到连接请求字段后，如果同意建立连接，则向客户机发回确认，并为 tcp 连接分配缓存和变量。
**我们的服务器会存储我们的对应的五元组（源 IP，目的 IP，源端口，目的端口，服务协议**确定我们的一个流归属。

**Server 需要回复的信息如下：**
同时，我们需要**同意对方的请求，并请求和对方建立连接**。因此我们这个时候
在服务器（server）向客户机（client）发送的确认报文段中，把 SYN 位和 ACK 位（标志位）都置为 1，**期望收到的报文号**是 `ack=x+1`,同时也为自己选择一个初始序号  `seq=y`,
![[Pasted image 20240531195955.png]]
第三步：当客户端 (client)收到数据后，还要向服务器给出确认，并为该 tcp 连接分配缓存和变量，向应用层通知，此时，我们会向我们的 (server)发送，来告诉我们的服务端，我们的已经确认了。确定报文段的 ` ACK=1 `,确认好 ` seq=x+1 `, ` ack=y+1 `。这个时候我们就进入了我们的连接状态。

![[Pasted image 20240411145455.png]] 

### TCP 连接释放
**连接的释放可以从服务器开始，也可以从我们的服务端开始**。

第一步：我们的 A 的应用程序先向 TCP 发送连接释放报文段，并停止发送数据，主动关闭 TCP 连接。此时我们有 $FIN=1$,

![[Pasted image 20240411151103.png]]
A 把连接释放报文段的首部 FIN=1，其序号 seq=u，等待 B 的确认。
```
FIN=1,seq=u
```


第二步：在我们的 B 收到我们的消息后，我们的会发出一个确认的报文段，在确认之后，我们的 B 会同时把这一个信息提示我们 B 中的应用，这个时候，我们从 $A$ 到 $B$ 的连接就已经关闭了。

在我们的 B 向 A 发送的报文段中，我们就有：
```
ACK=1,ack=u+1,seq=v;
```

第三步：我们现在虽然关闭了 $A$ 到 $B$ 的连接，但是我们可能还有从 $B$ 到 $A$ 的连接，这个时候，我们要怎么处理？我们当然不能不处理，我们这个时候应该保持我们的 B 向我们的 A 发送数据。

在发送数据后，我们就会由我们的 $B$ 向 $A$ 通知，我们现在不发送数据了，对应的保卫段如下：
```
FIN=1,seq=w,ack=u+1,ACK=1
```

然后我们的 B 会借此来通知我们的对应程序。这个时候，我们有两种情况，第一种情况：我们的 B 没有意见，同意直接释放，此时，我们的 B 会发送：
```
FIN=1，ACK=1,ack=u+1
```

如果我们的 B 还有需要传输的数据，我们就先继续传输数据，然后我们
B 把连接释放的报文段的首部 ACK=1,

第四步：在我们的 A 收到消息后，我们仍然需要通知我们的 B，我们已经完成了接受，我们就需要向对方发送对应的报文段。
```
ACK=1,seq=u+1,ack=w+1
```

![[Pasted image 20240411151230.png]]



