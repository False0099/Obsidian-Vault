# **整数高位补 0，小数低位补 0**

## **注意定点小数和浮点小数的区别，纯小数起始位位符号位**


易错点：***反码取反是指对数字位取反，不改变符号位***
补码是不对称的，会多一个 $-2^n$
**补码的“+1”指在最低为+1 的二进制加法运算，不是加数值 1. 即如果含有小数部分，1 是夹在整体的最右边**

![[Pasted image 20230907130635.png]]

# 数据编码与表示
1. 计算机中的数据
	1. 整数、浮点数、字符、逻辑值
	2. 需要编码进行表示
2. 编码原则
	1. 使用少量简单的基本符号
	2. 一定的规则
	3. 表达大量的复杂的信息
3. 二进制码 0、1
	1. 符号个数最少，物理上易实现
	2. 与二值逻辑的真，假对应
	3. 表示数值数据运算规则简单

# 无符号数、有符号数
1. 无符号数就是不带有符号位的数，例如：一个 16 位 2 进制无符号数，表示范围为 0-65535
2. 有符号数指带符号位的数，最左边的位用作符号位，0 为正，1 为负，例如有符号数+00010001 00000000 表示为 0 x 0900, 有符号数-00010001 00000000 表示为 0 x 8900
3. 定点表示：数值范围优先，处理简单
	1. 机器中所有数据的小数点位置固定不变
	2. 不适用记号. 来表示小数点
	3. 定点数可以表示纯小数或纯整数
4. 浮点表示：数值范围很大，但处理过程复杂
5. 十进制表示
	1. 压缩 bcd
	2. 非压缩 bcd

# 定点表示
## 纯小数
$x_{0} x_{1}\dots x_{n}$

1. $x_{0}$ 表示数的符号，数值 0 正 1 负，其他表示量值
2. 小数点位于 $x_{0}与x_{1}$ 之间
3. 表示范围为 $0\leq|x|\leq 1-2^{-n}$

## 纯整数
$x_{0} x_{1}\dots x_{n}$

1. $x_{0}$ 表示数的符号，数值 0 正 1 负，其他表示量值
2. 小数点位于最低为 $x_{n}$ 的右边
3. 表示范围为 $0\leq|x|\leq2^{n}-1$

# 机器码表示（重要）
1. 在计算机中将数的符号位和数值为一起编码，可以方便数的运算操作
2. 为了区别有符号数和机器中把符号数字化的数，通常将前者称为真值，后者称为机器码、机器数。
3. 常用机器码包括
	1. **原码**
		1. 定点小数
			1. 定义
			2. [x]={x 1>x>=0
				    1-x=1+|x| 0>=x>-1 }
			3. X=+0.1001------》0.1001
			    X=-0.1001------》1.1001

		 2. 定点整数
			 1. 定义
			 2. [ x  ]={x            2^n>x>=0}
					  {2^n-x    0>=x>-2^n}
			3. X=**+** 0111001------>**0** 0111001
			    X=**-** 0111001------>**1** 0111001
		 3. 对应真值：
			 **第一位表示符号，不参与数位的计算**，剩下的按照我们的二进制转化为十进制后，再添加符号即可。
			 
		优点：表达简单
		缺点：计算复杂
	2. 补码（在同余意义下）
		1. 定点分数
			1. 定义
				$x_{补}=x  (1>x\geq 0)$
				$x_{补}=2+x(0\geq x\geq-1)$
			 2. 举例
				 1. X=+0.1011------>0.1011
				 2. X=-0.1011------>1.0101 (按位取反再加一)
		2. 定点整数
			1. 定义
				$x_{补}=x  (2^n>x\geq 0)$
				$x_{补}=2+x(0\geq x\geq-2^n)$
			2. 举例
				1. X=+0111001------>0 0111001
				2. X=-0111001------>11000111（除符号位外按位取反再加 1---》补码等于反码+1）
			3. 对应真值：
				**第一位权值取为-1，其他位都取 1**, 最后相加的结果就是我们的实际数。![[Pasted image 20230906093058.png]]
	3. 反码
		1. 定点分数
			1. 定义
				$x_{反}=x(1\geq x\geq 0)$
				$x_{反}=(2-2^n)+x 0\geq x>-1$
			2. 举例
				X=+0.1011------>0.1011
				X=-0.1011------>1.0100 (除符号位外按位取反)
			3. 反码对应真值：

	4. 移码
		1. 定点分数
			1. 定义
				1. 移码就是将每一个数值加上一个偏移值 bias，通常为 n 位二进制整数
				$x_{移}=x+2^n-1 (-2^{n-1}\leq x<2^{n-1})$
				$x_{移}=$
			2. 举例 (假设移码为 4 位)
				X=-7------->[x]=1---->0001;
				X=+5------>[x]=5+8------>1101
				(移码和补码尾数相同，符号位相反)
		**1. 补码、移码中 0 的值唯一，原码中 0 的值不唯一，反码中 0 的值也不唯一
		2. 若 x 为正数，则原、反、补都相同
		3. 最高位为符号位
		4. 移码与补码尾码相同。符号位相反
		5. 补码、反码、移码的符号位在加减运算时视为数值，而原码的符号位必须单独处理
	 Eg. 假定机器字长 16 位，定点表示，尾数 15 位，数字符号 1 位，问：
	 （1）定点原码整数表示时，最大整数、最小负数各是多少？
	 （2）定点原码小数表示时，最大整数、最小负数各是多少？
```
定点源码表示最大整数：0111 1111 1111 1111
定点源码表示最小整数：1111 1111 1111 1111

定点原码表示最大小数： 0111 1111 1111 1111
定点原码表示最小小数： 1111 1111 1111 1111
```

**64 位现代计算机中，有符号数都是用补码表示的

题型一：**给定十进制数，求对应的补码、移码、反码、原码**
1. 先用带符号的形式表示我们的数字 A
$(-127)=-(0111111)_{2},-1=-(0000001)_{2},0=(0000000)_{2}$
$(1)=+(0000001)_{2},+127=+(0111111)_{2}$

2. 对于原码：如果是有符号的，我们就把最高位变成我们的 1，如果没有符号，我们的最高位就为 0
$(-127)=(1111111)_{2},-1=(1000001)_{2},0=(0000000)_{2}$
$(1)=(0000001),127=(01111111)_{2}$

3. 对于反码：如果是有负号的，我们就把**除符号位外**的每一位按位取反，如果没有负号，我们不变，仍然等于初始值
$(-127)=(1000000)_{2},-1=(1111110)_{2},0=(0000000)_{2}$
$(1)=(0000001)_{2},127=(01111111)_{2}$

4. 对于补码：如果是有负号的，我们就在反码的基础上+1，如果是没有负号的，我们就不变，仍然等于初始值。（**除符号位外，按位取反再+1**）
$(-127)=(1000001)_{2},-1=(1111111)_{2},0=(0000000)_{2}$
$(1)=(0000001)_{2},127=(01111111)_{2}$

5. 对于移码：我们只需要在补码的基础上，让符号位反过来即可，无论是整数还是负数
$(-127)=(0000001)_{2},-1=(0111111)_{2},0=(1000000)_{2}$
$(1)=(1000001)_{2},127=(11111111)_{2}$

题型二：求每一个数所能表示的**最大正数，最小负数**，最小整数，最大负数（**贪心+数值计算**）

对于定点**原码**：我们**贪心的让除了符号位外的所有位置都为 1**，因此能表示的最大正数为 $(0111111)$,最大负数为 $(1111111)$,在原码运算规则下，我们能表示的就是+32676，-32676
对于定点**补码**：对于最大负数，**我们贪心的让符号位为 1，其他位全为 0，就能得到我们的最大负数**，-32678。对于最大整数，**我们让符号位位 0，其他位贪心的全为 1**，就能得到我们的最大整数 32677

（新规则，不是 IEEE 格式）对于由 S, E, M 三个域组成的一个 32 位二进制数所表示的非 0 规格化浮点数 x，真值表示为 x= $(-1)^s*(1.M)*2^{E-128}$。于是我们就可以用**贪心的思路**，**最大正数就是符号位位 0，其他位全为 1**，
![[Pasted image 20230906093626.png]]

**最小正数**，就是符号位位 0，小数位全为 0，指数为全为 0
![[Pasted image 20230906093706.png]]

最小负数，就是符号位位 1，其他位全为 1

![[Pasted image 20230906093742.png]]
最大负数，就是符号位为 1，其他位全为 0
![[Pasted image 20230906093829.png]]

# 纯小数的表示方法
纯小数即只存在小数点后面的值。
## 纯小数的进制表示 ：
$0000\to 0$
$0100\to 0.5$
$0010\to \frac{1}{4}$
$0001\to \frac{1}{8}$
在**原码**中：我们从左往右数**第一位为符号位**，接着后面的位置以此为 $2^{-1},2^{-2},\dots 2^{-n}$。

在**补码**中：我们的从左往右数每一位都是一个权值，第一位表示 $-2^0$,剩下的都是正的 $2^k$。

纯小数原码和补码的转换：同样的，**除符号位外按位取反再加一即可**。

# 十进制数表示方法
1. 字符串形式
	1. 一个子节存放以恶搞十进制的数或符号位
2. 压缩的十进制数：一个子节存放两个十进制的数位
	1. 用四位二进制表示一位十进制，16 个编码状态选用其中的 10 个编码
	2. 多种方案：
		1. 8421 码
		2. 余 3 码
		3. 循环码


# 浮点数的表示方法（IEEE 754）
第一步，我们把原来的小数转变为形如 $\pm(1.x)*2^M$ 的形式，然后我们在所有的数位中，用一位来表示**符号**，一位来表示我们 $(1.x)$ 中的**小数部分（M）**，32 位计算机中有 $23$ 位，64 位计算机中有 52 位，另外用若干位来表示 2^M 中的**指数（E）**，32 位计算器中有 8 位，64 位浮点数中有 11 位。

其中，我们的指数部分采用移码方式存储，32 位浮点数中，移码改变的固定常数量为 $127=2^7$，同时我们的移码量应该由我们的实际值+127 来表示。

我们把浮点数转化为十进制数，我么应采用下面的公式
![[Pasted image 20230906085307.png]]


一些规定：
若 E=255 (指数，M<>0（小数）），则 N=NAN（无定义数据）
若 E=255（指数），M=0（小数），则 N= $\pm\infty$
若 0<E<255（指数）, 则 N= $(-1)^s*(1.M)*2^{E-127}$
若 E=0（指数）, M=0（小数），则 N=0
若 E=0（指数），且 M<>0, 则 N= $(-1)^s*(0.m)*2^{-126}$（非规格书）


EG:
![[Pasted image 20230906090720.png]]

![[Pasted image 20230906090906.png]]



# 字符型数据的表示
1. ASCILL 码
	2. 大小写字母、数字、专用符号、控制字符
	3. 每个字符用 7 位二进制数表示，可以表示 128 个字符。在计算机内部用 1 个子节表示一个符号，最高位位 0，或用作奇偶校验位。
2. Unicode 码或 ISO 10646
	1. 统一码，表示多种语言文字
	2. 规划的码空间是 17 个平面，0 x 0000 至 0 x 10 FFFF, 每个平面中有 65536 个编码
		1. 平面 2 的 43253 个字符都是汉字
		2. 平面 0 上定义了 27973 个汉字
	3. UTF 是 Unicode 字符集转换格式，是一种存储和传送的格式。可理解为 U nicode 的压缩形式，UTF 格式包括 UTF-8，UTF-14，UTF-32
	4. UTF-8 是一种变长字符编码，1-4 个子节

# 校验码
1. 在数据存储、传输过程中，附加数据可能会出错，我们就可以通过校验码来是的我们最后读出的数据是正确的。
2. 原理
3. 分类
	1. 检错码
		1. 奇偶校验 (只能检验奇数个错误，无法检验偶数个错误)
			1. 加上检验位后，传输的位组中，“1”的个数一定为奇数（奇校验）或偶数（偶校验），否则就发生了错误
			2. 校验位计算 C= $x_{0}\oplus x_{1}\dots.\oplus x_{n-1}$
		2. 海明码
			
		3. 循环冗余校验码
	2. 纠错码
		1. 海明码
		2. BCH 码
		3. RS 码
# 数据在存储器中的表示
1. 按字节寻址的存储器可以视为一个很大的字节数组，数组下标为存储器地址，数组元素的值即为存储器存储的内容
2. 连续存放的 32 位或 64 位的字数据的地址差值为 4 或 8

3. 大端模式
	1. 低字节存放在大地址处，即高字节在前，低字节在后
	2. SPARC、IBM 
4. 小段方式
	1. 低字节放在小地址，即低字节在前，高字节在后
	2. X 86




# 位扩展、位截断、移位操作

1. 位扩展
	1. 将 n 位有符号的整数转换为 n+k 位，并保持值不变
Eg: 已知在 C 语言中，int 占 32 位，short 占 16 位，若有下列语句
```cpp
unsigned short x=65530;
unsigned int y=x;
```
则执行后 y 的十六进制表示为（B）

A 0000 7 FFA
B 0000 FFFA
C FFFF 7 FFA
D FFFF FFFA

```
unsigned为无符号，65530直接的就是FFFA，表示数值，从short变为 int是，同时还是无符号，我们前面直接填0即可，所以答案为B
```

2. 截断
	1. 给定 k+w 为的有符号或无符号整数 X
	2. 将其转换为 w 位整数 X'，且对于“足够小”X 而言，截断后的值保持不变
	3. 规则
		1. 删除前 k 位
		2. X'= $x_{w_{1}},x_{w-2},\dots,x_{0}$
3. 移位操作
**补码**左移移位：**无论正负，都是带符号位整体左移一位，空位补 0**，就算有移除我们也要这么移位，进行向左移位后，我们得到的正数数字是原来的数的两倍。对于负数而言，我们对我们的补码左移一位（不考虑符号），我们得到的仍然是正确的

**补码**右移移位：**带符号为整体右移一位，正数右移，最左侧补 0，负数右移，最左侧补 1**，右移 n 位相当于/2^n

无符号右移：**带符号整体右移一位，都补充 0**
对于补码：
	1. 机器中的移位是一种运算
		1. 左移一位绝对值扩大，×2
		2. 右移一位绝对值缩小，/2
	2. 计算机中，移位与加减结合，能够实现乘除运算
	3. 逻辑移位
		1. 左移时，高位移除，低位补 0
		2. 右移时，低位移除，高位补 0
	4. 算数移位（ 数字绝对值* 2）（有符号数移位）
		1. 左移时，高位移除，低位补 0（负数反码补 1）
		2. 右移时
			1. 原码：符号位固定不变，右移空出的数值位补 0
			2. 补码和反码：符号位固定不变，右移空出的数值位**补符号位**。
Eg. 机器字长 8 位，x=-20, 对其进行左移位和右移位，结果如下
$x_{原}=1001 0100$ 
左移 00101000（高位移除，原码左移补 0）+40
右移 10001010（符号位不动，原码右移补 0）-10
$x_{补}$ = 11101100
左移: $x_{补}=11011000$ $x_{原}=10101000$ (高位移除，补码左移补 0) -40
右移: $x_{补}=11110110$ $x_{原}=10001010$（符号位不懂，补码右移补符号位）-10
$x_{反}$ = 11101011
左移: $x_{补}=11010111$ $x_{原}=10101000$ (高位移除，负数反码左移补 1) -40
右移: $x_{补}=11110101$ $x_{原}=10001010$（符号位不懂，补码右移补符号位）-10

# 定点加法、减法

1. 补码加法公式 （**补码加法等价于数据直接进行加减**）
	1. 整数 $x_{补}+y_{补}=(x+y)_{补}$
	2. 补码加法：符号位要作为数的一部分参与运算，最后的结果对最高位取模。
 ![[Pasted image 20230906094643.png]]
 ![[Pasted image 20230906094658.png]]

1. 补码减法公式
	1.  $x_{补}-y_{补}=(x-y)_{补}=x_{补}+(-y)_{补}$
		1. 我们只需要证明 $-y_{补}=(-y)_{补}$
		2. $(-y)_{补}$ 我们可以通过对已知的 y 的补码，各位求反且末尾加 1 得到
补码正负转换：
1. 正->负
我们直接对原来的正数按位取反再加 1，就能得到我们负数的对应补码
2. 负->正
我们对原来的负数补码直接按位取反再加 1，就能得到我们对应相反数的补码

**负数减负数时，两个都要变成补码，然后再相加**
![[Pasted image 20230906095330.png]]

eg: $x_{1}=-0.1110,x_{2}=0.1101$,求 $x_{1补}，(-x_{1})_{补}，x_{2补},(-x_{2})_{补}$
```
x1补=1(符号位).0010(按位取反+1)
-x1补=0.1110(整体按位取反+1）
x2补=0.1101
-x2补=1.0011(整体按位取反+1);

```

**因为有取模操作，所以最后可能会有数据的溢出（正+正=负，负+负=正）

# 溢出
1. 无论是定点小数还是定点整数，在运算过程中会出现超过机器表示范围的现象，称之为移除
2. 有符号整数加法运算
	1. 正溢出：两个整数相加为负数
![[Pasted image 20230906095633.png]]
	1. 负溢出：两个复数相加结果为整数
![[Pasted image 20230906095641.png]]


1. 检测方法 
方法一：双符号位（变形补码，我们改变我们的模，使我们的符号位有两位，只有**两个符号位都是相同值时，我们才得到一个正确的数字**，两个符号位都是-1，我们是负数，两个符号位都是 0，我们是正数。）
	小数 $[x]_{补}=x (2>x\geq 0)$ $x_{补}=4+x (0>x\geq-2)$
    整数 $[x]_{补}=2^{n+2}+x$

双符号位下，补码加法规则仍然成立，双符号位依然要参与运算，同时 00 代表正，11 代表负，出现 01 表示出现**正溢出**，出现 10 表示出现**负溢出**

**无论我们是否出现溢出，我们的最高位，始终指示正确的符号**

![[Pasted image 20230906095934.png]]
	
  
  
  
单符号位法
		 V= $C_{f} \oplus C_{0}$ 
		$C_{f}$ 是符号位产生的进位，$C_{0}$ 是最高有效位产生的进位
	
Eg: 某字长为 8 位的计算机中，已知整型变量 x, y 的机器数分别为 $[x]_{补}=1111 0100,[y]_{补}=10110000$，若整型变量 z=2×x+y/2, 则 z 的机器数为（A）
A 1100 0000
B 0010 0100
C 1010 1010
D 溢出
```
首先，我们要知道，对于×2，就相当于左移，在这里对于补码左移，就是符号位不动，剩下的左移补零
对于/2，就相当于右移，在这里对于补码右移，就是符号位不动，剩下的右移补符号位
```

Eg 2: 若 x=103, y=-25, 则下列表达式采用 8 位定点补码运算实现时，会发生溢出的是 (C)
A x+y
B -x+y
C x-y
D -x-y
```
我们直接进行数值计算，在判断数值是否超过8位定点补码所能表示的范围即可。
```

![[Pasted image 20230907165958.png]]

![[Pasted image 20230907170803.png]]