1. 十进制代码
为了用二进制表示 0-9 这 10 个数字，我们需要至少 4 个二进制位。4 个二进制位可以表示 16 个对应的方案。我们于是就有 8421 码（BCD 码），余 3 码，2421 码，5211 码，余 3 循环码

8421 码：
按照**原始的大小来规定我们的权值**，是最常用的一种方法。标题中的 8421，代表从高到低每一个数字所代表的权值。与之相似的还有 2421 码（互为反码），5211 码（分频计时方便）。

余 3 码（用 **3-12 表示 0-9**）：
如果我们把一个余三码看作 4 位二进制数，那么他的数值要比他所表示的十进制数码多 3，所以我们叫做余 3码。
在使用余三码相加时，所得的和比十进制数所对应的二进制多 6，因此，在使用余三码进行十进制加法时，若两数之和位 10，正好等于二进制的 16，从而从高位自动产生进位信号。此外，我们还可以看出，0 与 9，1 和 8，2 和 7 的余三码互为反码，这对于求对 10 的补码时很方便的。
![[Pasted image 20230907171259.png]]
## 格雷码
我们的格雷码又称为循环码，从 0000 开始，最**右边一位的黄台按照 0110 顺序循环变化**，右边**第二位的状态按照 00111100 循环变换**，右边第三位按照 0000111111110000 顺序循环变化......

与普通的二进制代码相比，我们的格雷码相邻两个数字之间只有最多一个数字发生变化。

格雷码的编写：![[Pasted image 20230831142557.png]]
```cpp
class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> list =new ArrayList<Integer>();
        list.add(0);
        int temp=1;
        //后一个在前一个的基础上，前半部分+0；后半部分+1镜像对称
        for(int i=0;i<n;i++){
            for(int j=list.size()-1;j>=0;j--){
                list.add(temp+list.get(j));
            }
            temp<<=1;//左移一位
        }
        return list;
    }
}
```

**二进制码与格雷码的转换**：从最右边开始，**依次将每一位与左边一位异或**，最左边不变 ![[Pasted image 20230907171739.png]]

ASCILL 码
ASCILL 码是用来计算表示我们字符的一个标准，一共只有 1 个 byte-》8 个 bit

例题：
注意：1.余三循环=**格雷码+余三码**
2. 在进行余三码是，我们要**把十位分开来看，分别表示**
![[Pasted image 20230907172140.png]]
![[Pasted image 20230907172848.png]]