## DIJ
![[Pasted image 20231219172202.png]]
Step0：初始化，`D[i]` 为源点 V0到 Vi 的边长。
![[Pasted image 20231219172151.png]]

Step 1: 选择当前的最短路径，将我们的对应结点加入到我们的 `vis` 数组。
![[Pasted image 20231219172236.png]]

Step 2: 由我们的 $v_{2}$，更新我们的所有值。
![[Pasted image 20231219172325.png]]
以此类推，直到我们的所有点都被我们加入到我们的最短路当中。

## FLoyd 算法
问题的提法：已知一个各边权值均大于0的带权有向图，对每一对顶点 vi ¹ vj，要求求出 vi 与 vj 之间的最短路径和最短路径长度。

Floyd算法的基本思想：

定义一个n阶方阵序列： D(-1), D(0),  …, D(n-1).

其中: `D(-1) [i][j] = Edge[i][j]`；

              D(k) [i][j] = min { D(k-1)[i][j]，D(k-1)[i][k] + D(k-1)[k][j] },

                                         k = 0,1,…, n-1

     D(0) [i][j]是从顶点vi 到vj , 中间顶点是v0的最短路径的长度,  D(k) [i][j]是从顶点vi 到vj ,  中间顶点的序号不大于k的最短路径的长度, D(n-1)[i][j]是从顶点vi 到vj 的最短路径长度。

最短路径的表示：为了能记录路径，采用 n 个 PathMatrix 类型的矩阵 P，表示每个顶点到其余顶点的最短路径

运行过程：
![[Pasted image 20231219172510.png]]
手算的快速思路：我们第几次运行，就找到第几行和第几列，然后我们对应的找到两个相接的地方，然后比较这个地方和我们的对应行列之间的和的大小关系。[[闭包求法]]

![[Pasted image 20231219172743.png]]