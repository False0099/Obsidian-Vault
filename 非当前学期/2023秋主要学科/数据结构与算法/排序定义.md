重点：
**冒泡，快排，稳定排序**
## 插入排序
我们的操作就是把我们的无序序列中的数字插入到我们的一个有序的排列当中的对应位置。
优化：我们通过我们的二分找到我们最后一个比当前数字小的位置，然后我们插入到这个位置即可。
```cpp
for(int i=0;i<n;i++){
	for(int j=0;j<i;j++){
		if(a[i]<a[j]){
			swap(a[i],a[j]);
		}
	}
}
```

优化：我们采用**二路插入**（了解），动态开点，先找顶一个基准值，如果比我们基准值大的，我们就放到右边，如果比基准值小的，我们就放左边，每一次我们的位置通过二分确定。

优化：希尔排序，第一次我们比较 $a[i],a[i+dt]$ ，依次类推，知道我们最后选择到了 $a[i],a[i+1]$

```
void ShellInsert ( SqList &L，int dk)  
{  
　for ( i=dk+1; i<=L.length; ++i )　　if ( L.r[i].key < L.r[i-dk].key ) {  
　　　L.r[0] = L.r[i];
　　　  L.r[i]=L.r[i-dk];  
　　　for ( j=i-2*dk; j>0 && L.r[0].key < L.r[j].key; j-=dk )　　　　　L.r[j+dk] = L.r[j]; 　

                 L.r[j+dk] = L.r[0]; 　　　　　　　　   } // if} // ShellInsert  

void ShellSort (SqList &L, int dlta[], int t)　{  
　　// 按增量序列 dlta[0..t-1] 对顺序表L作希尔排序　　for (k=0; k<t; ++k)　　　ShellInsert(L, dlta[k]); // 一趟增量为 dlta[k] 的插入排序　} // ShellSort
```


## 冒泡排序
我们每一次就比较我们的相邻的两个，如果大小有差距，我们就直接交换，重复这个操作 n 次。

改进：快速排序，先从我们的序列中找到一个基准数，然后我们把我们的数字按照比这个数字大的放到一边，比这个数字小的放到另一边。这里我们一般会选取我们数列第一个数。

## 选择排序
即通过 n-i 次关键字间的比较，从 n-i+1个记录中选出关键字最小的记录并和第 i 个记录交换。也就是每一次选择我们的最大值，次大，...

我们的堆也就是用这种思路来进行排序的。

## 归并排序
v 归并排序是将两个或两个以上的有序表组合成一个新的有序表。
2-路归并排序的时间复杂度为 O(nlogn)

## 基数排序
根据我们的某一位是多少，决定我们的位置是多少，也就是我们的桶排序

|  |  |  |  |  |
| ---- | ---- | ---- | ---- | ---- |
| 排序方法 | 平均时间 | 最坏情况 | 辅助存储 | 稳定性 |
| 简单排序 | O(nn) | O(nn) | O(1) | √ |
| 快速排序 | O(nlogn) | O(nn) | O(logn) | × |
| 堆排序 | O(nlogn) | O(nlogn) | O(1) | × |
| 归并排序 | O(nlogn) | O(nlogn) | O(n) | √ |
| 基数排序 | O(d(n+rd)) | O(d(n+rd)) | O(rd) | √ |
|  |  |  |  |  |

