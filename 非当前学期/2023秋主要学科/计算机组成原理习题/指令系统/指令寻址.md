上一篇：[[非当前学期/2023秋主要学科/计算机组成原理习题/指令系统/指令格式]]
下一篇：[[非当前学期/2023秋主要学科/计算机组成原理/指令系统/指令格式|指令格式]]
各种操作优劣比较：
![[Pasted image 20231123114239.png]]
## 定义
![[Pasted image 20231224195635.png]]
1. B（只有这一个，其他的都是瞎说）
![[Pasted image 20231224195706.png]]
2. A 无条件转移指令，也就是实现我们的程序计数器，这个时候，我们的操作应该是把我们的对应的地址放到我们的程序计数器当中去。所以我们这一题应该选择我们的 A
![[Pasted image 20231224195810.png]]
3. D 这里，我们虽然上面三个都能够缩短我们的地址，但我们最能缩短的，一定是我们的寄存器寻址，因为我们寄存器的数量一般都很少。
![[Pasted image 20231224200033.png]]
04. B 我们想要简化我们的地址结构，我们最好的方法就是没有我们的地址，所以我们的 B 隐地址显然是符合我们的要求的一个选项。
![[Pasted image 20231224200247.png]]
05、B 获取操作数做快的，显然是我们的直接寻址，找到什么就是什么（直接寻址和立即寻址：见上）
![[Pasted image 20231224200348.png]]
06. A 我们如果给定的是有效地址，也就是我们的 EA，那么显然，这个就是我们的直接寻址（A）
![[Pasted image 20231224200441.png]]
07. B 变址寻址的意思就是：我们由我们的 A+（X），也就是我们的地址吗+变址寄存器当中的内容。间接寻址：也就是我们的 (X)+A 只是我们的指针，我们要找到真正的数据，还要再取一次地址。所以我们选 B
![[Pasted image 20231224200715.png]]
08. B 变址寻址，也就是我们的寄存器数据可以改变，因此，我们用我们的变址寻址可以很好的找到我们的数组和相关的数据。
![[Pasted image 20231224201008.png]]
10. D 因为我们相对寻址中，要把我们的数据和我们的 PC 相加，所以我们就指向了我们下一条地址的便宜量，而不是我们的当前地址。
![[Pasted image 20231224201100.png]]
11. A 多道程序设计中，相对寻址便于我们的地址浮动

![[Pasted image 20231224201154.png]]
12. C（程序浮动主要依靠我们的相对寻址，条件浮动也是如此，而我们的程序调用其实也主要以来我们的堆栈指针。）
![[Pasted image 20231224201636.png]]
14. B 按字寻址的机器，我们的 PC 位数，取决于我们的指令的地址，也就是我们的地址线的宽度，而我们指令寄存器，也就是取决于我们的指令的长度，
![[Pasted image 20231224204708.png]]
18. D（正确原因已经叙述，这里不再多说）
![[Pasted image 20231224204934.png]]
A：不一定
![[Pasted image 20231224211307.png]]
D 
## 具体操作
![[Pasted image 20231224200818.png]]
9. B 我们在这里，我们如果想要出栈，那么我们的操作应该是：先移动我们的栈顶指针，然后再移动我们的栈底指针。
![[Pasted image 20231224202944.png]]
15. D 如果我们想要我们的操作数（**数值**）位 200，也就是说我们要用我们的寄存器间接寻址，得到的
## 计算
![[Pasted image 20231224201256.png]]

13. C 取指令后，我们的 PC 指向的一定是下一条指令，因为我们执行的是我们的相对寻址无条件转移，所以我们这个时候最后推出还会把我们的 EA 给加上
![[Pasted image 20231224203059.png]]
16. A 我们这一题因为我们的第一个操作数采用的是寄存器间接寻址方式，也就是说，我们先找到我们的寄存器，寄存器中的内容是我们的一个 EA，我们再拿这个地址去得到真正的数据。
![[Pasted image 20231224204152.png]]
17. C, D我们如果想要完成我们的操作，我们的第一点就是
![[Pasted image 20231224204751.png]]
19. C 因为我们去一个字节就会地址++，并且我们读取了两个字节，然后我们还便宜连 06，所以我们是+6. 
![[Pasted image 20231224210314.png]]
21. C 我们这一题假设两个无符号整数 A, B，bgt 会将两者进行比较，也就是 A 和 B 相减，若 A》B，则 A-B 肯定无进位，也不为 0，所以 CF 和 ZF 均为 0）
![[Pasted image 20231224210433.png]]
23. A 
![[Pasted image 20231123115139.png]] 

![[Pasted image 20231224210512.png]]
24 C
![[Pasted image 20231224212600.png]]
28. 
![[Pasted image 20231123110941.png]]

![[Pasted image 20231123110950.png]]

28. A 
![[Pasted image 20231123115203.png]]
## 大题
![[Pasted image 20240102193617.png]]
1. 采用我们的寄存器寻址的时候，我们的指令码长度显然是最短的，采用我们的直接寻址的之后显然我们的指令码长度是最长的
2. 采用我们的寄存器寻址显然是执行速度最快的，采用我们的间接寻址的时候显然我们的执行速度是最慢的。
3. 如果我们采用定长指令码的时候，所有的指令所包含的二进制数均相同，所以我们的立即寻址方式是最快的。
![[Pasted image 20240102193949.png]]
02. 
1）因为我们是固定操作数，所以我们总共的操作数就是我们的操作码的幂次，就是 $2^5=32$ 条
![[Pasted image 20240102194430.png]]

![[Pasted image 20240102193957.png]]
(直接寻址：EA=A)，（立即寻址：ans=A），（间接寻址：EA=(A））, (相对寻址：EA=(pc)+A)，（变址寻址：EA=（XR）+A），（寄存器 R 1 寻址，EA=R 1），（寄存器间接寻址，EA=(R 1））
![[Pasted image 20240102194746.png]]

![[Pasted image 20240102194027.png]]

![[Pasted image 20240102195225.png]]

![[Pasted image 20240102194036.png]]
![[Pasted image 20240102195250.png]]



![[Pasted image 20240102194048.png]]
![[Pasted image 20240102195330.png]]
![[Pasted image 20240102194059.png]]

![[Pasted image 20240102200204.png]]
![[Pasted image 20240102200221.png]]


![[Pasted image 20240102194114.png]]

![[Pasted image 20240102200236.png]]
![[Pasted image 20240102200306.png]]

![[Pasted image 20240102200323.png]]