上一篇：[[Cache替换]]
下一篇：[[Cache映射]]
## 公式
![[Pasted image 20240101172820.png]]

## 概念
![[Pasted image 20240101155356.png]]
02. C **主存向 CPU 传送信息的单位是字**，主存**向 Cache 写入的单位是块**
![[Pasted image 20240101155403.png]]
03. **D**，（写回法：我们命中之后，设置一个藏位，用来表示这个位置已经被修改过，等到完成后再统一返回我们的家中。全写法：我们命中之后，我们每一次如果有修改，就对我们的主存和 Cache 同时进行修改。分配法：不命中时，我们直接从主存中把对应的数据调用过来再直接修改）
![[Pasted image 20240101155427.png]]
06. C（LRU 算法根据程序访问局部性原理选择近期使用的最少的存储块作为我们的替换的块）
![[Pasted image 20240101155507.png]]
10. C
![[Pasted image 20240101155650.png]]

![[Pasted image 20240101155740.png]]

## 计算
![[Pasted image 20240101155349.png]]
01. **B**（A 为干扰项。各层次的存储系统不是孤立工作的，三级结构的存储系统是围绕主存储器来组织、管理和调度的存储器系统，它们既是一个整体，又要遵循系统运行的原理，其中包括包含性原则。由于 Cache 中存放的是主存中某一部分信息的副本，所以不能认为总容量为两个层次容量的简单相加。）
![[Pasted image 20240101155412.png]]
04. A LRU 表如下： 可见页面失效率是 6/20 =30%。(LRU: 最近最少使用，
操作：
第一步：我们数据进来，如果空间没有满，我们就进入我们的 LRU 表，记为不命中
第二步：如果我们数据已满，并且我们的新数据是我们之前访问过的数据，我们就把这个对应数据的位置提前
第三步：如果我们的数据已满，并且我们的新数据是我们之前没有访问过的数据，我们就从我们的所有数据中，出现次数最小，并且放入时间最早的那一个移动出去
![[Pasted image 20240101160735.png]]

![[Pasted image 20240101155420.png]]
05. C 因为 Cache 容量为 16 KB $=2^{14}$ B, 所以 Cache 地址长 14 位 (选项都为 14 位，即隐含了按字节编址)。主存与 Cache 地址映像采用直接映像方式，将 32 位的主存地址 Ox 1234 E 8 F 8 写成二进制，根据直接映射的地址结构可知，取低 14 位就是 **Cache 地址**。（区别 Cache 地址，Cache 块号，Cache 块内地址，我们的 Cache 地址=Cache 块号+Cache 块内地址）
Cache 地址=Cache 行号+块内地址
![[Pasted image 20240101172936.png]]
![[Pasted image 20240101155439.png]]
07. **D** 直接映射，也就是对于我们的 Cache 的 64 个块，我们每一个块都要存储我们的对应的主存容量会是多少，因此答案就是我们的 B（注意，我们还要**加上一个有效位**）
![[Pasted image 20240101173204.png]]
有效位：标志我们的这一块是否已经被占用，没有被占用
是否已经修改：回写法（脏位）
替换算法位：
![[Pasted image 20240101155446.png]]
08. C（相关术语：一个组有多少个块，我们就叫作多少路组相联）块大小为 16 B, 所以**块内地址字段为 4 位**；Cache 容量为 128 KB, 采用 8 路组相联，共有 $128$ KB $( 16$ B $\times 8) = 1024$ 组，**组号字段为 10 位**：剩下的为标记字段。1234567 H 转换为二进制数 **0001 0010 0011 01**00 0101 *0111*（）, 标记字段对应高 14 位，即 048DH。（**主存物理地址=标记+装载进入的组号+（具体哪一块不知道）块内地址**）
![[Pasted image 20240101173428.png]]
（组相联映射：先算出在哪一个组，然后在这个组里随机分配，在算出）

![[Pasted image 20240101155455.png]]
09. **A** （默认按字节编址）先写出**主存地址的二进制形式**，（我们按字节编址）然后分析 Cache 块内地址、Cache 字块地址和主存字块标记。主存地址的二进制数 0011 0101 0011 0000 0001, 根据直接映射的地址结构，**字块内地址为低 5 位** (每字块含 32 B, $2^5=32$,因此为 5 位), **主存字块标记为高 6 位** (1 MB/16 KB = 64, $2^6=$ 64, 因此为 6 位), 其余 010011000 即为 Cache **字块地址**，转换为十进制数 152。
![[Pasted image 20240101173500.png]]
![[Pasted image 20240101155514.png]]
11. **C**（对于**逻辑地址**，因为 $8=2^{3}$ 页，所以**表示页号的地址有 3 位**，又因为每页有 102 $4=2^{10}$ B, 所以**页内地址有 10 位**，因此逻辑地址共 13 位。对于物理地址；, 块内地址和页内地址一样有 10 位，内存至少有 32=2 $^{5}$ 个物理块，所以表示块号的地址至少有 5 位，因此物理地址至少有 15 位。）1024 B 就是我们需要对应的页内地址，

![[Pasted image 20240101155522.png]]
题解： 
D ![[Pasted image 20240101172144.png]]


![[Pasted image 20240101155530.png]]

![[Pasted image 20240101172250.png]]

![[Pasted image 20240101155539.png]]
$14.\:\mathbf{c}$ 一次缺失损失需要从主存读出一个主存块 (64 B), 每个总线事务读取 8 B, 因此需要 8 个总线事务。每个总线事务所用的时间为 1+8+1=10 个时钟周期，共需要 80 个时钟周期。
![[Pasted image 20240101155548.png]]
15. A![[Pasted image 20240101172355.png]]
![[Pasted image 20240101155624.png]]
17. C ![[Pasted image 20240101172409.png]]
![[Pasted image 20240101155636.png]]

![[Pasted image 20240101155732.png]]
20. C
![[Pasted image 20240101155749.png]]
22. A
![[Pasted image 20240101172451.png]]

![[Pasted image 20240101172606.png]]

## 大题
![[Pasted image 20240102110514.png]]
02. 采用我们的组相联方式，我们就有：
主存地址=标记位（21）+组号（5）+块内地址（6）

于是，我们的 Cache 总位数=块数* 块内数据，
我们的块内数据又由我们的标记位+有效位+脏位来实现一共就是 23bit，于是我们的 Cache 总位数就是我们的 $128*23bit$


（在这里，我们的 Cache 行大小指的是我们一个 Cache 行中的有效数据数量是多少）
![[Pasted image 20240102110752.png]]

![[Pasted image 20240102110956.png]]

![[Pasted image 20240102111100.png]]
![[Pasted image 20240102111604.png]]

![[Pasted image 20240102111109.png]]


![[Pasted image 20240102112853.png]]
![[Pasted image 20240102120751.png]]
![[Pasted image 20240102120804.png]]
![[Pasted image 20240102120810.png]]

![[Pasted image 20240102121641.png]]
![[Pasted image 20240102121858.png]]


![[Pasted image 20240102122025.png]]
![[Pasted image 20240102122038.png]]