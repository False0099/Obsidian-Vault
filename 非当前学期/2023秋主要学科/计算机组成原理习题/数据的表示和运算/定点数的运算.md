![[Pasted image 20231213112947.png]]
1. D
2. B
3. C (四个都会影响，但是我们的进位传递延迟影响最大，所以我们的选择是 C)
![[Pasted image 20231213113155.png]]
4. **B** ![[Pasted image 20231213113926.png]]
5. D
6. C
![[Pasted image 20231213113207.png]]
7. C
8. B（正数补码无论左移右移，我们的符号位都不变，我们的空位都补 0）
9. D（负数补码，右移补 1，左移补 0）
10. **C**不带进位位的循环左移将最高位移入最低为和标志寄存器 C 内
11. C（原码左移右移都是补 0 即可，且符号位不变，BAH= $10111010$,移位后变成 $11110100$ 和 $10011101$）
12. A (补码负数移位，我们左移补 0，右移补 1，我们的结果就是：)![[Pasted image 20231213114457.png]]
13. B（补码扩展的时候，我们的符号位也要跟着扩展，数值保持不变）
![[Pasted image 20231213113242.png]]
14. **C**
15. **B**
![[Pasted image 20231213131334.png]]
16. B
17. D ![[Pasted image 20231213131441.png]]
![[Pasted image 20231213113255.png]]
18. C (本题与 17 题类似，都考察我们的溢出方式)
19. B![[Pasted image 20231213131744.png]]
20. A
21. C（补码乘法不考虑）
22. B（这里的运算指的是我们的乘法运算，）
![[Pasted image 20231213113309.png]]
23. C
24. D (补码不考虑)
25. D![[Pasted image 20231213131957.png]]
26. B（补码不考虑）
![[Pasted image 20231213113321.png]]
27. D
28. D（小端序与大端序的例题）![[Pasted image 20231213132236.png]]
![[Pasted image 20231213113346.png]]
29. B（减法运算过程中，把我们的被减数直接用补码输入，减数用反码输入，sub 端输入 1，表示我们的按位取反后的加一）![[Pasted image 20231213133102.png]]
30. A![[Pasted image 20231213133513.png]]
31. C
32. D
![[Pasted image 20231213113359.png]]
33. B
34. D
35. B（无符号数填充后，我们的高位应该补充 0）
![[Pasted image 20231213113426.png]]
36. A![[Pasted image 20231213161024.png]]
37. C（我们这一题本质上还是在就是求我们的 8 位补码的表示范围）
38. D（![[Pasted image 20231213161201.png]]
![[Pasted image 20231213113522.png]]
39. A（小端模式详情参见我们的）
40. C
41. A
42. A
![[Pasted image 20231213113535.png]]
43. B
44. A
![[Pasted image 20231213113546.png]]
45. D
