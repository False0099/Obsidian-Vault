![[Pasted image 20231023151236.png]]
01. B（两种存储结构有好有坏，不能绝对，I 错误，链式存储用指针表示，有逻辑顺序，II 正确，在顺序存储中，插入和删除结点需要移动大量元素，效率低，III 错误，IV 正确）
2. B（快速删除，快速插入，显然可以用我们的链式结构（dancing links））
3. C（顺序存储即数组式存储，我们排序一定是 $o(n\log n)$,B 和 D 显然错误，）
4. D（I 树和图也能用我们顺序存储，错误，线性表采用顺序存储时 II 错误，III 时静态链表的特点，有序单链表只能依次查找插入位置，为 $o(n)$,队列要在表头删除元素，表尾插入元素，用带尾指针的方便）
![[Pasted image 20231023151915.png]]
5. A (对于 A，单链表和顺序表都是 $o(n)$,但是顺序表的**常数更大**，所以效率更高)
6. C（s 插入后，q 成为 s 的前驱，而 p 成为 s 的后继）
7. D（排序 $o(n\log n)$ +建表 $o(n)$,）
8. C ,遍历我们的 m 链表，找到我们的 m 链表尾部，然后我们再找我们的头部即可。 
9. C（插入、删除统一，不需要再判断是否在第一个元素之前插入或删除，空表和非空表也方便处理）

![[Pasted image 20231023152446.png]]

10. B (删除最后一个元素，我们还要去获得我们最后一个元素前面的元素地址是多少)
11. B, A（空表是这样的，两个都要满足）
12. C（删除最后一个 $o(m)$,尾节点没有后继，D 显然）
13. D（看看就行）

![[Pasted image 20231023153035.png]]

15. B (我们这一题为了保持我们有序，所以我们只需要求出我们第一个比该节点大的位置，然后我们再去在这个位置前插入即可)
16. D（插入删除都很方便，不是 A，随机访问和链表无关，不是 B,）
17. D (循环判空等价于头指针的 pri 和 ne 都指向自己)
18. A（末尾插入删除，类似于我们的栈？我们用单链表显然不合适，我们**需要多次修改相邻结点的指针**，于是我们就要最好采用我们的带头结点的双循环链表）
19. C

![[Pasted image 20231031160754.png]]
	   D.
20. C ，首先，因为我们要在最后一个元素后，所以我们最好有一个尾指针，并且我们找头节点是 $o(1)$ 的，很优。 (也就是我们的队列常用的操作)
21. C
22. B
23. D（对于一个空表，我们一定有 $head\to next=head$,因此，我们一定有 $head\to next\to next=head$,所以我们的长度可以为 0，如果长度位 1，那么我们就是常规操作）
24. D

![[Pasted image 20231031161436.png]]

25. D
26. D
