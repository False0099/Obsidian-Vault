下一步：[[归并排序]]

概念：
![[Pasted image 20231229155544.png]]
02. **A**由于这里的序列基本有序，使用直接插入排序算法的时间复杂度接近 $O(n)$,而使用其他算法的时间复杂度均大于 $O(n)$。
![[Pasted image 20231229155558.png]]
06. C 在直接插入排序中，**若待排序列中的最后一个元素应插入表中的第一个位置**，则前面的有序子序列中的所有元素都不在最终位置上。堆排序能够以 $\log n$ 的速度确定出我们第一大的元素，我们的冒泡排序能够以 $o(n)$ 的速度确定出我们的第一大的元素，哦我们的快速快婿，能够一次性确定 $k$ 组变量的位置（最差退化到冒泡排序）。
07. A（希尔排序只修改了我们的每一次的变化量）
![[Pasted image 20231229155604.png]]
09. C（对于判断排序类型，我们的思路是找我们一次确定了多少个有序的位置，选择排序会确定一个，快速排序会确定多个，冒泡排序确定最大的）（**判断排序类型**）
![[Pasted image 20231229155611.png]]
12. A（因为我们的希尔排序是由我们的直接插入排序来组成的，也就是我们先维护一个有序的数列，因此我们不一定是有序的）
13. C（希尔排序是一种插入排序）（希尔排序，快速排序，堆排序不稳定）
14. C（背诵）

![[Pasted image 20231229155617.png]]

15. B 每趟**冒泡和选择排序后，总会有一个元素被放置在最终位置上**。显然，这里{11,12}和{4,5} 所处的位置并不是最终位置，因此不可能是冒泡和选择排序。**2 路归并算法经过第二趟后应该是每 4 个元素有序**的，但 $\{11,12,13,7\}$ 并非有序，因此也不可能是 2 路归并排序。（判断排序类型：**根据我们有多少个已经在正确的位置上**）
16. D（折半插入排序与直接插入排序都将待插入元素插入前面的有序子表，区别是：确定当前记录在前面有序子表中的位置时，直接插入排序采用顺序查找法，而折半插入排序采用折半查找法。排序的总趟数取决于元素个数 $n$,两者都是 $n-1$ 趟。**元素的移动次数都取决于初始序列**，两者相同。使用辅助空间的数量也都是 $O(1)$。折半插入排序的比较次数与序列初态无关，为 $O(n\log_2n);$ 而直接插入排序的比较次数与序列初态有关，为 $O(n){\sim}O(n^2)$。）

![[Pasted image 20231229155624.png]]
18. A 希尔排序的思想是：先将待排元素序列分割成若干子序列 (由相隔某个“增量”的元素组成), 分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序 (增量足够小) 时，再对全体元素进行一次直接插入排序。

 
## 计算题：
![[Pasted image 20231229155635.png]]
01. B (直接插入排序在最坏的情况下要做 $n(n-1)/2$ 次关键字的比较，当 $n=5$ 时，关键字的比较次数为 10。注意本题不考虑与哨兵的比较。)
![[Pasted image 20231229155641.png]]
03. D, A (待排序表为反序时，直接插入排序需要进行 $n(n-1)/2$ 次比较 (从前往后依次需要比较 1,2,..., $n-1$ 次); 待排序表为正序时，只需进行 n-1 次比较。同样注意不考虑与哨兵的比较。)
![[Pasted image 20231229155649.png]]
05. B 首先，越接近正序的序列，比较次数应是越少的；而越接近逆序，比较次数越多。不难得出 A 选项 B 和 C 是比较接近正序的，然后分别判断两个序列的比较次数，以选项 B 为例：第一趟，插入 32，比较 1 次；第二趟，插入 46，比较 1 次；第三趟，插入 40，由于 40 比 46 小但比 32 大，所以比较 2 次；第四趟，插入 80, 比较 1 次；第五趟，插入 69, 比较 2 次...... 共比较 9 次。
![[Pasted image 20231229155655.png]] 08. B 这一题，我们的关键是找到了我们的 15 和 20 没有改变，因此，我们的增量就是我们的 B
![[Pasted image 20231229155703.png]]
10. A
11. C 虽然折半插入排序是对直接插入排序的改进，但它改进的只是比较的次数，而**移动次数**未发生变化，时间复杂度仍为 $O(n^2)$。（注：我们的插入排序=（找位置+移动元素），我们折半只能优化我们找位置，不能优化我们的移动元素部分）

![[Pasted image 20231229155712.png]]
17. B 
![[Pasted image 20231229155719.png]]
19. D（这里，我们的思路就是采用我们的主次增加的方法）