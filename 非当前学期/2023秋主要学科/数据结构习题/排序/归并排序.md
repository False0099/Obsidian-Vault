下一步：[[交换排序]]

## 概念
![[Pasted image 20231230163039.png]]
01. C (选择排序，堆排序就是隶属于我们的选择排序可以选出我们的最小的，冒泡排序就是我们的交换排序，)
02. C（基数排序是基于关键字的各位的大小来进行比较的）
![[Pasted image 20231230163048.png]]
03. D, C（归并排序算法在平均情况下和最坏情况下的空间复杂度都会达到 $O(n)$,快速排序只在最坏情况下才会达到 $O(n)$, 平均情况下为 $O(\log_2n)$。所以归并排序算法可视为本章所有算法中占用辅助空间最多的排序算法。）
04. B（前面已讲过**选择排序的比较次数与序列初始状态无关**，归并排序的比较次数的数量级也与序列的初始状态无关。读者应能从算法的原理方面来考虑为什么和初始状态无关。）
![[Pasted image 20231230163053.png]]
05. B 对于 $N$ 个元素进行 $k$ 路归并排序时，排序的趟数 $m$ 满足 $k^m=N$,所以 $m=\lceil\log_kN\rceil$, 本题中即为「log $_{2}n\rceil。$
![[Pasted image 20231230163118.png]]
09. D (采用基数排序是，我们有 4 个位，然后我们要进行 4 次排序，因此我们就可以有我们的 $o(n)$ 的排序)
![[Pasted image 20231230163144.png]]
12. D（外部排序一般采用我们的归并排序来进行）
![[Pasted image 20231230163152.png]]
13. B（归并排序代码比选择插入排序更复杂，前者的空间复杂度是 $O(n)$,后者的是 $O(1)$。但前者的 时间复杂度是 $O( n$ logn) $, 后者的是$ O (n^2)$。所以选项 B 正确。）
 
## 操作
![[Pasted image 20231230163106.png]]
06. B（我们根据我们的第 5 题的公式，可以得到，我们归并的路数最少就是我们的 3 路）
07. A, B（注意到当一个表中的最小元素比另一个表中的最大元素还大时，比较的次数是最少的，仅比较 $N$ 次；而当两个表中的元素依次间隔地比较时，即 $a_1<b_1<a_2<b_2<...<a_n<b_n$ 时，比较的次数就是哦我们的 2 N-1）
08. B (由于这里采用 2 路归并排序算法，而且是第二趟排序，因此每 4 个元素放在一起归并，可将序列划分为{25,50,15,35},\{80,85,20,40\}和{36,70}, 分别对它们进行排序后有{15,25,35,50}, $\{20,40,80,85\}$ 和{36,70}, 故选择选项 B。) 
![[Pasted image 20231230163131.png]]

![[Pasted image 20231230163216.png]]

10. C 基数排序有 MSD 和 LSD 两种，且基数排序是稳定的。对于选项 A, 不符合 LSD 和 MSD;对于选项 B, 符合 MSD, 但关键字 42、46 的相对位置发生了变化；对于选项 D, 不符合 LSD 和 MSD。
11. C 基数排序的第 1 趟排序是按照个位数字的大小来进行的，第 2 趟排序是按照十位数字的大小来进行的，排序的过程如下图所示。
14. C 基数排序是一种稳定的排序方法。由于采用最低位优先 (LSD)的基数排序，即第一趟对个位进行分配和收集操作，因此第一趟分配和收集后的结果是{151,301,372,892,93,43,485,946, 146,236,327,9\}, 元素 372 之前、之后紧邻的元素分别是 301 和 892。
![[Pasted image 20231230163224.png]]
15. A，送分题。本书对归并的定义原话是“归并的含义是将两个或两个以上的有序表合并成一个新的有序表”, 而二路归并是将两个有序表合并为一个新的有序表。

## 操作：
![[Pasted image 20231230164655.png]]
![[Pasted image 20231230164705.png]]（我们每一次操作，都能让长度为：$2^i$ 长度的连续序列变得有序）