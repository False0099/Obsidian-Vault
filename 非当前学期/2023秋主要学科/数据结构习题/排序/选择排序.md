## 概念
![[Pasted image 20231230145724.png]]
01. A

![[Pasted image 20231230150037.png]]
16. C
![[Pasted image 20240102170353.png]]
 5. 堆排序 堆排序、快速排序、归并排序的最坏时间复杂度分别为 O(nlogn) $\mathrm{O( n^2) }$ O(nlogn),而显然堆排序的空间复杂度只有 O(l)要好于归并排序的 O(n)。
## 操作
![[Pasted image 20231230145801.png]]
03. **D** 本题思路来自基数排序的 LSD, 首先应确定 $k_1$、$k_2$ 的排序顺序，若先排 $k_1$ 再排 $k_2$, 则排序结果不符合题意，排除选项 A 和 C。再考虑算法的稳定性，当 $k_{2}$ 排好序后，再对 $k_{1}$ 排序，若对 $k_{1}$ 排序采用的算法是不稳定的，则对于 $k_{1}$ 相同而 $k_{2}$ 不同的元素可能会改变相对次序，从而不一定能满足题设要求。直接插入排序算法是稳定的，而简单选择排序算法是不稳定的，故只能选择选项 D。
![[Pasted image 20231230145822.png]]
05. D 可将每个选项中的序列表示成**完全二叉树**，再看父结点与子结点的关系是否全部满足堆的定义。例如，选项 A 中序列对应的完全二叉树如右图所示。显然，最小元素 19 在根结点，因此可能是小根堆，但 75 与 26 的关系却不满足小根堆的定义，所以选项 A 中的序列不是一个堆。其他选项采用类似的过程分析。
![[Pasted image 20231230154357.png]]
（小根堆：我们的根节点比我们的子树上的结点都要小）

![[Pasted image 20231230145828.png]]
06. C
操作：
第一步：按照我们的数据直接构造我们的一颗完全二叉树
第二步：我们对于 $i\leq \dfrac{n}{2}$ 的结点，我们判断每一个结点是否已经满足我们的大根堆的要求，如果不满足我们的大根堆的要求，我们就让**不满足要求的结点和这个结点的最大的孩子互换**
![[Pasted image 20231230154531.png]]
![[Pasted image 20231230145915.png]]
07. B 这是小根堆，关键字最大的记录一定存储在这个堆所对应的完全二叉树的叶结点中；又因为二叉树中的最后一个非叶结点存储在 $\lfloor$ n/2」中，所以关键字最大记录的存储范围为  $n/2\rfloor+1{\sim}n$,所以应该选择选项 B。


![[Pasted image 20231230145936.png]]
10. D（筛选法初始建堆为{8,17,23,52,25,72,68,71,60}, 输出 8 后重建的堆为{17,25,23,52,60,72,68,71}, 输出 17 后重建的堆为{23,25,68,52,60,72,71}。）
![[Pasted image 20231230145946.png]]
11. A 操作：
第一步：新节点插入到我们的表尾。
第二步：比较我们的新节点和我们的父节点，如果更符合要求，我们就交换。直到满足要求
![[Pasted image 20231230161741.png]]

![[Pasted image 20231230145957.png]]
12. B ![[Pasted image 20231230161804.png]]

![[Pasted image 20231230161845.png]]

![[Pasted image 20231230150014.png]]

14. C（删除操作：我们每一次就是把我们的被删除的元素，**用我们的最后一个元素替代**，然后再不断调整，直到我们的答案是小根堆）

![[Pasted image 20231230150026.png]]
15. A
![[Pasted image 20231230162639.png]]

![[Pasted image 20231230150046.png]]
17. B
![[Pasted image 20231230162725.png]]
![[Pasted image 20240103191106.png]]


## 计算
![[Pasted image 20231230145735.png]]
02. C


![[Pasted image 20231230145810.png]]
04. D 希尔排序和快速排序要等排序全部完成之后才能确定最小的 10 个元素。冒泡排序需要从后向前执行 10 趟冒泡才能得到 10 个最小的元素，而堆排序只需调整 10 次小根堆，调整时间与树高成正比。显然堆排序所需的时间更短。


![[Pasted image 20231230145925.png]]
08. C C (在向有 $n$ 个元素的堆中插入一个新元素时，需要调用一个向上调整的算法，比较次数最多等于树的高度减 1, 由于树的高度为 Llog $_2n$ 」+1, 所以堆的向上调整算法的比较次数最多等于 $\lfloor\log_2n\rfloor$。此处需要注意，调整堆和建初始堆的时间复杂度是不一样的，读者可以仔细分析两个算法的具体执行过程。)
09. AD (都较小。因此，可以证明在元素个数为 $n$ 的序列上建堆，其时间复杂度为 $O(n)$。无论是在最好情况下还是在最坏情况下，堆排序的时间复杂度均为 $O(n\log_2n)$。）

## 操作题：
![[Pasted image 20231230162818.png]]
![[Pasted image 20231230162834.png]]
