下一步：[[应用]]

链式队列思路：删除的部分放在我们的链表头，**插入的部分放在我们的链表尾部。于是我们就让我们的对头在我们的链表头，我们的队尾在我们的链表尾**。
![[Pasted image 20240104170636.png]]
2. D（插入第一个节点的时候，我们的头、尾指针都要修改）
![[Pasted image 20231031170100.png]]
01. D（共同点在于逻辑结构一样，不同点在于插入删除操作不一样）
02. B（FIFO 的定义捏）
03. D（定义捏）
04. B （先进先出捏）
05. D（因为我们是循环队列，所以我们要模上一个数，这个数就是我们的 n+1）
06. C 我们的队列长度就是我们的 $(rear-front+maxsize)\%21$，于是我们的队列长度就是我们的 C 16
![[Pasted image 20231031170536.png]]
07. B（没删除一个元素，我们有 $front=(front+1)\%6$，添加一个元素，我们有 $rear=(rear+1)\%6$。）
08. C（循环队列我们考虑一个特殊情况，然后带入我们的特殊值即可）
09. B (循环是画蛇添足地，因为我们还要特地去判断我们的 rear 和front)
10. A

![[Pasted image 20231031171107.png]]
11. A (我们是这样的)
12. D（看情况吧，如果我们有![[Pasted image 20231031171802.png]]
13. D
14. A
15. C (排除法)
16. C（人脑模拟法）

![[Pasted image 20231031172013.png]]
17. B![[Pasted image 20231031172347.png]]
18. A![[Pasted image 20231031172356.png]]
19. C![[Pasted image 20231031172405.png]]
![[Pasted image 20240103182830.png]]
4. D


## 操作题

![[Pasted image 20240102151025.png]]
在我们循环变量的类型结构中，增设一个 tag 型的整数变量，进队时置为 1，出队是置为 0.
![[Pasted image 20240102151146.png]]

![[Pasted image 20240102151159.png]]

![[Pasted image 20240102151212.png]]
![[Pasted image 20240102151331.png]]
![[Pasted image 20240102151221.png]]
思路：利用两个栈 si 和 s 2 来模拟一个队列，当需要向队列中插入一个元素时，用 s 1 来存放已输入的元素，即 S 1 执行入栈操作。当需要出队时，则对 S 2 执行出栈操作。由于从栈中取出元素的顺序是原顺序的逆序，所以必须先将 s 1 中的所有元素全部出栈并入栈到 s 2 中，再在 s2 中执行出栈操作，即可实现出队操作，而在执行此操作前必须判断 s 2 是否为空，否则会导致顺序混乱。当栈 sl 和 S 2 都为空时队列为空。

总结如下： 1)对 S 2 的出栈操作用做出队，若 s 2 为空，则先将 S 1 中的所有元素送入 S 2。
 2)对 si 的入栈操作用作入队，若 sl 满，必须先保证 s 2 为空，才能将 s 1 中的元素全部插入 S 2 中。
![[Pasted image 20240102151341.png]]
![[Pasted image 20240102151350.png]]

![[Pasted image 20240102151228.png]]
![[Pasted image 20240102152155.png]]
![[Pasted image 20240102152257.png]]

