下一步: [[非当前学期/2023秋主要学科/数据结构习题/队列栈/队列习题]]
## 定义
![[Pasted image 20231031161951.png]]

1. B (都属于线性结构，逻辑结构相同)
2. C（栈首先是哟中线性表，但是不能顺序存储，它是对存储有限制的）
![[Pasted image 20240103182159.png]]
3. B（删除我们的栈顶元素是我们的基本操作）

![[Pasted image 20240103182417.png]]
06. A
![[Pasted image 20240103182444.png]]
7. **C**（对于双向循环链表，无论是表头指针还是表尾指针，都可以很方便的找到表头结点，方便在表头做插入或删除操作。而单循环链表通过尾指针可以很方便的找到表头结点，但通过头指针找则要遍历一次。）
## 操作：

![[Pasted image 20240103185555.png]]
手工做法：
第一步：按照运算的优先级添加我们的括号 ![[Pasted image 20240103185935.png]]
第二步：如果我们要转换为我们的前缀表达式，我们就把我们的运算符号移到我们的括号前面，然后再把我们的括号去掉。![[Pasted image 20240103190029.png]]
第三步：如果我们要转换为我们的后缀表达式，我们就把我们的运算符号移到我们的括号后面，然后再把我们的括号去掉。
![[Pasted image 20240103190118.png]]
将中缀表达式转换为后缀表达式的**算法思想**如下：从左向右开始扫描中缀表达式；
遇到数字时，加入后缀表达式；
遇到运算符时：
a.若为' (', 入栈；
b.若为')', 则依次把桟中的运算符加入后缀表达式，直到出现' (', 从栈中删除' (''
c. 若为除括号外的其他运算符，当其优先级高于除·(·外的栈顶运算符时，直接入栈。否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，直到一个比它优先级低的或遇到了一个左括号为止。

当扫描的中缀表达式结束时，栈中的所有运算符依次出栈加入后缀表达式。

![[Pasted image 20240103185703.png]]
：

![[Pasted image 20240103182224.png]]
04. C 我们进栈时，应该先把我们当前栈顶的元素++，然后再去进行我们的数字添加，因此应该是我们的 C
![[Pasted image 20240103182310.png]]
05. A 我们的栈顶指针的相对偏移量就是我们的 2，因此我们的答案是我们的 1002 H
![[Pasted image 20240103182522.png]]
8. C（链栈采用不带头结点的单链表表示时，插入玩后需要将 top 指向该插入的结点 x）
![[Pasted image 20231031163038.png]]
9. D（先取数据，再去往回跳）
10. A（我们进行一个 $o(n)$ 的模拟即可）
11. B (卡塔兰数)
12. D（我们进行一个人脑的模拟即可，或者我们考虑这么一个性质，）
13. D（人脑模拟模拟）
14. D（特殊值，我们令 i=1 ）
15. D
![[Pasted image 20231031163909.png]]

16. C (我们如果 a 已经出栈了，那么我们 a 之前的出栈相对顺序一定是倒序)
17. C![[Pasted image 20231031164042.png]]
18. C
![[Pasted image 20231031164057.png]]
19. C
![[Pasted image 20231031164110.png]]

![[Pasted image 20231031164731.png]]
20. B
21. A
22. C（我们尝试使用我们的一个）
23. D（我们进行一波人脑模拟即可）
24. B (运用我们的出栈性质，然后在用我们的隔板法模型，我们就能接触我们的次数)

![[Pasted image 20231031165043.png]]
25. C
26. C
![[Pasted image 20240103182702.png]]
27. C
![[Pasted image 20240103182720.png]]
28. B（进栈时栈顶指针先+1, 再送值到栈顶元素。）
![[Pasted image 20240103190557.png]]
答案：3，这里我们可以模拟一下我们的操作
`a->ab->a->ac->acd->ac->a->ae->aef->ae->a->->g->` (**检查点**)

![[Pasted image 20240103211356.png]]

## 计算大题
![[Pasted image 20240102150050.png]]
我们出栈序列有：3 中，分别是我们的：DCEBA, DCBEA, DCBAE

![[Pasted image 20240102150201.png]]
我们的出栈入栈可以当作一个括号序列，我们的出栈操作一定不能大于我们的入栈。所以我们就一定能有：
```cpp
stack<char> a;
stack<char> b;
if(str[i]=='I'){
	a.push(i);
}else if(str[i]=='O'){
	if(a.size()){
		a.pop();
	}
}
```

![[Pasted image 20240102150419.png]]


![[Pasted image 20240102150436.png]]
我们这一题也可以抽象为我们的括号匹配问题，因此，我们就可以有下面的方法：
1. 我们找到我们的中点，我们中点前面的看成是一个左括号，我们中点往右的看成一个右括号
2. 我们直接进行我们的中心匹配即可。
![[Pasted image 20240102150905.png]]

![[Pasted image 20240102150624.png]]
我们可以让我们的 $s_{1}$ 向上增长，我们的 $s_{2}$，向下增长。

![[Pasted image 20240102150930.png]]
