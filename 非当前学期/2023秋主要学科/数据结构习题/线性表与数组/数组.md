下一步：[[非当前学期/2023秋主要学科/数据结构习题/线性表与数组/广义表|广义表]]

**在存储我们的下三角的时候，我们还需要一个位置来存储我们其余相同部分的值是多少**
同理，在存储我们的三对角矩阵的时候，我们也需要一个位置来存储我们其余相同部分的值是多少。

**注意看我们在数组中的元素从什么位置开始，如果从 0 开始，那么我们还要再我们的答案的基础上-1**。
## 概念
![[Pasted image 20240104153250.png]]
01. D
![[Pasted image 20240104153343.png]]
09. A
## 计算：
![[Pasted image 20240104172200.png]]
4. C 首先，我们的数组是按行存储的，所以我们 $A[2][2]$ 在 $A[0][0]$ 后 $2*(n+1)+2$ 个元素，所以我们就有：$n+1=15$,于是我们的 $A[3][3]$ 到我们的 $A[2][2]$ 之间的距离就是我们的 $675+15+1=692$
![[Pasted image 20240104153155.png]]
2. **C** (如果我们是一个对称矩阵的话，我们需要存放的元素就是我们的除了对角线以外的元素只用存 1 个，然后我们的对角线也要存，我们的总和就是 $1+2+\dots+n$)(**因为我们的 n 有可能不是偶数，我们的 $\frac{n^2}{2}$ 不一定为整数**)
![[Pasted image 20240104153208.png]]
03. A（我们第 i+1 行，那么我们前 i 行的总和就是我们的 $\dfrac{(i+1)*i}{2}$）, 然后又因为我们后来又有 i 个，所以我们的下表就应该是我们的 $A$
![[Pasted image 20240104153216.png]]
04. D（因为我们没有特殊的元素，所以我们的地址就是我们的 $8*10+5$）(注意：我们是 0-9 说明**一行有 10 个元素**)
![[Pasted image 20240104153226.png]]
05. B（注意到，我们的矩阵是我们的三对角矩阵对于三对角矩阵，将 $A[1... N][1... N]$压缩至 $B[1... 3 n-2]$时，$a_{i,j}$ 与 $b_k$ 的对应关系为 $k=2i+j-2$。则 A 中的元素 $A[66][65]$在数组 B 中的位置 $k$ 为 2×66 + 65-2=195 。）
![[Pasted image 20240104153234.png]]
06. C（按照列优先，那就是先把我们的列填满，然后再去填我们的行，因此我们的答案就是我们的 $\frac{(j-1)(j-2)}{2}+i$,再或者，我们可以用我们的特殊值法快速的排除）
![[Pasted image 20240104153319.png]]
07. B（因为我们是下三角矩阵，所以我们呢到第 j 列的时候，前面的 $(1-j-1)$ 列应该是都填满了的，而我们第 1 列有 n 个，第 2 列有 n-1 个，第 $j-1$ 列有 $(n-(j-1)+1=n-j+2)$ 个，因此我们一共就有：（$\frac{n+n-j+2)(j-1}{2}$））个，然后我们还要添加的就是我们现在有的行数是多少，这个就是我们的 $i-j+1$ 因此答案是我们的 B 选项
![[Pasted image 20240104153331.png]]
08. B
![[Pasted image 20240104155506.png]]

![[Pasted image 20240104153412.png]]
10. A![[Pasted image 20240104155719.png]]
![[Pasted image 20240104153421.png]]
11. C
![[Pasted image 20240104155751.png]]

## 稀疏矩阵存储
我们对于原来矩阵中的每一个元素，都采用一个三元组去计算它的对应位置是多少，比如我们可以用我们的 $(1,1,1)$ 来存储我们数组 $(1,1)$ 位置的数字是 1。
将我们的稀疏矩阵进行转置的思路：
我们开一个桶来统计我们 1 的数字有多少的，我们 0 的数字有多少个，以此类推。然后我们我们对于每一个位置统计出一个最早开始的位置，之后我们在读的时候依次放就可以了
```cpp
void reverse(List a,List b){
	b.sum=a.sum;
	b.col=a.row;
	b.row=a.col;
	for(int i=0;i<b.row;i++){
		cnt[i]=0;
	}
	for(int i=0;i<a.sum;i++){
		int row=a.data[i].j;
		cnt[row]++;
	}
	int sum[N];
	sum[0]=0;
	for(int i=1;i<a.sum;i++){
		sum[i]=sum[i-1]+cnt[i];
	}
	for(int i=0;i<a.sum;i++){
		int col=a.data[i].j;
		int pos=sum[col];
		b.data[pos]=a.data[i];
		sum[col]++;
	}
}
```