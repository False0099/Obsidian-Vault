下一步：[[非当前学期/2023秋主要学科/数据结构习题/栈习题]]

![[Pasted image 20240103210553.png]]


![[Pasted image 20240109134454.png]]
2. B（静态链表有一下特点：移动和删除和我们的链表是相同的时间，但是我们的时间复杂度相对更小一点。）
![[Pasted image 20231023151236.png]]
01. B（两种存储结构有好有坏，不能绝对，I 错误，链式存储用指针表示，有逻辑顺序，II 正确，在顺序存储中，插入和删除结点需要移动大量元素，效率低，III 错误，IV 正确）
2. B（快速删除，快速插入，显然可以用我们的链式结构（dancing links））
3. C（顺序存储即数组式存储，我们排序一定是 $o(n\log n)$,B 和 D 显然错误，）
4. D（I 树和图也能用我们顺序存储，错误，线性表采用顺序存储时 II 错误，III 时静态链表的特点，有序单链表只能依次查找插入位置，为 $o(n)$,队列要在表头删除元素，表尾插入元素，用带尾指针的方便）
![[Pasted image 20231023151915.png]]
5. A (对于 A，单链表和顺序表都是 $o(n)$,但是顺序表的**常数更大**，所以效率更高)
6. C（s 插入后，q 成为 s 的前驱，而 p 成为 s 的后继）
7. D（排序 $o(n\log n)$ +建表 $o(n)$,）
8. C ,遍历我们的 m 链表，找到我们的 m 链表尾部，然后我们再找我们的头部即可。 
9. C（插入、删除统一，不需要再判断是否在第一个元素之前插入或删除，空表和非空表也方便处理）

![[Pasted image 20231023152446.png]]

10. B (删除最后一个元素，我们还要去获得我们最后一个元素前面的元素地址是多少)
11. B, A（空表是这样的，两个都要满足）
12. C（删除最后一个 $o(m)$,尾节点没有后继，D 显然）
13. D（看看就行）

![[Pasted image 20231023153035.png]]

15. B (我们这一题为了保持我们有序，所以我们只需要求出我们第一个比该节点大的位置，然后我们再去在这个位置前插入即可)
16. D（插入删除都很方便，不是 A，随机访问和链表无关，不是 B,）
17. D (循环判空等价于头指针的 pri 和 ne 都指向自己)
18. A（末尾插入删除，类似于我们的栈？我们用单链表显然不合适，我们**需要多次修改相邻结点的指针**，于是我们就要最好采用我们的带头结点的双循环链表）
19. C

![[Pasted image 20231031160754.png]]
	   D.
20. C ，首先，因为我们要在最后一个元素后，所以我们最好有一个尾指针，并且我们找头节点是 $o(1)$ 的，很优。 (也就是我们的队列常用的操作)
21. C
22. B
23. D（对于一个空表，我们一定有 $head\to next=head$,因此，我们一定有 $head\to next\to next=head$,所以我们的长度可以为 0，如果长度位 1，那么我们就是常规操作）
24. D

![[Pasted image 20231031161436.png]]

25. D（我们只需要画出我们的对应的最终链表，然后就可以拿到我们的链接地址）
26. D（我们还要注意判断我们是不是一个空链表，如果我们删除之后，我们的尾指针已经改变，那么我们就要**把我们的尾指针移动到我们的开头**。）

## 操作题
![[Pasted image 20240102170421.png]]
P->next (我们最后的结构应该是 p, s,...)这样的。

（难点，虽然感觉可以修改成我们的带有父节点的方法）
![[Pasted image 20231231121130.png]]
![[Pasted image 20231231121159.png]]


![[Pasted image 20231231121232.png]]
我们的思路就是遍历到某一个点，并且存储这一个节点的父节点，如果是，我们就 (**链表的删除**)
![[Pasted image 20231231121558.png]]

![[Pasted image 20231231121821.png]]
我们这一题要从尾到头，我们可以采用我们的递归的思路（链表的反转 ,类似于我们的树）：
![[Pasted image 20231231121856.png]]

![[Pasted image 20231231122008.png]]
我们要删除一个结点，思路使用一个辅助结点，存储我们这一个结点的前驱节点。
![[Pasted image 20231231122103.png]]
![[Pasted image 20231231122109.png]]

![[Pasted image 20231231122208.png]]
这里我们的思路是构建一个类似于头插法的方法，而我们的节点数据来自于我们的其实。（我们的逆转就是**把我们原来的链表通过一个尾插法插入到一个新的节点上，就实现了我们的逆转**）
![[Pasted image 20231231122223.png]]

（**链表上的排序算法**）
![[Pasted image 20231231122730.png]]
思路：我们采用直接插入排序的思路，我们先假设我们已经有了前 $m$ 个有序的，现在我们要找到我们的第一个无序的结点 j，我们要把这个 j 插入到我们的正确的位置上去。
于是，我们就能有：
```cpp
point prevorder//有序节点前一个
point head//有序节点的头节点
point unorder//无序结点
point prevunorder//无序节点前一个,也就是最后一个无序节点
while(current){
	if(curr.val>=prev.val){
		prev=curr;
		curr=curr.next;
	}else{
		p=head;
		while(p.next.val<curr.val){
			p=p.next;
		}
			prev.next=curr.next;
			curr.next=p.next;
			p.next=curr;
			curr=prev.next;
	}
}
while(curr->next!=null){
	if(curr->data>prev->data){
		prev=curr;
		curr=curr->next;
	}else{
		p=head;
		while(p->next->data<curr->data){
			p=p->next;
		}
		prev->next=curr->next;
		current->next=p->next;
		p->next=current;
		current=prev->next;
	}
}
```
![[Pasted image 20231231123044.png]]
![[Pasted image 20231231122750.png]]


![[Pasted image 20231231123135.png]]
节点的删除，我们就需要先遍历我们的所有元素，然后如果满足条件，我们再删除，

（**经典算法**找两个链表的公共结点）
![[Pasted image 20231231123219.png]]

我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历长度之差个结点之后，再同步遍历两个链表，直到找到相同的结点，或者一直到链表结束。此时，该方法的时间复杂度为 $O ( len1+ len2)$。
![[Pasted image 20231231124240.png]]

![[Pasted image 20231231123238.png]]

![[Pasted image 20231231124536.png]]
（链表的拆分）
![[Pasted image 20231231123356.png]]

![[Pasted image 20231231124627.png]]
![[Pasted image 20231231124724.png]]

![[Pasted image 20231231123436.png]]
![[Pasted image 20231231124744.png]]


（链表上的unique 操作）
![[Pasted image 20231231123444.png]]
![[Pasted image 20231231124932.png]]

（链表的归并操作）
![[Pasted image 20231231123454.png]]
算法思想：两个链表已经按元素值递增次序排序，将其合并时，均从第一个结点起进行比较，将小的结点链入链表中，同时后移工作指针。该问题要求结果链表按元素值递减次序排列，故新链表的建立应该采用**头插法**。比较结束后，可能会有一个链表非空，此时用头插法将剩下的结点依次插入新链表中即可。
![[Pasted image 20231231125041.png]]

![[Pasted image 20231231123510.png]]
![[Pasted image 20231231130134.png]]

(**类似于链表归并的思路**)
![[Pasted image 20231231123516.png]]

![[Pasted image 20231231130213.png]]

（链表上的 KMP 算法）
![[Pasted image 20231231123525.png]]
![[Pasted image 20231231130501.png]]

![[Pasted image 20231231124033.png]]
![[Pasted image 20231231130537.png]]

![[Pasted image 20231231124041.png]]

![[Pasted image 20231231130545.png]]
![[Pasted image 20231231124055.png]]
![[Pasted image 20231231130600.png]]
![[Pasted image 20231231124101.png]]
![[Pasted image 20231231130607.png]]