下一步：[[哈夫曼树]]

## 遍历顺序
![[Pasted image 20231222143653.png]]
01. C **中序遍历的最后一个结点（最大值），一定是由根节点开始走，沿着右指针走走到的最低点**，假设 p 是叶子节点，那么我们的前序与中序遍历的最后一个结点也是他，
![[Pasted image 20231222143708.png]]
![[Pasted image 20231222143808.png]]
02. 我们的最好的方法就是画图，或者从我们的流程去思考，我们因为我们一定有：结点 b 在左，结点 c 在右，所以一定有：结点 b 一定在结点 c 的前面，C
3. n 在 m 前，也就是 n 比 m “大”，也就是说，我们要满足：C
4. **后续遍历（从一个点到另一个点的简单路径）** 时，我们是按照 LRN 的，若 n 在 N 的左子树，m 在 N 的右子树，那么在后续遍历的过程中，n 在 m 之前访问；若 n 是 m 的子孙，设 m 在 N 的位置，那么 n 无论是在 m 的左还是右，D
5. C，因为后序遍历满足后序遍历中的两个点之间的所有点描述了一条路径，所以我们就可以用我们的这个来进行。
6. B，因为访问左右节点的顺序是没有改变的。
7. C，对每个顶点从 1 开始按序编号，要求结点编号大于其左、右孩子编号，并且左孩子编号小于右孩子编号。编号越大说明遍历顺序越靠后，因此，三者遍历顺序为先左子树、再右子树、后根结点。4 个选项中仅后序遍历满足要求。


![[Pasted image 20231222143835.png]]
09. C因为我们的非空树的先序遍历和后序遍历相反，即“根左右，左右根”顺序相反，因此树只有根节点或者根节点只有左子树或者右子树，依次类推，左子树也具有类似的性质。因此整体来说，我们的二叉树就有：书中所有非叶节点的度数为 1，即二叉树只有一个叶节点。
10. C 我们这一题的做题思路是自己画一颗树，然后用特殊值去解。但是

## 遍历计数
![[Pasted image 20231222143819.png]]
这一题，我们的思路见 [[neuqoj 1022 二叉树]].总之就是由 4 颗这样的树。
## 遍历可能性
![[Pasted image 20231222143852.png]]
12. B 二叉树的**前序和中序的关系相当于以前序作为我们的入栈序列**，然后我们的中序是我们的出栈序列，因此我们就可以来算出，我们的结果
13. D (显而易见的)
14. 我们这种题的做法就是先求出我们的树长什么样子，之后再去进行一边后续遍历即可。
15. 我们这种题的做法就是先求出我们的树长什么样子，之后再去进行一边后续遍历即可。
16. 我们由层序+中序求解树的
## 线索二叉树定义
![[Pasted image 20231222144004.png]]
17. A
18. C (线索二叉树并没有改变我们的二叉树，知识改变了它的某些存储方式而已)
22. D (有左孩子或者有孩子的就不行)
23. D（![[Pasted image 20231222172156.png]]）
## 线索二叉树计算
![[Pasted image 20231222172030.png]]

19. C 我们如果一个节点的度为 0，那么我们这个节点的线索就是 2，如果一个节点的度为 1，那么我们这个节点的线索就是 1，所以我们就有 $n+1$ 个或者，我们有：![[Pasted image 20231222172042.png]]
20. C
21. D ![[Pasted image 20231222172102.png]]

## 性质
![[Pasted image 20231222172254.png]]
24. C（![[Pasted image 20231222172337.png]]）
25. C（后续搜索树遍历时，最后访问根节点，）
![[Pasted image 20231222172416.png]]
26. B（非空二叉树的）
![[Pasted image 20231222172552.png]]
