上一篇：[[Cache组成]]
下一篇：[[Cache替换]]，[[非当前学期/2023秋主要学科/计算机组成原理/存储系统/Cache]]
## Cache 和主存的映射方式
我们的一个 `Cache` 会分为若干个“行”，而我们的一个块内又会包含我们的若干个存储单元。与之相对应的，我们的 `主存` 中也会分为若干个“块”，它的大小和我们的行是相同的，结构也是相同的。

Cache 行中的信息时主存中某个块的副本，地址映射是指把主存地址空间映射到 Cache 地址空间，即把存放在主存中的信息按照某种规则装入 Cache。


由于 **Cache 行数比主存块数少得多**，因此主存中只有一部分块的信息可以放在 Cache 中

### 直接映射
主存中的每一块只能装入 Cache 中的唯一位置。若这个位置已有内容，则产生块冲突，**原来的块将无条件的替换出去**，（[[Cache替换]]）我们对应的映射关系可以直接定义为 **Cache 行号=主存块号 mod Cache 总行数。**

**主存地址=标记位+块号+块内地址**	

假设 Cache 一共有 $2^c$ 行，主存有 $2^m$ 块，在直接映射方式中，主存的第 0 块，第 $2^c$ 块... 只能映射到第 0 行，以此类推。
	
由映射函数可以看出，**主存块号的低 c 为正好是他要装入的 cache 行号**。给每个 cache 行设置一个**长为 $t=m-c$ 的标记**，([[Cache组成]]中 CAM 表 tag 的内容)标记我们现在的 cache 是**同余系下哪一个的映射**，也就是我们的 k 是多少，当主存某块调入 cache 后，就将其块号的高 t 位设置在对应的 Cache 行的标记中，如图
	![[Pasted image 20230927102900.png]]

我们在 CPU 访存过程中，首先根据访存地址的中间的 c 位，找到对应的 Cache 行，将对应 Cache 行中的标记和贮存地址的高 t 位标记进行比较，若相等且有效位为 1，则访问 Cache 命中，否则不命中。


### 全相联映射 (Hash)
主存中的每一块可以装入 Cache 中的任何位置，每行的标记用于指出该行取自主存的哪一块，所以 CPU 访存时需要与所有 Cache 行的标记进行比较。
我们这个时候的标记为就应该是存储我们的对应的**主存地址的高 t 位**([[Cache组成]]中 CAM 表的标记内容)

**主存地址=标记+块内地址**
	![[Pasted image 20230927103635.png]]
因为我们的映射是随机的，所以我们对我们的每一个 `cache` 块，都要去找对应的标记数据是多少，因此，我们的 `CAM` 表的大小就应该是我们的 Cache 块数 $\times$ 主存标记位数。

![[Pasted image 20231207120401.png]]
![[Pasted image 20231207120442.png]]

### 组相联映射
**将 Cache 分成 Q 个大小相等的组**，每个主存块可以装入固定组中的任意一行，组间采用直接映射，组内采用全相联映射。**此时我们的标记，就只是我们的主存地址的前几位 （[[Cache组成]]中 CAM 表），为不是我们的所有位。**

主存地址=标记+组号+块内地址
![[Pasted image 20230927111335.png]]
![[Pasted image 20230927111404.png]]



![[Pasted image 20230927114140.png]]
我们这里的行长，**仅仅只是指我们有效数据部分的大小**，即我们一个 cache 行中能存储多少主存中的信息，这里我们是 64 B，512 bit。
我们之后标记位，我们的主存地址有 28 位，其中 6 位位块内地址（$\log_{2}64$），3 位为行号 ($\log_{2} 64)$，标记字段长度=主存地址总长度-**块内地址**总长度-行号= $28-6-3$。再加上一位有效位，我们就一共有 20 位改行对应的标记位，总容量为 $8*(512+1+19)=4256$
![[Pasted image 20230927121022.png]]
![[Pasted image 20230927121016.png]]

在直接映射方式中，主存按照块的大小划分，主存地址 3200 对应的字块号为 $\frac{3200B}{64B}=50$,而 Cache 只有 8 行，则 Cache 行号为 2

**我们把我们的块理解成我们存储器中的一片，我们的块内地址就相当于我们的片内地址**

