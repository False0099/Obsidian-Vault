## 定点除法运算
设有 n 位定点小数，被除数为 x，其原码为 $[x]_{原}=x_{f}x_{n-1}\dots x_{1}x_{0}$
除数 y，其原码为 $[y]_{原}=y_{f}y_{n-1}\dots y_{1}y_{0}$,那么我们的商 $q=\frac{x}{y}$ 其原码为 $[q]_{原}=(x_{f}\oplus y_{f})+\frac{0.x_{n-1}\dots x_{1}x_{0}}{0.y_{n-1}\dots y_{1}y_{0}}$

纯正数出发前提：

## 原码除法  ：
前提条件：
1. 除数不为 0 
2. 定点纯小数时，被除数位数<除数位数，不够往前补 0
3. 定点纯整数时，被除数位数 $\geq$ 除数位数，不够要往后补 0

商的符号=被除数的符号 $\oplus$ 除数的符号

商=被除数/除数

过程：假设我们给定 $X=a_{7}a_{6}a_{5}a_{4}a_{3}a_{2}a_{1}a_{0}$, $Y=b_{3}b_{2}b_{1}b_{0}$,我没要求一个 4 bit 的商，我们在确定商的某一位时，我们要**比较我们上一位余数和我们下一位加起来这个数字与我们 $b_{3}b_{2}b_{1}b_{0}$ 的大小关系**，如果大，我们就商 1，**减去我们的除数后作为我们这一位的余数**，如果小，我们就商0，余数保留，右移一位作为我们的新余数。



1. 设 X= $0.1011$, $Y=0.1101$,则 $\frac{X}{Y}=?$


![[Pasted image 20230913103605.png]]


## 恢复余数法 ：
1. 运算法则
![[Pasted image 20230913104129.png]]
1. 被除数 $x=-0.10001011$,除数 $Y=0.1110$,我们利用原码恢复余数法求商及余数
![[Pasted image 20230913103926.png]]

![[Pasted image 20230913104844.png]]

我们的**符号器仍然可以采用我们的异或运算**。

##  加减交替法：
##### 运算一步加减完成时，遵循的规则

- **当余数为正时，表示够减，即商上1，在进行下一次商时，将余数(此时为正)左移一位，减去除数**。
- **当余数为负时，表示不够减，即商上0，在进行下一次商时，将余数(此时为正)左移一位，加上除数**。
- 运算时需要双符号补码，所以应先把给定的定点数转换为补码形式，需要注意的是，除数的负数也要转换为双符号补码，方便后面作减法。因为在计算机中减一个数等于加这个数的负数。而补码正是用来做加减法的。
- 操作的步数 n 是由要求的 n 位商决定的，如果第 n 步余数为负，则需增加一步恢复余数，即 +Y ，增加的这一步不移位。

**题目：**

X=0.1011  
Y=0.1101  
用加减交替法求X/Y

**解:**  
[X]补 =0.1011 对应的双符号位补码为 00 1011  
[Y]补 =0.1101 对应的双符号位补码为 00 1101  
[-Y]补 =1.0011 对应的双符号位补码为 11 0011

开始计算，X先减一下Y，即X+[-Y] 我们用双符号补码来做  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191222153434505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4OTg0MQ==,size_16,color_FFFFFF,t_70)  
根据规则，结果若是负数，代表不够减，下一步应该+Y，则**商上0**，并且在进行下一步之前让余数左移一位。即余数11 1110变为 11 1100

开始下一步  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191222153723582.png)  
根据规则，结果若是正数，代表够减，下一步应该-Y，(-Y 就是加上-Y) 则**商上1**，并且在进行下一步之前让余数左移一位。即余数00 1001 变为 01 0010

开始下一步  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191222153947801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4OTg0MQ==,size_16,color_FFFFFF,t_70)  
根据规则，结果若是正数，代表够减，下一步应该-Y，(-Y 就是加上-Y) 则**商上1**，并且在进行下一步之前让余数左移一位。即余数00 0101 变为00 1010

开始下一步  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191222154202162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4OTg0MQ==,size_16,color_FFFFFF,t_70)

11代表双符号位的负数，根据规则，结果若是负数，代表不够减，下一步应该+Y，则**商上0**，并且在进行下一步之前让余数左移一位。即余数11 1101变为 11 1010

开始下一步

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191222155055194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4OTg0MQ==,size_16,color_FFFFFF,t_70)  
00代表双符号位的正数，根据规则，结果若是正数，代表够减，则**商上1**，

这时候商了五次，到了X和Y的位数

最终商总共上了01101 所以最终结果的数值位为1101 符号位为相除两数符号的异或值，在这里都是0和0 即最终异或值应该为0

另外还应该加上余数00 0111(上图最后双符号位形式) 即0.0111 (正常形式)

最后结果为0.1101 + 0.0111 × 2-4


![[Pasted image 20230913111610.png]]
ABE


![[Pasted image 20230913110736.png]]

阵列除法器：
1. 补码运算的进位
![[Pasted image 20230913111919.png]]

可控加减单元 CAS
![[Pasted image 20230913112055.png]]

![[Pasted image 20230913112228.png]]

