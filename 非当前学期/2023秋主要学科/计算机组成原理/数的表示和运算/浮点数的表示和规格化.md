# 浮点数的表示方法（IEEE 754）
1. 一般格式表示（非规格化）

![[Pasted image 20230914124818.png]]

假设我们的**阶码和尾数都采用原码**形式
那么我们数的真值 $N=2^E*M$,其中我们的 E 为我们的阶码对应的数值，**M 为我们的尾数**，**一般来说，我们的尾数都是一个纯小数**。![[Pasted image 20231008110951.png]]

例如：
![[Pasted image 20230914125043.png]]
如果都采用补码，那么我们的-01 就要用补码的 111 表示，我们的 (-0.1110)也要转换为补码的 (10010)。最后，我们两个相加即可。

非规格数的范围：
原码表示时：
最大正数： ${(01111111)_{阶码}(011111111111)_{尾码}}$

最大负数：$(111111111)_{阶码}(100000001)_{尾码}$

最小正数：$(11111111)_{阶码}(0000000001)_{尾码}$

最小负数：$(01111111)_{阶码}(11111111)尾码$

补码表示时：
最大正数 $(0111111)_{阶码}(01111111)_{尾码}$
最小负数 $(011111)_{阶码}(10000000)_{尾码}$
最大负数 $(10000000)_{阶码}(100000001)_{尾码}$
最小正数 $(1000000)(0000000001)$







**规格化**：尾数的数值位最高位必须是一个有效值（**我们的 IEEE 754 与我们的一般规格化规则不同**）
**对于原码**，正数尾数必须是形如：$(0.1xxxxxxxxxx)$ 的形式。负数也必须是形如：$(1.1xxxxxxxxxx)$ 的形式如果不满足时，我们就需要把我们的尾数进行左移操作
![[Pasted image 20231008105545.png]]
对于正数而言：最大的为 $(0111)_{阶码}(0111)_{尾数}$
最小的为 $(1111)_{阶码}(0.100)$

对于负数而言：我们最小的为 $(0111)(1111)$
我们最大的为 $(1111)(1100)$

对于补码：我们规定必须是 $0.1xxxxxxxxx$ 这种形式，对于负数，我们规定，必须是 $1.0xxxxxxx$ 这种形式

因此，![[Pasted image 20230914131533.png]]
![[Pasted image 20230914131539.png]]

IEEE-754 标准下的浮点数：
**浮点数中尾数用原码，阶码用移码**

第一步，我们把原来的小数转变为形如 $\pm(1.x)*2^M$ 的形式，然后我们在所有的数位中，用一位来表示**符号**，一位来表示我们 $(1.x)$ 中的**小数部分（M）**，32 位计算机中有 $23$ 位，64 位计算机中有 52 位，另外用若干位来表示 2^M 中的**指数（E）**，32 位计算器中有 8 位，64 位浮点数中有 11 位。

其中，我们的指数部分采用移码方式存储，32 位浮点数中，移码改变的固定常数量为 $127=2^7$，同时我们的移码量应该由我们的实际值+127 来表示。

我们把浮点数转化为十进制数，我么应采用下面的公式
![[Pasted image 20230906085307.png]]


一些规定：（**阶码为 0，阶码为 255 是特殊用法，所以我们的有效范围只是从 1-254**，因此我们指数的取值范围为-126-127）
若 E=255 (指数，M<>0（小数）），则 N=NAN（无定义数据）
若 E=255（指数），M=0（小数），则 N= $\pm\infty$
若 0<E<255（指数）, 则 N= $(-1)^s*(1.M)*2^{E-127}$
若 E=0（指数）, M=0（小数），则 N=0
若 E=0（指数），且 M<>0, 则 N= $(-1)^s*(0.m)*2^{-126}$（非规格书）

想要求出我们尾数的真实值，我们就只需要把我们的阶码以**实际值减去我们的 127 后，才是我们的实际得阶码**。


EG:
![[Pasted image 20230906090720.png]]

![[Pasted image 20230906090906.png]]

当我们的**阶码用补码表示**时
浮点数的最小负数

浮点数的最大负数

浮点数的最小负数

贪心：我们的阶码位 011111111, 让我们的阶尽可能的打
我们的尾数位应为 1.00000000 (因为我们的**尾数用补码**表示，所以我们找到最大负尾数即可)

浮点数的最大正数