上一章：[[字符表示方法]]
下一张：[[校验方式]]
# 浮点数的表示方法
![[Pasted image 20230914124818.png]]
假设我们的**阶码和尾数都采用原码**形式
那么我们数的真值 $N=2^E*M$,其中我们的 E 为我们的阶码对应的数值，**M 为我们的尾数**，**一般来说，我们的尾数都是一个纯小数**。（因为我们要求我们的尾数是一个完全小数，因此我们就可以进行我们的规格化操作， $0.8\times10^6$）

### 小数转为典型浮点数
例如：
![[Pasted image 20230914125043.png]]
如果都采用补码，那么我们的-01 就要用补码的 111 表示，我们的 (-0.1110)也要转换为补码的 (10010)。最后，我们两个相加即可。

![[Pasted image 20240107200319.png]]

## 编码转换为真值

### 规格化：
#### **一般[[规格化]]要求**：
1. 尾数的数值位最高位必须是一个有效值（我们的 IEEE 754 与我们的一般规格化规则不同）
2. 我们区分原码和补码，**原码和补码的规格化不相同**

**对于原码**，正数尾数必须是形如：$(0.1xxxxxxxxxx)$ 的形式。负数也必须是形如：$(1.1xxxxxxxxxx)$ 的形式如果不满足时，我们就需要把我们的尾数进行左移操作（**原码第一位必须是 1**）

**对于补码**：我们规定必须是 $0.1xxxxxxxxx$ 这种形式，对于负数，我们规定，必须是 $1.0xxxxxxx$ 这种形式（**补码符号位与最高位异或结果一定为 1，否则我们就移位**）
## 非规格数的范围 （[[边界值]]）：
原码表示时：
最大正数： ${(01111111)_{阶码}(011111111111)_{尾码}}$

最大负数：$(111111111)_{阶码}(100000001)_{尾码}$

最小正数：$(11111111)_{阶码}(0000000001)_{尾码}$

最小负数：$(01111111)_{阶码}(11111111)尾码$

补码表示时：
最大正数 $(0111111)_{阶码}(01111111)_{尾码}$
最小负数 $(011111)_{阶码}(10000000)_{尾码}$
最大负数 $(10000000)_{阶码}(100000001)_{尾码}$
最小正数 $(1000000)(0000000001)$

![[Pasted image 20240107195239.png]]

对于正数而言：最大的为 $(0111)_{阶码}(0111)_{尾数}$
最小的为 $(1111)_{阶码}(0.100)$

对于负数而言：我们最小的为 $(0111)(1111)$
我们最大的为 $(1111)(1100)$




## [[IEEE -754]] 标准下的浮点数：
### 浮点数的格式
32 位浮点数=1 位符号+8 位阶码（移码表示，dx=127）+23 位尾码（原码表示）

64 位浮点数=1 位符号+11 位阶码（移码表示）+52 位尾码（原码表示）

**浮点数中尾数用原码，阶码用移码**
因为我们的尾数不需要我们的政府，我们只需要直到我们尾数的后面几位是多少即可。
第一步，我们把原来的小数转变为形如 $\pm(1.x)*2^M$ 的形式，然后我们在所有的数位中，用一位来表示**符号**，一位来表示我们 $(1.x)$ 中的**小数部分（M）**，32 位计算机中有 $23$ 位，64 位计算机中有 52 位，另外用若干位来表示 2^M 中的**指数（E）**，32 位计算器中有 8 位，64 位浮点数中有 11 位。

其中，我们的指数部分采用移码方式存储，32 位浮点数中，移码改变的固定常数量为 $127=2^8-1=0111\ 1111$，同时我们的移码量应该由我们的实际值+127 来表示。

### 浮点数转换为真值
（相比较来说，我们的 IEEE 754 方法更接近我们的科学计数法，因为我们的科学计数法中，也是要求我们的最高位位为 1.）

我们把浮点数转化为十进制数，我么应采用下面的公式
![[Pasted image 20230906085307.png]]
或者，我们可以采用我们的**符号位取反，末尾加 1 的方法，来快速的求出我们对应的补码是多少**。
![[Pasted image 20240107195606.png]]
![[Pasted image 20240107200053.png]]

![[Pasted image 20230906090720.png]]
## 真值转换为浮点数：
![[Pasted image 20240107200211.png]]

![[Pasted image 20240107200347.png]]



想要求出我们尾数的真实值，我们就只需要把我们的阶码以**实际值减去我们的 127（0111 1111） 后，才是我们的实际得阶码**。
（在这里，我们的译码不能用我们的简单的符号位取反来进行我们的计算）

当我们的**阶码用补码表示**时（[[边界值]]）

浮点数的最小负数：

浮点数的最大负数

浮点数的最小负数

贪心：我们的阶码位 011111111, 让我们的阶尽可能的打
我们的尾数位应为 1.00000000 (因为我们的**尾数用补码**表示，所以我们找到最大负尾数即可)

浮点数的最大正数

## IEE 754 的[[边界值]]
一些规定（[[边界值]]）：（**阶码为 0，阶码为 255 是特殊用法，所以我们的有效范围只是从 1-254**，因此我们指数的取值范围为-126-127）
若 E=255 (指数，M<>0（小数）），则 N=NAN（无定义数据）（**指数满，我们的小数必须全部为 0**，否则算无定义数据）
若 E=255（指数），M=0（小数），则 N= $\pm\infty$
若 0<E<255（指数）, 则 N= $(-1)^s*(1.M)*2^{E-127}$
若 E=0（指数）, M=0（小数），则 N=0
若 E=0（指数），且 M<>0, 则 N= $(-1)^s*(0.m)*2^{-126}$（非规格书）

1. 如果我们的**阶码全为 0** 且我们的尾数全为 0-》我们表示的是我们的数字 0
2. 如果**阶码全为 1**，且我们的尾数全为 0，表示我们的无穷大。
3. 如果**阶码全为 1**，但我们的尾数不全为 0，那么我们这个是无效的表示。