# 运算器的基本结构
典型运算器包括
1. 算术逻辑单元 ALU（这里我们都采用**补码计算**）
	1. 基本思想
		1. 先将原全加器的输入送至函数发生器进行处理，
		2. 函数发生器的输出送入全加器中进行全家
		3. 由一些部件控制 ALU 完成对应的运算，通过信号变化，我们可以让 ALU 实现多种不同的功能
	2. 实例 74181
		1. M 决定工作模式

2. 阵列乘除法器
3. 寄存器组（数字电路）
	1. 功能上能够暂时的存储我们之前输入的数据
	2. 结构上参见数字电路课程（
4. 多路选择器/多路分配器
	1. 功能
	2. 结构上参见数字电路课程
5. 三态门（连接）
6. 数据总线（连接）

二进制操作
1. 逻辑或
	1. 将一个数的某些位置指定比特变为 1，其他位置保持不变
2. 逻辑与
	1. 将一个数的某些指定比特清空，其他比特保持不变
3. 逻辑异或
	1. 将一个数的某些特定位置取反，其他比特保持不变
4. 两数相加进位的表示
	1. $F_{i}=X_{i}\bigoplus Y_{i}\bigoplus C_{n+i}$ //表示某一位的应有值
	2. $C_{n+i+1}=X_{i}Y_{i}+Y_{i}C_{n+1}+X_{i}C_{n+i}$

一位全加器
要求功能：输入两个一位二进制数，给出两个数相加的结果

结构
	![[63WXPR($XOHVMQ7J31Y0T_O.png]]


基本的二进制加法器：
当我们在计算器中进行二进制计算时，我们应该**按位计算，如同我们的列竖式一样的**。我们给加法器三个输入，一个输入位加数 a，另一个输入为加数 b，最后一个输入为上一位的输入 c。那么**我们在这一位的结果**就是 $a\oplus b\oplus c$,我们这一位给下一位的进位就是 $C_{i+1}=A_{i}B_{i}+(A_{i}\oplus B_{i})C_{i}$。（两个都是 1 进位，1 个进位为 1 且我们上一位的进位为 1，我们也要进位）。

转化为我们的数字电路，我们可以画出下面的电路图（详情见数字电路）


N 位**行波进位**的补码加法、减法器（包含有溢出等提示）

要求功能：输入两个 n 位的二进制数，要求我们给出两个数相加的结果，并且提示我们是否溢出
如果我们采用**串行**方法连接我们的加法器，我们记 $C_{i+1}$ 的时间延迟为 $2T$,那么 n 为行波进位器的时间延迟就是 $t_{a}=(2n+9)T$。设一位全加器的进位延时为 $dt$,则 n 位加法器的延时就是 $n dt$, 
结构
![[W{SK5EG{%HK20(YX}3}YFRA_tmb.png]]

时间延迟分析：
第一步：画出我们一个正常全加器的延迟是多少
第二步：在我们的全加器上不断地找我们的最长路是多少，最后的最长路，就是我们的时间。**假设我们经过异或门，我们的延迟是 $3T$, 我们经过我们的或门时间是 $t$**。
我们发现，除了一开始有一个 $3T$ 以外，每一个加法器，都青果两个延迟，也就是 $2T$，因此，我们的最后总共的时间延迟就是我们的 $3T+n\times 2T$
找最长路，假设我们一个 T 表示一级门延迟，我们一个异或门延迟为 $3T$,那么我们的最长路径如下所示：
![[Pasted image 20240109145805.png]]

4. 改进将串行改为并行
加法器进位链的基本逻辑关系
		1. $C_{i+1}=A_{i}B_{i}+(A_{i}\bigoplus B_{i})C_{i}$
		2. 令 $G_{i}=A_{i}B_{i}$ 为进位产生函数（本地进位）$p_{i}=A_{i} \bigoplus B_{i}$ 为进位传递函数（进位条件），即 $P_{i}C_{i}$ 为传送进位或条件进位，
		3. 所以 $C_{i+1}=G_{i}+P_{i}C_{i}$
		4. 只有当 $A_{i}=B_{i}=1$ 时，本位才向更高位进位
		5. 当 $A_{i}\neq B_{i}$ 时，低一位的进位将向更高位传送
		6. 传送进位和本地进位不可能同时为 1
由此，我们可以改进我们的 C
1. $C_{i+1}=G_{i}+P_{i}(G_{i-1}+P_{i-1}C_{i-1})$,根据这个公式，我们只需要知道最低位进位 C 0，然后再分别计算各个位置上自己的 P 和 G 函数，就可以得到我们的 C，而不用再并行操作。
![[_LZH()3V3TP9_LVP%%K]MAN_tmb.png]]

我们假如把我们的变量看成一个八位的二进制输入，把我们的输出看作一个函数，那么我们的每一位结果都是一个关于我们八个输入的函数。于是我们就可以通过我们的卡诺图化简，来确定我们每一个位置的具体的表达式应该是多少。

最后，我们就能发现，我们的每一位的表达式应该如图所示：
![[Pasted image 20240109150911.png]]

然后，我们就能获得我们的最后的所有的加法器连线图：
![[Pasted image 20240109151343.png]]

这个时候，我们的延迟计算就可以通过
1. 分析我们的电路
我们的电路中，需要耗时最长的，应该是我们的 $C_{4}$,我们首先计算我们的 $P_{4},G_{4}$,这些，会消耗我们的 $T$,然后，我们的每一个最长的有 4 个项相连，因此我们就有 $3T$ 的延迟，于是我们就要**先花费**$4T$ 来计算我们的 $C_{4}$,然后我们每一个位置，还需要一个或门 $T$ 异或来计算出我们的 $S_{4}$ 的大小。
总之，我们的 4 位全加器的时间就是我们的 $3T+3T=6T$,其中，我们的 $3T$ 计算进位，我们的 $3T$ 计算我们的异或。因此
2. 推广结论：
不论我们的时间延迟是多少，我们的 $k$ bit 时间，都是我们的一个固定值，这个值只与我们的每一个电路的结构相关。这里是因为我们每一个最多只会加三个。

![[Pasted image 20240109153035.png]]


![[Pasted image 20230913093134.png]] 

其他：BCD 数加法器：
	当我们在进行 BCD 运算时，注意到，运算中某位 BCD 数**相加的结果大于 9 或有向更高位的进位，则结果加六**，否则无需矫正。

![[Pasted image 20230913093524.png]]

![[Pasted image 20230913093814.png]]**B**

