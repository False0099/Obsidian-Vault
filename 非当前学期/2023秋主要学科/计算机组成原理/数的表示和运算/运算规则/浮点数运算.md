上一篇：[[非当前学期/2023秋主要学科/计算机组成原理/数的表示和运算/ALU的设计]]
下一篇：[[运算溢出]]，[[非当前学期/2023秋主要学科/计算机组成原理/CPU/指令流水线]]，[[非当前学期/2023秋主要学科/计算机组成原理/存储系统/系统概述]]

**IEEE 754 中，在对阶的时候我们要把隐藏的 1 补充上去**

设我们由两个浮点数 x 和 y，他们分别为 $x=2^{E_{x}}*M_{x}$
$y=2^{E_{y}}*M_{y}$。其中 $E_{x}$ 和 $E_{y}$ 为阶码，$M_{x},M_{y}$ 为尾数。
## 加减法
那么我们两个浮点数在进行加法和减法的运算规则就是：
![[Pasted image 20230907103323.png]]
过程分为四步

第一步：0 操作数检查
**如果判断直到 x 或 y 中有一个数位 0，那么我们就跳过后面的所有操作**

第二步：比较阶码大小并完成对阶**小阶变大阶**（10+100），
全部化成我们的 $1,10\to 0.1\times10,1\times10$
**注意，我们因为在浮点数表示的时候省略了我们的开头的 1，但是我们在对阶的过程中，要把这个给补全**，例如：
![[Pasted image 20231129130226.png]]
我们呢的 $x$ 阶数是小于我们的 $y$ 的，所以我们就需要进行我们的对阶操作，对阶后，我们的 x 就应该是：
![[Pasted image 20231129130324.png]]


第三步：尾数进行加减运算
按照定点加减法进行，把我们的浮点数直接传入到我们的定点数加法器中即可。（注意，这一步的时候，如果我们采用的是我们的 IEEE 754，那么我们还要把我们隐藏的 1 给添加）

![[Pasted image 20231129130405.png]]

第四步：结果规格化
如果是我们的 IEEE 754，那么我们就转换为绝对值为 $1.x$ 的形式，如果是我们的标准浮点数，我们就转换为绝对值为 $0.x$ 的形式。注意，如果是我们的典型浮点数，那么我们的末尾形式一定是 $0.1$ 或者 $1.0$。
![[Pasted image 20240107212559.png]]


第五步：舍入处理
在对阶或向右规格化时，尾数右移，尾数的低位取值直接丢掉会引起较大计算误差，为减小计算误差，尾数右移要丢掉的低位取值 (称为保护位)暂时保留
![[Pasted image 20240107212745.png]]
实例：
1. 如果我们的尾数中有 0.000001，那么我们就要把我们的尾数进行移位，这个时候我们不存在舍入问题
2. 如果我们的尾数是形如 10.000001，那么我们就要把我们的尾数进行左移，也就是我们的右规，对于我们被抹除掉的哪一位，我们可以按照下面的舍入规则来处理：
![[Pasted image 20231129130739.png]]
例如：
![[Pasted image 20231129130906.png]]

第六步：我们进行我们的溢出判断，这里我们**浮点数溢出判断实际上只是在关注我们的阶码**，这一步，我们可以通过我们的手动判断，如果溢出了，那么我们就要返回我们的对应信息，我们浮点数一共有四种溢出：

上溢出：若**阶码的值超过了阶码所能表示的最大正数**上溢出时，若浮点数为正数，为正上溢，浮点数记为$+\infty$; 若浮点数为负数，为负上溢，浮点数记为$-\infty$ 

下溢出：若**阶码的值超过了阶码所能表示的最小负数**；下溢出时，若浮点数为正数，为正下溢，若浮点数为负数，为负下溢。正下溢和负下溢时浮点数**记为 0**。


例题：浮点数运算
![[Pasted image 20230907104946.png]]
![[Pasted image 20230907105000.png]]
![[Pasted image 20230907105151.png]]


浮点数乘法：
设有两个浮点数 $x$, $y$, 我们浮点数的乘法规则就是：**阶码相加，小数位相乘**
同理，我们除法的规则就是**阶码相减，小数位相除**

流程总结如下：
第一步：0 操作数检查
如果被除数 x 位 0，则商位 0，如果除数 y 位 0，则商位正无穷
第二部：阶码加/减操作
浮点数乘法中，对阶码的运算总共只有四种，对阶码的运算时检查结果是否溢出。
第三步：尾数乘除操作

第四步：结果规格化

第五步：舍入处理
第一种：无条件丢掉正常尾数最低为之后的全部数值
第二种：保留右移种溢出的若干高位的值，最后再按某种规则用这些位上的值修正原尾数。尾数用**原码**表示时，我们只要尾数最低为位 1，或移出的几位中有为 1 的数值为，就使最低位的值为 1.

另一种 0 舍 1 入方法，当丢失的最高位的值为 1 时，我们把这个 1 加到最低为树枝上进行修正
第六步：确定积的符号

![[Pasted image 20230907110029.png]]
![[Pasted image 20230907110039.png]]
![[Pasted image 20230907110103.png]]

![[Pasted image 20230907110112.png]]


![[Pasted image 20231008111215.png]]

![[Pasted image 20231008111313.png]]
