设我们由两个浮点数 x 和 y，他们分别为 $x=2^{E_{x}}*M_{x}$
$y=2^{E_{y}}*M_{y}$。其中 $E_{x}$ 和 $E_{y}$ 为阶码，$M_{x},M_{y}$ 为尾数。

那么我们两个浮点数在进行加法和减法的运算规则就是：
![[Pasted image 20230907103323.png]]
过程分为四步
第一步：0 操作数检查
**如果判断直到 x 或 y 中有一个数位 0，那么我们就跳过后面的所有操作**

第二笔：比较阶码大小并完成对阶
**小阶变大阶**（10+100）

我们先把**小数点的位置对齐，然后再进行我们的尾数加减运算。**，首先我们求出两数阶码的差 $ΔE=E_{x}-E_{y}$,若 $E_{X}-E_{Y}$ 不等于 0 时，我们要通过尾数的移动来改变 $E_{x}$ 或 $E_{y}$，使之相等。我们规定，将我们的**尾数右移（小阶变大阶）**，以减小我们的精度损失。在对接是，总是使小阶向大阶看起，记小阶的尾数向右移位。
**阶码变大，尾数右移**

第三步：尾数进行加减运算
按照定点加减法进行，把我们的浮点数直接传入到我们的定点数加法器中即可。

第四步：结果规格化并进行舍入处理
规格化要求：
1. 典型浮点数编码，尾数规格化的要求是 $0.5\leq |M|<1$
2. IEEE 754 标准编码，尾数规格化的要求是 1. M
3. 浮点数运算**溢出的依据不是尾数**，则：
	1. 如果尾数是双符号，运算结果=01 或 10，不是浮点数运算结果溢出，而是尾数需要右规规格化
![[Pasted image 20231008105142.png]]

舍入处理：
1. 就近舍入法：保护位<0111 保留尾数
2. 朝 0 舍入法
3. 朝 $\infty$ 舍入法
4. 超 $-\infty$ 舍入法
![[Pasted image 20231008105243.png]]


五、溢出处理：
浮点数的溢出是以其**阶码溢出表现，与尾码无关**来的，在加减运算过程中要检查是否产生了溢出，若阶码正常，运算正常结束，若阶码溢出，则要处理。![[Pasted image 20230907104915.png]]



例题：浮点数运算
![[Pasted image 20230907104946.png]]
![[Pasted image 20230907105000.png]]
![[Pasted image 20230907105151.png]]


浮点数乘法：
设有两个浮点数 $x$, $y$, 我们浮点数的乘法规则就是：**阶码相加，小数位相乘**
同理，我们除法的规则就是**阶码相减，小数位相除**

流程总结如下：
第一步：0 操作数检查
如果被除数 x 位 0，则商位 0，如果除数 y 位 0，则商位正无穷
第二部：阶码加/减操作
浮点数乘法中，对阶码的运算总共只有四种，对阶码的运算时检查结果是否溢出。
第三步：尾数乘除操作

第四步：结果规格化

第五步：舍入处理
第一种：无条件丢掉正常尾数最低为之后的全部数值
第二种：保留右移种溢出的若干高位的值，最后再按某种规则用这些位上的值修正原尾数。尾数用**原码**表示时，我们只要尾数最低为位 1，或移出的几位中有为 1 的数值为，就使最低位的值为 1.

另一种 0 舍 1 入方法，当丢失的最高位的值为 1 时，我们把这个 1 加到最低为树枝上进行修正
第六步：确定积的符号

![[Pasted image 20230907110029.png]]
![[Pasted image 20230907110039.png]]
![[Pasted image 20230907110103.png]]

![[Pasted image 20230907110112.png]]


![[Pasted image 20231008111215.png]]

![[Pasted image 20231008111313.png]]
