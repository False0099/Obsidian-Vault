## 第三章运算方法和运算部件
### 数据的表示方法和转换
* 机器数正 0 负 1
    * 符号数值化的带符号二进制数，称为机器数。
* 真值: 符号位加绝对值
* 余三码: 在 8421 码的基础上，把每个编码都加上 0011
    * 当两个余三码想加不产生进位时，应从结果中减去 0011; 产生进位时，应将进位信号送入高位，本位加 0011
* 格雷码: 任何两个相邻编码只有 1 个二进制位不同，而其余 3 个二进制位相同
* 8421 码
    * 权值从高到低为 8、4、2、1
        * 算术运算时，需对运算结果进行修正。方法：如果小于、等于 (1001) 2，不需要修正；否则加 6 修正
### 带符号的二进制数据在计算机中的表示方法及加减法运算
* 原码
    * 定义
        * 最高位为符号位 0/1+数值的绝对值形式
    * 特点
        * （1）值+0，-0 的原码分别为 00000、10000，形式不唯一；
        * （2）正数的原码码值随着真值增长而增长
            *      负数的原码码值随着真值增长而减少
        * （3）n+1 位原码表示定点整数范围－(2 n－1)——2 n－1
            *      n+1 位原码表示定点小数范围 －(1－2－n)——1－2－n
    * 运算
        * 绝对值相加减，由数值大小决定运算结果符号
* 补码
    * 定义，特点和运算
        * 运算:
结果不超过机器所能表示范围时，[X+Y]补=[X]补+[Y]补
减法运算:
[X–Y]补=[X+(–Y)]补=[X]补+[–Y]补
        * 结论
            * 负数的补数＝模＋负数
            * 互为补数的绝对值相加＝模
            * 在补数中，减法运算即加法运算
        * 定义
            * 定义法，即[X]补=2·符号位+X     （MOD  2）
            * X 为正数，则符号 0+X 的绝对值；X 为负数，则 X 的绝对值取反+1。
        * 特点
            * 数值零的补码表示唯一
            * 正数补码码值随着真值增大而增大，负数补码码值随着真值增大而增大
            * n+1 位补码所表示定点整数范围－ 2 n——2 n－1，n+1 位补码所表示定点小数范围－1——1－2－n
    * 加法运算逻辑事例
        * 过程
        * 加减法运算的溢出处理
            * 溢出定义
                *  当运算结果超出机器数所能表示的范围
            * 加减中，可能产生溢出的情况
                * 可能出现溢出
                    * 同号数相加
                    * 异号数相减
                * 不可能出现溢出
                    * 异号数相加
                    * 同号数相减
            * 判断溢出的方法
                * 法一：当符号相同两数相加，结果符号和加数（或被加数）不相同，则溢出
                    * fa, fb 表示两操作数（A, B）的符号位, fs 为结果的符号位
                * 法二：任意符号相加，如果 C=Cf，则结果正确，否则溢出；
                    * C 为数值最高位的进位，Cf 为符号位的进位
                * 法三：采用双符号相加，如果 fs 1=fs 2，则结果正确，否则溢出；
                    * 运算结果的符号位为 fs 2；
                    * 多符号位的补码，叫做变形补码；
                    * 如果采用双符号位，当数为小数时，模 m=4; 当数为整数时，模 m=2 的 n+2次方
* 反码
    * 定义
        *  a.定义法，即[X]反=(2-2-n)·符号位+X   (MOD  2-2-n)
        * b.X 是正数，[X]反=[X]原；X 是负数，符号+数值取反。
    * 特点
        * 数值零的反码表示不唯一
        * 正数反码码值随着真值增大而增大，负数反码码值随着真值增大而增大
        * n+1 位反码所表示定点整数范围－ (2 n－1)——2 n－1，n+1 位反码所表示定点小数范围－(1－2－n)——1－2－n
    * 加减运算特点
        * 在机器数范围内，反码运算满足[X+Y]反=[X]反+[Y]反
，[X－Y]反=[X]反+[－Y]反
    * 反码运算在最高位有进位时，要在最低位+1，此时要多进行一次加法运算，增加了复杂性，又影响了速度，因此很少采用
    * 由于反码运算是以 2-2 的-次方为模，所以，当最高位有进位而丢掉进位 (即 2)时，要在最低位+/-1
* 移码
    * 由来及窍门
        * 为了**从码值直接判断对应真值的大小**，所以引进移码
        * [X]补的符号位取反，即得[X]移 
    * 特点
        * 最高位是符号位，1 表示正，0 表示负
        * 数据 0 有唯一的编码
        * 移码码值随着真值增大而增大
        * n+1 位移码所表示定点整数范围－ 2 n——2 n－1， n+1 位移码所表示定点小数范围－1——1－2－n
        * 计算机中，移码常用于表示阶码，故只执行加、减运算
        * 计算机中，移码运算公式需要对结果进行修正
    * 浮点数的阶码运算
        * 移码定义:[X]移=2 的 n 次方+X
        * 补码定义:[X]补=2 的 n+1 次方+Y
        * 阶码求和公式
            * [X]移+[Y]补=[X+Y]移  mod 2 的 n+1 次方
            * [X]移+[-Y]补=[X-Y]移
            * 判溢方法
                * 双符号位参加运算，最高符号位恒置 0
                * 当结果最高符号位=1 则溢出
                    * 低位符号=0，则上溢；低位符号=1，则下溢；
                *  当结果最高符号位=0 则未溢出
                    * 低位符号=0，负数；低位符号=1，正数
            * 说明: 如果阶码运算的结果溢出，上述条件不成立。此时，使用双符号位的阶码加法器，并规定移码的第二个符号位，即最高符号位恒用 0 参加加减运算，则溢出条件是结果的最高符号位为 1。此时低位符号为 0 时，表明结果上溢; 为 1 时，表明结果下溢。当最高符号位为 0 时，表明没有溢出，低位符号位为 1，表明结果为正; 为 0 时表明结果为负。
* 补，反，原，移码的相互转换
    * 反码-》原码
        * 方法：符号位不变，正数不变，负数数值部分取反。
    * 补码-》原码
        * 方法 1：正数不变，负数数值部分求反加 1。
        * 方法 2：串行转换
            * 从最后开始数，遇到第一个“1”，除第一个“1”不变，前面数字分别取反
    * 移码-》原码
        * 方法：移码转换为补码，再转换为原码
* 数据从补码和反码表示形式转换成原码
    * 自低位开始转换，从低位向高位，在遇到第一个 1 之前，保存各位的 0 不变，第一个 1 也不变，以后得各位按位取反，最后保持符号位不变，经历一遍后，即可得到补码
* 定点数和浮点数
    * 定点数
        * 小数点固定在某个位置上的数据
            * 32 位定点小数、定点整数补码的范围
                * 32 位定点小数-1～1-2-31
                *  32 位定点整数-231～231-1
    * 浮点数
        * 根据 IEEE 754 国际标准，常用的浮点数有两种格式
            * Nmax=Mmax * 2 的 Emax
Nmin=Mmin * 2 的 Emax
            * 单精度 (32 位)=8 位阶码+24 位尾数
                * 单精度浮点数 (32 位)，阶码 8 位 (含一位符号位)，尾数 24 (含一位符号位)，取值范围:-2 的 127 次方～(1-2 的-23 次方) * 2 的 127 次方
            * 双精度 (64 位)=11 位阶码+53 位尾数
                * 双精度浮点数 (64 位)，阶码 11 位 (含一位符号位)，尾数 53 位 (含一位符号位)，取值范围:-2 的 1023 次方～(1-2 的-52 次方) * 2 的 1023 次方
        * 为了保证数据精度，尾数通常用规格化形式表示: 当 R=2，且尾数值不为 0 时，其绝对值应大于或等于 (0.5) 10
            * 左规
            * 右规
        * 小数点位置可以浮动的数据。
        * 表示形式：N = M · RE
        * 计算机中存储形式
            * Ms+Es+E (n 位)+M (m 位)
                * 阶码 E，一般为整数，用补码或者移码表示；
                * 尾数 M，一般为规格化的定点小数，用补码表示；
### 二进制乘法运算
* 定点原码一位乘法
    * 两个原码数相乘，其乘积的符号为相乘两数符号的异或值，数值则为两数绝对值之积
        * [X·Y]原=[X]原·[Y]原=(X 0⊕Y 0)|(X 1 X 2.. Xn) · (Y 1 Y 2.. Yn)
    * 几点结论
        * 从低到高根据乘数每位 0、1 决定相加被乘数还是 0；
        * 相加数每次左移，最后一起求积；
        * 符号由异或决定
    * 表达式
    * 电路框架
    * 修正
        * 1. 在机器内多个数据一般不能同时相加，一次加法操作只能求出两数之和，因此每每求得一个相加数，就与上次部分积相加
        * 2. 人工计算时，相加数逐次向左偏移一位，由于最后的乘积位数是乘数 (或被乘数)的两倍，如按此算法在机器中运算，加法器也需增到两倍。观察计算过程很容易发现，在求本次部分积时，前一次部分积的最低位不再参与运算，因此可将其右移一位，相加数可直送而不必偏移，于是用 N 位加法器就可实现两个 N 位数相乘
        * 部分积右移时，乘数寄存器同时右移一位，这样可以用乘数寄存器的最低位来控制相加数 (取被乘数或零)，同时乘数寄存器的最高位可接受部分积右移出来的一位，因此，完成乘法运算后，A 寄存器中保存乘积的高位部分，乘数寄存器中保存乘积低位部分
    * 例题
    * 控制流程图
* 定点补码一位乘法
    * 表达式
    * [X·Y]补=[X]补·(－Y 0+Y 1·2-1+…. Yn·2-n)
    * 注意：此处为双符号位，当最后乘积高位为负数时，需要补充加上[-|x|]补的操作
### 二进制除法
* 加减交替法
    * 当余数为正时，商上 1，求下一位商的办法是，余数左移一位，再减去除数; 当余数为负时，商上 0，求下一位商的办法是，余数左移一位，再加上除数。此方法不用恢复余数，所以又叫不恢复余数法。但若最后一次上商为 0 而又需得到正确余数，则在这最后扔需恢复余数
### 浮点数的运算方法
* 浮点数的加减法运算
    * 1. 对阶操作
        * 求出△E，再对小的进行移位
    * 2. 尾数的加减运算
    * 3. 规格化操作
        * 规则简化是符号位和数值最高位不同，即 00.1 xxxx 或 11.0 xxxx
    * 4. 舍入
        * 超出表示范围的高位为 1 舍入
    * 5. 检查阶码是否溢出
* 浮点数的乘除法运算
    * 1.浮点数阶码运算 (移码)
        * 牢记公式
            * [X+Y]移=[X]移+[Y]补
            * [X–Y]移=[X]移+[–Y]补
    * 2. 按照一位乘或加减交替除运算
        * 先确定符号，在列式子计算
### 运算部件
* ABC 寄存器作业
* 定点运算部件
* 浮点运算部件
    * 由阶码运算部件和尾数运算部件组成
### 数据校验码
* 码距
    * 任意两个合法码之间不相同的二进制位数的最小值
        * 要具有差错能力，则码距>1
        * 合理增大码距，就能提高发现错误的能力
* 鉴定方法
    * 有无差错能力
    * 是否能合理增大码距
* 奇偶校验码
    * 能发现数据代码中一位或奇数个位出错情况的编码
    * 实现原理是使码距由 1 增加到 2
        * 步骤 1：在字节高位补充一位，即校验位
        * 步骤 2：依据图 3.10 电路形成原始数据 D 8.. D 1 的校验位值
        * 步骤 3：将 9 位数据写入主存
        * 步骤 4：读出该数据时，读取数据 D 8.. D 1 通过图 3.10 判定合法性
    * 电路图
    * 结论
        * （1）奇偶校验码只能发现一位或奇位错，且不能确定出错位置
        * （2）奇偶校验码的码距=2
* 海明校验码
    * 海明码位号和校验位位号的关系
        * Pi 的位置在 2 的 i-1 次方，但是除了最高位
    * 笔记
        * 3,5,7||3,6,7||5,6,7
    * 电路图
    * 海明码码距为 4
    * 纠一位错，查一位错
        * 2∧r≥k+r+1
    * 纠一位错，查两位错
        * 2∧(r–1)≥k+r
* 循环冗余校验码 (CRC)
    * CRC 码可以发现并纠正信息存储或传送过程中连续出现的多位错误
    * CRC 码一般是指 k 位信息码之后拼接 r 位校验码
    * 模 2 运算
        * 模 2 加减
        * 模 2 乘除
        * 异或逻辑
    * CRC 的译码与纠错
        * 更换不同的待测码字可以证明: 余数与出错位的对应关系是不变，只与码制和生成多项式有关
        * 图