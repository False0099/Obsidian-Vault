## 定点乘法器
我们进行我们的乘法器时，我们的**符号**可以用我们的被乘数与乘数的符号相异或，我们的**数值**可以用类似于**乘法竖式**的方法来得到我们的答案。
从成熟 y 的最低为开始，若这一位为“1”，则将被乘数 x 写下：若这一位为“0”，则写下全 0. 然后再去成熟 y 的高以为进行乘法运算，则规则同上。

**串行加，原码串行加法**：
我们列出乘法竖式后，**每一位结果直接计算**，没有任何优化！
       0110
    0110
  0000
1011

$p_{0}=0,p_{1}=1+0,p_{2}=F_{1}+1+1+0,p_{3}=F_{1}+F_{2}+0+1+0+0\dots$

总计需要 12 个 FA，12 个加法的时间（**画图嗯算**）

**并行加, 原码并行乘法，阵列乘法器**：
我们对我们的串行加法进行我们的算法改进：我们让我们的
我们列出乘法竖式后，每一位
       **011**0
     0**110**
  0**000**
 1**011**
$p_7 p6 p5 p4 p3 p2 p1$

我们首先 $p_{0}$ 可以直接我的，我们的 $p_{1}$ 直接将我们的第一行的高三位 $011$ 和我们第二行的第三位 $(110)$ 直接相加，得到一个四位数字 $(p_{i}p_{j}p_{k}p_{l})$,这里我们采用我们的并行加方法，然后我们的最后一位作为我们的 $p_{1}$，用我们的三个全加器，产生三个数值为和三个进位，我们直接把我们的最后一个数值为当作我们的本位，剩下的位置统一右移一位更，高位补 0，再与我们接下来下一个数字的低三位 $000$ 相加，**ALU 中进位输入就是我们上一次加产生的进位**，依次类推，每一次确定一个位置，我们**一共要确定 6 个位置**，第一位可以不用算

我们甚至可以推导出我们的公式，我们的 $p_{4}=S_{8}+C_{7},p_{5}=S_{9}+C_{8}+C_{10}$ =

如果我们是 $m*n$ **乘法阵列/阵列乘法器**，我们需要 $(m-1)*n$ 个全加器，n 个半加器，


**由阵列乘法器到带补码乘法器**
我们先把我们的补码转换为原码后再去求我们的新乘法，再去进行我们的乘法。
![[Pasted image 20230928111323.png]]
![[Pasted image 20230928111402.png]]


**原码一位乘法**：
首先，我们可以采用类似于我们的思路，根据乘数上是否位 0，来决定我们加不加我们这一位。
第一步：我们把**被乘数 B 放到寄存器中**，**A 放到我们的寄存器中**，并且用一个 **D 来存储我们单词运算的结果**
第二步：如果我们 A 的最后一位为 1，那么我们答案就在 B 寄存器的基础上加上被乘数。加的结果存到 D 寄存
第三步：我们乘数，被乘数的内容都右移一位。我们重复第二部的步骤。
第三步：**我们最后把 D 寄存器中的内容和 A 寄存器中的内容加起来，就能得到我们的乘积的数值。**
![[Pasted image 20230913095500.png]]
![[Pasted image 20230906120521.png]]

![[Pasted image 20230913095910.png]]




**原码二位乘法**：
被乘数 X 和乘数 Y 为用原码表示的纯小数，
$[x]_{原}=X_{0}X_{-1}X_{-2}\dots X_{-(n-1)}$
$[Y]_{原}=Y_{0}Y_{-1}Y_{-2}\dots Y_{-(n-1)}$
两位乘数位有四种情况 $00,01,10,11$,对应 $+0,+1|x|,2|x|,3|x|$，但是 3 在二进制中显然不是一个好的数字，所以我们应该换一种方法，来让我们的 3 消失，于是我们引入我们的欠账标记 C

我们考虑按位计算，我们用一个位 C 作为标记，我们每一位可以根据 X, Y, C 画出我们的真值表
（这里的右移是指我们的 Y 右移）![[Pasted image 20230906121252.png]]
![[Pasted image 20230906121835.png]]

**补码一位乘**：
设被乘数 x，乘数 y，均为字长位 n 位的顶点小数，且 $[Y]_{补}=y_{0}*2^0+y_{-1}2^{-1}+\dots$
![[Pasted image 20230913100233.png]]

列竖式：当我们用补码时，（**除了最后一行，其他的都要用我们的加法，只有最后一行要用减法来计算**）。

**BOOTH 法**：![[Pasted image 20230913101058.png]]
![[Pasted image 20230913101202.png]]

![[Pasted image 20230913101242.png]]

![[Pasted image 20230913101658.png]]

乘法阵列器（不带符号）：
**我们乘法的每一位都可以由我们的数学卷积运算来预先计算得出**
![[Pasted image 20230913102019.png]]




设我们由两个不带符号的二进制整数：$A=a_{m-1}a_{m-2}\dots a_{0}$, $B=b_{n-1}b_{n-2}\dots b_{0}$。在二进制乘法中，被乘数 A 与乘数 B 相乘，山城 $m+m$ 为乘积 P: $P=p_{m+n-1}\dots p_{1}p_{0}$,乘积 P 的数值为 $P=ab=\left( \sum_{i=0}^{m-1}a_{i}2^i \right)\left( \sum_{j=0}^{n-1}b_{j}2^j \right)=\sum_{k=0}^{m+n-1}p_{k}2^k$
其中，我们的 $p_{k}$ 可以通过我们的卷积来算出，$p_{k}=\sum_{i=0}^{k}a_{i}b_{k-i}$
这里的加法可以用 $m*n$ 个“与”门并行的产生。
![[Pasted image 20230906113232.png]]


**求补器**（带符号时，我们需要这么一个电路来变成我们的补码）
![[Pasted image 20230913102524.png]]

（相当于我们的 lowbit 操作给具象化）
![[Pasted image 20230906113312.png]]