## 整体：
第一步：发出我们的**中断请求**，中断源向我们的 CPU 发送我们的中断请求信号。
第二步：**中断判优**，我们的判断其器来判断我们进行哪一个程序中断，这一步我们可以通过我们的 CPU 来进行。
第三步：**处理我们的中断**，而相应中断又可以分为我们的下面几个步骤。

## 中断请求分类：
![[Pasted image 20231225192625.png]]
而为了让我们知道是哪一个中断源是给我们发送了一个中断请求，我们于是就会设置一个 `中断请求标记触发器INTR`，当他的状态为 1 时，表示我们的中断源有请求。
这些触发器可以组成我们的中断请求标记寄存器，存储在我们的 CPU 中，也可以分散到各个中断源中。
![[Pasted image 20240105223625.png]]

对于我们的外中断，CPU 在统一的时刻发出中断查询信号，以获取我们 I/O 的中断请求。也就是说，CPU 相应中断的时间，一定是在我们的每条指令结束后。而我们 CPU 会相应我们的这一个中断有下面三个条件：1. 有中断 2. CPU 允许中断 3. 优先级足够 

我们的中断判优可以通过硬件 (硬件排队器）或者软件（查询程序）的方法来实现的
## 中断处理过程：
中断处理过程=中断隐指令+中断服务程序
#### 中断隐指令
1. 先进行**关中断**（防止其他中断干扰），
2. **保存我们的断点**（记住我们当前主程序进行到哪一步，保存我们的 **PC** 的值，）
3. **找到中断服务程序**（找到我们中断服务程序的入口地址，把这个地址赋给我们的 PC）这里，我们找到我们的中断服务程序的方法有：**软件查询法**和**硬件向量法**两种办法。
硬件向量法中：我们获得方法是，先由我们的**硬件产生一个向量地址**（中断向量地址形成部件，这个向量由我们的中断请求标记寄存器决定），然后再由我们的**向量地址找到我们的入口地址**。

### 中断服务程序
1. **保存现场**（保存我们的当前状态下的 PC, 状态字寄存器，中断屏蔽寄存器等）
2. **开中断**。
3. 执行中断服务
4. 恢复现场
5. 开中断，中断返回

注：我们的单极中断和我们的多级终端之间可能存在一定的差距，
![[Pasted image 20231225193113.png]]
## 中断屏蔽计数：

## 单极中断与多级中断
当几个设备同时要求中断时，CPU 响应并处理中断，有两种方式：
**单级中断**系统是中断结构中最基本的形式。在单级中断系统中，所有的中断源都属于同一级，所有中断源触发排成一行。其优先次序是离 CPU 近的优先权高。当响应某一中断请求时，执行该中断源的中断服务程序。在此过程中。不允许其他中断源再打断中断服务子程序，即使优先权比它高的中断源也不能再打断。只有该中断服务程序执行完毕之后，才能响应其他中断；

**多级中断**,多级中断系统是指计算机系统中有相当多的中断源，根据各中断条件的轻重缓急程度不而分成若干级别，每一中断级分配给一个优先权。一般说来，优先极高的中断级可以打断优先权低的中断服务程序，以**程序嵌套方式进行工作**。（）

### 中断屏蔽
我们用一个屏蔽字来存储我们在这一个中断的情况下，我们回去执行哪些任务。
![[Pasted image 20240105231437.png]]

### 例题

例题：
![[Pasted image 20231225193532.png]]

## 中断控制器
8259 屏蔽方式：
(1)简单屏蔽方式，提供 8 位屏蔽字，每位对应着各自的 IR 线。被置位的任一位则禁止了对应 IR 线上的中断。
(2)特殊屏蔽方式，允许 CPU 让来自低优先级的外设中断请求去中断高优先级的服务程序。例如屏蔽字为 1100111，说明 IR 4 和 IR 5 线上的中断请求可中断任何高级别的中断服务程序。

8259 优先级选择方式：
(1)完全嵌套方式：是一种固定优先级方式，连至 IR O 的设备优先级最高，IR 7 的优先级最低。这种固定优先级方式对级别低的中断不利，在有些情况下最低级别的中断请求可能一直不能被处理。

(2)轮换优先级方式 A：每个级别的中断保证有机会被处理，将给定的中断级别处理完后，立即把它放到最低级别的位置上去。

(3)轮换优先级方式 B：要求 CPU 可在任何时间规定最优优先级，然后顺序地规定其他 IR 线上的优先级。

(4)查询方式：由 CPU 访问 8259 的中断状态寄存器，一个状态字能表示出正在请求中断的最高优先级 IR 线，并能表示出中断请求是否有效。

## 中断机制
### 相关概念
中断服务子程序：中断发生的时候，要执行的代码；中断向量号/类型号：X 86 系统有 256 个中断，每个中断有一个 8 位无符号整数表示的编号，类型号：0-255;

中断向量：1 个逻辑地址，中断服务子程序的入口逻辑地址；共 256 个中断向量；

中断向量表：保存 256 个中断向量的表； ·实模式中是 IVT 表，保护模式中是 IDT 表。

断点：中断发生时，当前 cs: ip 取值 (1 个逻辑地址);

现场：中断发生时，标志寄存器的取值；

CS: IP, 逻辑地址，指向 cpu 要执行的下 1 条指令；

SS: SP, 栈顶指针；

### 处理过程：
(1)保护现场：标志寄存器 EFLAGS 的内容压入堆栈。
(2)保护断点：CS: IP 逻辑地址压入此堆栈。
(3)跳转 1：计算中断子程序的保存位置，将获取的保存位置传递给 CS：IP,修改 CPU 的执行流程进入中断子程序。
(4)在中断子程序中，根据需要修改设置 TF 和 IF 标志位，以及保护 CPU 中寄存器。
(5)跳转 2：执行中断子程序，直到执行中断返回指令 iret，恢复断点，恢复现场，修改 cpu 的执行流程进入主程序继续执行。
