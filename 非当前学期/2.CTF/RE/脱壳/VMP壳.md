CTF 中更常见的加密技术是算法加密。算法加密更偏重算法的混淆、模糊与隐藏，其中最常见的方式便是虚拟机保护。

所谓的虚拟机保护，就是自己手搓一个指令集，然后让我们的程序用我们手搓的指令集下进行执行，从而达到混淆我们的代码的目的。

虚拟机 (Virtual Machine, VM) 保护的大范围使用最早出现在加密壳软件中，是一些加密壳的最强保护手段，其中最具代表性的是 VMProtect。VMProtect 除了提供常规的数据加密、代码加密和其他反调试等功能，还能在汇编指令层面对程序逻辑进行虚拟化，将开发者指定的代码段中所有的汇编指令转变为自行编写的一套指令集中的指令，并在实际执行时由自行编写的虚拟机执行器进行模拟执行。注意，这与 VMWare 等虚拟机程序并非同一个概念。VMWare 等虚拟机程序规模更加庞大，目的是虚拟出一整套硬件设备，从而支持操作系统等软件的运行，而虚拟机保护壳规模相对较小，目的是尽可能地对原始程序代码、算法逻辑进行混淆、模糊和隐藏。

基于虚拟机保护的加密壳发展至今，已经能达到极其复杂的加密混淆效果，要对保护过后的程序进行还原已经变得极其困难，并且将耗费大量时间。

在 CTF 中，我们经常看到的 VM 实际上是简化、抽象后的，一般不会针对 x86、x64等真实 CPU 的汇编指令进行虚拟化。一般，出题人会针题目中的校验算法设计一套精简的指令集。例如，要实现一个移位密码可能需要用到加、模等运算，于是便可以设计一个包含加、模等运算指令的指令集，将校验算法用自己设计的指令集中的指令实现，再将其汇编为该指令集的机器码（俗称虚拟字节码），最后将这些字节码交给编写好的虚拟 CPU 执行函数进行执行。

## 思路：
要对这类题目进行逆向，我们可以对其虚拟 CPU 执行函数进行逆向，还原出该虚拟架构的指令集，然后编写反汇编代码对虚拟字节码进行反汇编，最后根据反汇编的结果，分析题目真正的校验算法，获得 flag。（也就是我们要人工去进行我们的反汇编工作）




