## 什么是壳
壳是一种特殊的程序，对另一个程序进行变换后，利用变换的结果重新生成可执行文件。在运行的时候，它全部或部分还原存储在可执行文件中的变换结果，然后恢复源程序的执行。

## UPX壳的原理
用了一个壳就相当于把我们原来的程序分成了两端。然后我们会通过一个执行代码来吧我们的程序分成两个。

我们在启动进程后，会申请内存，内部包含一个空节
第一步：映射头
第二步：我们把解压缩代码和压缩数据映射进内存
第三步，把各种表进行处理
第四步，运行压缩代码，跑压缩数据
第五步，还原数据，填充
第六步，执行完解压缩代码后，跑到节区 1 去执行原来的功能
![[Pasted image 20231216204448.png]]

## 查壳
我们可以用我们的 `DiE` 来查找我们的文件是否含有我们的壳。我们的特征是，用我们的 `IDA` 打开的时候，会出现一大串乱七八糟的东西。
## 怎么去壳
我们 CTF 中使用最多的一般是我们的 `UPX` 壳，我们脱去 `UPX` 壳的两种方法：
第一种：静态方法，UPX 本身提供脱壳器，使用命令行参数-d 即可，但是有时候会失败，需要我们切换使用正确的 `UPX` 版本。

我们可以去我们的 github 上下载我们的 `upx`,然后用我们的对应指令进行直接的脱壳即可。

（这种方法使用的场景要求我们的壳不会被乱改（））

第二种：修改方法
首先，如果是简单的被乱盖的情况，比如只是修改了我们的区段名，把 UPX 改成了 1 PX, 那么我们直接改回来就行了。
![[Pasted image 20231216205155.png]]

第三种：动态调式脱壳（有一个接受字符串的函数）
原理：一般加壳程序在运行时，会先执行壳代码，然后在内存中恢复还原原程序，再跳转回原始 `OEP`，执行原程序的代码，我们可以把壳代码理解为一个大的函数，既然是函数，那么进入函数和退出函数时，堆栈应该就是平衡的，基于这样的一种特性，我们可以在壳代码操作了堆栈之后，对堆栈设置访问断点，然后让程序跑起来，当程序暂停的时候，就是壳代码即将执行完的时候，然后在其附近单步跟踪，就可以找到原始 OEP 了。这种方法比较适用于 upx 这种只对代码和数据压缩了的壳，如果还对代码加密了，那么就不是太好找了。加密的话就需要结合单步跟踪法。

动态脱壳需要我们找到我们的原始程序的入口点的位置在哪里，这一步就是我们的找 `OEP` (原始程序入口地址)，然后我们下一次就可以在这里设置一个 `硬件` 端点，

第一步：固定我们的基质，然后另存为我们的另一个文件
![[Pasted image 20231216213305.png]]

第二部：我们用我们的 `x64dbg` 来进行我们的动态操作，操作我们的新程序，
![[Pasted image 20231216205345.png]]

第三步：我们直接运行我们的程序，再让我们输入的时候，进行一个断点。
![[Pasted image 20231216213420.png]]
第四步：我们不停的利用我们的调用上一级功能，就能找到我们加壳函数的 `main` 函数，`main` 的特征如下所示：
![[Pasted image 20231216213533.png]]

第五步：我们要找到谁调用了我们的 `main`,这里我们就可以用我们的查找引用
![[Pasted image 20231216213733.png]]

第六步：跳转到对应的地址后，我们可以对我们的地址进行一个标记，
![[Pasted image 20231216213825.png]]

第七步：继续向上看，我们找到一个有大跳 `jump` 的引用，这个地址就是我们对应的 `OPE` 的地址，
![[Pasted image 20231216214011.png]]

第八步：我们用我们的 `x86debug` 来进行我们的 `dump`,
![[Pasted image 20231216214104.png]]
此时我们 dump 出来的程序还不能运行，我们

第九步：我们点击我们的自动搜索：![[Pasted image 20231216214206.png]]
第十步：我们点击我们的自动搜索，获取导入，![[Pasted image 20231216214259.png]]
第十一部：我们把我们带叉的删除后，转储后，再修复，然后我们就能运行我们脱壳后的程序。

