## 简介
TEA 算法是一种快速算法，主要思想是：一次性加密多个比特的数据，然后再采用迭代的形式，迭代一定的轮数，就能得到我们的答案。（**int级别）

## 需要的参数：
1. 输入字符，（分割成若干个 2 倍 int 数组）
2. Key 秘钥数组（长度为 4）
3. TEA 加密

## 加密算法：
第一步，我们把我们的原来的输入数据分为若干组，每一组中只包含 `2 个 int` 的数据。

第二步：我们使用一个秘钥，key，key 应当包含 4 个数字，这四个数字就是我们加密的工具。

第三步：我们添加一个常数 delta，作为我们的加密常数，每一次加密，都根据我们的这个加密常数生成一系列的数字用于辅助我们的加密。

第四步：我们将处理完的结果赋给我们的原函数。

综上，我们就完成了 2 个 int 的处理，我们如果需要继续处理，我们就需要接着去计算。

如果是一个字符串的话，我们就会把这个字符串先转为 int，然后再去处理。

```cpp
void encrypt (uint32_t* v, uint32_t* k) {
    uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */
    uint32_t delta=0x9e3779b9;                     /* a key schedule constant */
    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */
    for (i=0; i < 32; i++) {                       /* basic cycle start */
        sum += delta;
        v0 += ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);
        v1 += ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3);  
    }                                              /* end cycle */
    v[0]=v0; v[1]=v1;
}
```

## 解密算法：
我们对于我们的 TEA 类的解密，我们的思路是：在保留我们的原来的基础上，按照反着的顺序。

第一步：确定我们的 sum 值应该是多少（这个和我们的轮数有关）

第二步：**把我们的加密函数反着写**，从而让我们能够拿到答案。
假设我们是先写 sum, v 1, v 0, 那么我们就按照 v 0, v 1, sum 的顺序处理即可。

```cpp
void encrypt(uint32_t *v,uint32_t* k){

    uint32_t sum=0;

    uint32_t v0=v[0],v1=v[1];

    uint32_t delta=0x9e3779b9//Delta常数

    uint32_t k0=k[0],k1=k[1],k2=k[2],k3=k[3];

    for(int i=0;i<32;i++){

        v1-=((v0<<4)+k2)^(v0+sum)^((v0>>5)+k3);
         v0-=((v1<<4)+k0)^(v1+sum)^((v1>>5)+k1);
        sum-=delta;
    }

    v[0]=v0;

    v[1]=v1;

}
```

## 识别特征
1. 标准 DELTA 常数
2. 秘钥为 16 字节
3. 加密轮数为 16/32/64 位
4. 加密结构中存在左四有五移位以及异或
5. 加密中存在轮家，

## 魔改方式：
1. 修改 DELTA 常数
2. 修改轮数
3. 修改轮加/减魔数的位置