`AES` 是一种分组加密算法，假设我们的明文加密长度是 128 位，那么我们的密钥长度可以是我们的 128，192，256 位

我们的 AES 分为若干种加密模式，比如我们的密钥长度，加密模式，填充模式。![[Pasted image 20231217192341.png]]
## 密钥长度
例如：在我们的 AES 128 模式下，我们要求我们的明文长度必须固定为 16 个字节（4 行 4 列），超过的部分会被溢出。在我们的 `AES 192` 中，我们要求我们的明文长度必须固定为 24 字节（4 行 6 列），在 ``AES256`` 中，我们要求我们的明文长度必须是我们的 32 个字节，分 4 行 8 列

## 加密模式
我们主要讲解我们的 ECD 模式

## 填充模式
在我们的用户给定数据不满足我们的 16 倍数的情况下，我们怎么处理我们的不足的字符，
![[Pasted image 20231217192745.png]]
注意：**哪怕我们已经是 16 的倍数，我们除非是 NONE, 其他情况下都要继续进行填充**。

## 加密流程
第一步：对我们的明文进行填充

第二步：对我们的明文进行分组，每 16 个一组

第三步：把我们每一组的数据都丢入我们的加密器进行加密，其中需要我们对于每一组数据都提供一个轮密钥

第四步：对我们的每一组密文进行合并即可。

![[Pasted image 20231217193100.png]]

## 加密器

![[Pasted image 20231217193119.png]]


## 排列方式
![[Pasted image 20231217193225.png]]

## 密钥扩展
第一步：计算我们需要的轮密钥的长度，我们的长度就是我们（执行混淆的次数+1）* （16），并且计算我们的 `nk` 值。也就是我们密钥的列数。（16/4=4,24/4=6.32/4=8）

第二步：根据我们的不同情况按列顺序依次计算我们的密钥
#### 如果我们当前列 % nk = 0

公式：$[当前列-nk 值]\oplus 轮常量(字节代换(列位移([当前列-1])))$

第一步：找到我们当前列的前一列是哪一列，![[Pasted image 20231217193851.png]]
第二步：把我们这一列的数据全都循环上移一位 ![[Pasted image 20231217193927.png]]
第三步：我们用我们的字节代换表把我们的数据进行代换。

![[Pasted image 20231217193954.png]]
![[Pasted image 20231217194007.png]]

第四步：当前我们进行的是哪一轮，就和我们轮常量表中的对应数字进行异或，以 `AES128` 为例，我们假设现在是第四列，那么我们要异或的值就是我们的表的 $\dfrac{列}{4}$ 个数值。
![[Pasted image 20231217194126.png]]

![[Pasted image 20231217194309.png]]

第五步：用我们上一步的结果再和我们的 $当前列-nk值$ 对应元素进行异或，
![[Pasted image 20231217194411.png]]

#### 如果我们当前列%nk 值!=0 且当前列%4=0 (只有 `AES256`) 
第一步：找到我们当前列的上一列是多少
![[Pasted image 20231217194831.png]]
第二步：找到我们的 $当前列-nk$ 列的值是多少，
![[Pasted image 20231217194936.png]]
第三步：对我们上一列的值进行我们的字节代换，代换表如下：
![[Pasted image 20231217193954.png]]

第四步：用我们代换后的结果和我们的 $当前列-nk$ 列的数值进行异或。
![[Pasted image 20231217195120.png]]

#### 其他情况
第一步：求出我们当前列-1 是哪里
![[Pasted image 20231217195216.png]]
第二部：求出我们 $当前列-nk列$ 是哪里
![[Pasted image 20231217195209.png]]
第三步：这两列直接异或得到我们的结果
![[Pasted image 20231217195223.png]]


## 轮密钥加
我们对我们的输入数组（16bit）和我们的轮密钥的 16 个字节依次进行异或操作
![[Pasted image 20231217195505.png]]
关键在于我们的轮密钥的选择  ：我们每一次选择 4 列，并且不重复使用。
![[Pasted image 20231217195559.png]]

## 字节代换
利用我们的字节代换表，把我们的数字进行直接替换而已。
![[Pasted image 20231217195727.png]]
![[Pasted image 20231217195735.png]]

## 行位移
第一行不变，第二行向左循环 1 字节，第三行向左循环 2 字节，第四行向左循环 3 字节
![[Pasted image 20231217195758.png]]

## 列混淆
在 $GF(2^8)$ 下对列混淆左乘矩阵的行与当前字节的列进行矩阵乘法

$GF(2^8)$ 下的加法：异或操作

$GF(2^8)$ 下的乘法：定义一个函数 $f(a)$,如果 $a<0x80$,那么我们返回 $2*a$,否则返回 $(2*a)\text{mod 0x100}$

那么我们两个数的乘法就可以定义如下：如果我们乘法操作其中一个数是 2 的 $N$ 次方，那么我们可以套用下面的公式：
$\text{0x01}\times b=b$
$\text{0x02}\times b=f(b)$
$\text{0x04}\times b=f(f(b))$

如果一个数不是 $2$ 的 $N$ 次方，那么我们就可以拆分后相加（异或）
$\text{0x0D}\times a=\text{0x08}\times a\oplus \text{0x04}\times a\oplus \text{0x01}\times a$


列混淆做成矩阵如下：
![[Pasted image 20231217195955.png]]

![[Pasted image 20231217200211.png]]
假如我们有一个第一行第一列的数据，那么我们就要选择到我们的列混淆矩阵的 ![[Pasted image 20231217200105.png]]
然后我们选择我们的第一列的四个数字，对应乘：
![[Pasted image 20231217200203.png]]

![[Pasted image 20231217200834.png]]
![[Pasted image 20231217200848.png]]


## 解密操作
![[Pasted image 20231217201045.png]]
![[Pasted image 20231217201125.png]]
