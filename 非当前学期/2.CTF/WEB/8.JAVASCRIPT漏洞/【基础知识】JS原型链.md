在我们的 js 当中，我们的对象，虽然可以 new 出来，但是我们的 new 的过程和我们的对应的认知不太对。
```js
function Foo(){...};
let f1=new Foo();
```

上面的代码表示创建一个构造函数 Foo (), 并且通过我们的 new 关键字实例化该构造函数得到一个实例对象 $f_{1}$,

在这里，我们的 new 操作符将**函数作为构造器**进行调用时的过程如下所示：
1. 函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的 this 是只想该新创建的对象，这意味着我们可以再构造器函数内部通过 this 参数初始化值），最后范围该信对象的引用。

## 原型链：
1. `__proto__和constructor` 属性是对象所独有的
2. `prototype` 属性是函数独有的。

但是因为 JS 中函数也是一种对象，所以函数也拥有 `__proto__` 和 `constructor` 属性。

我们的上面的三种属性分别如下所示：
在我们的 proto 属性，由一个对象指向另一个对象，相当于我们的**类继承**中，指向了我们的**父类**，也就是我们的**原型对象**。在我们有这个之后，我们类似于我们的类继承，我们定义一个 `person: eat sleep`, `man:smoke`, `woman:shop`。

我们的原型链，是在于我们的**调用方法的时候**，如果我们的当前类没有对应的实现，那么我们就会**沿着我们的原型链去一步一步寻找**。找到我们的对应的元素。这种通过我们的 `__proto__` 的就叫做我们的原型链。

我们的 `prototype` 就表示我们的函数的原型对象，这个是针对于我们的函数的，这个内容，是从一个函数指向一个对象，它的含义是**函数的原型对象**，也就是这个函数所创建的实例的原型对象，因此，我们可以知道：
```
f1.__proto__===Foo.prototype
```

这一个属性的作用是包含特定类型的所有实例所包括的方法，也就是让该函数实例化的对象**都可以找到公用的属性和方法**。

`constructor`,这个是我们的一个对象菜拥有的，他从一个对象指向一个函数，含义就是**指向该对象的构造函数**，每个对象都有构造函数，其中 `Function` 这个对象比较特殊，它的构造函数就是他自己。所有函数和对象都是最终由 Function 构造函数得来的。

每一个对象都可以找到其对应的 `constructor`,因为创建对象的前提是需要有 `constructor`,而这个 `constructor` 可能是对象自己本身显式定义的或者再原型链中找到的。

## 类构造与 proto
我们再哦我们的原本的当中，有下面的几种可能的构造方法：
方法一：
```js
f1={firstname:'111'};
```
这一种方法构造的对象，我们的 f 1 对象的原型链，**直接指向我们的**`object`。于是，我们就初步搞清楚了我们的每一个内容对应的信息。

