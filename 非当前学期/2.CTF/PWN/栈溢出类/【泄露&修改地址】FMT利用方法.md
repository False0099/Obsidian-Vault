1. 让程序崩溃 `%s`,
```cpp
printf("%s %s %s %s %s %s")
```

2. 泄露栈上内容 `%p(栈上数据当作指针),%x`
我们可以用我们的这个来找到我们的 `canary` 的值，然后我们就可以来进行我们的栈溢出漏洞！
```cpp
printf("%p %p %p %p %p %p")
```

3. 通过修改截断符来泄露 `%s`
我们在实际使用中，可以修改我们的 `0x00` 来让我们的字符串对应长度变长。


4. 我们通过我们的内容，来修改我们人一地址的内存：
原理：我们的格式化字符串并不会凭空消失，而是会被我们存储在我们的栈上的某一个地址，然后我们就可以通过我们的特定的格式化字符串，来获取我们的地址。
![[Pasted image 20231208203832.png]]
我们就会先打印我们的


5. 找到我们的栈中地址对应的内容 `%s`，例如：如果我们的栈中有一段 `read@got`,那么我们就可以用我们的 `%s` 来把我们的 `read` 的 `got` 表内容直接获得。于是，我们的 `%s` 就可以获得我们的任何地址的内存

```cpp
printf("%100$p")//获取我们的第100个参数的值
```

方法：
1. 找到我们的字符串存放地址和我们的第一个参数之间的距离是多少
2. 我们构造出下面的这一段话：`printf("%[dist]$p"`,

6. 任意修改 `%n`,向我们的对应地址中的内容写入之前已经打印成功的字符个数 ![[Pasted image 20231208204831.png]]