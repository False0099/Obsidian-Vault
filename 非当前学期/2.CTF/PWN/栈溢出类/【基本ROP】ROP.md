ROP，就是将我们的各个代码片段拼合在一起，然后利用我们系统的中断机制，统一执行最后目的是为了执行我们的 `exev`。
我们这一个的方法就是利用我们的栈：
我们的操作就是先把我们的栈溢出，把我们的溢出地址设置到我们的一个完整的代码片段，溢出更多的内容。以实现我们的攻击
![[Pasted image 20231129194333.png]]

其中，我们的 stack 中填写的文件段，可以用我们的 `ROPGADGET` 软件来获得。![[Pasted image 20231129194552.png]]
获取的代码段内容：
![[Pasted image 20231129194609.png]]

![[Pasted image 20231129194809.png]]

当我们有了一个 `pop-ret` 段的时候

第一步: 我们的栈溢出产生的 `ret` 执行，我们 EIP 的值变为我们栈顶所写入的值（这个值就是我们写入的一个 `Gadget`）
![[Pasted image 20231129195116.png]]

第二步：我们执行我们 `EIP` 中的 `POP %edx` 指令，我们的 ` Edx ` 就变成了我们的栈中的第一个元素，也就是我们栈溢出时写入的 value，执行完成后，我们的栈顶指针 `esp` 也会对应的++。
![[Pasted image 20231129195305.png]]

第三步：我们的执行 `EIP` 中的 `ret`,在这里，我们的 `ret` 指令指令，可以理解为我们的 `pop eip`,也就是把我们的栈顶指针赋给我们的 EIP，我们的 ` ESP ` 向上移动，又得到了我们的新的指令，并且把我们的 ` ESP ` 中的地址付给我们的 ` EIP `，这就跳转逃了我们的下一个 ` GADGET `

第四步：我们进行我们的操作，清空我们的 `EAX`,然后把我们的 `esp` 的内容付给我们的

![[Pasted image 20231129201520.png]]
于是我们的调用 shell，就可以由：给 `eax` 赋值，给 `ebx` 赋值，给 `ecx` 赋值，
比如说上面的程序中，我们执行 `pop_eax_ret`,就会把我们的 `0xb` 付给我们的 `eax`,然后我们的 `ret`,就是为了**回到我们的栈上获取我们的执行地址**。又把我们的 `pop_ebx_ret` 的指令地址放入到我们的 `eip` 中, 接着执行我们的 `pop_ebx_ret` 中。
就相当于

