我们的栈溢出的基本原理在于：**理解我们的函数调用构成**，我们的函数中，我们会由下面的东西组成：
1. 上一个函数的栈底（leave）
2. 上一个函数的 rip 指针应该指向的位置。（ret）

我们的调用函数会把我们的**rip 压栈**，这一个部分被**隐含在我们的 call 指令**。而我们的被调用函数，会把我们的**前一个的 rbp 压入我们的栈中**，我们会把我们的一些局部数据或者我们的局部变量存储在我们的**栈当中**。

那么，如果存储在战中**局部变量边界检查不严格造成越界写**，造成用户输入覆盖到缓冲区外的数据内容。由于栈中同时存在与函数调用相关的信息，栈溢出**可以导致控制流劫持**。

例如：
```
void func_a(){
	char buf[80];
	read(0,buf,200);
	return;
}
int main(){
	func_a();
}
```

我们的 buf 长度因为我们只有一个变量，所以我们的长度就固定为 80，紧邻 b 函数指针的 rbp 地址和返回地址。

这个时候，如果我们读入的元素恰好为 80，那么我们是刚好的，但是如果我们超过了，**因为我们的地址是由我们的高地址向低地址增长**，我们就会**覆盖我们的高地址，也就是我们的栈底的数据**。

这个时候，如果我们让我们的程序读入我们的下面的数据：`80'a'+AAAAAAAA+BBBBBBBB`,最后我们可以发现，我们的母函数的 RBP 就已经被覆盖为 AAAAAAAA，我们的 RIP 被覆盖为了 BBBBBBBB。

这个时候，如果我们的程序返回，程序会返回一个**异常错误**。**target addrs 是我们想要程序跳转到的地方**。这时候，程序的执行流就被我们控制了。这是因为，我们向控制程序的走向，其实也就是**控制我们的 RIP 指针**。而在我们的一般的情况下，我们的 rbp 是不需要去构造的，一般的 rop 时不需要考虑我们的 rbp 的

## 总结：
我们的栈溢出的原理就是栈中存储的局部变量数组发生溢出，覆盖了栈中的其他数据。将返回地址覆盖为我们期望的目标地址，就可以劫持我们的控制流。

