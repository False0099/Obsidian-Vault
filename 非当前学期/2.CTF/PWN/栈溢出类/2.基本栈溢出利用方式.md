我们对于我们的栈溢出我们的思考在于下面的几个点：
1. 我们返回到什么地址？
## 返回到哪里：
在我们的 CTF 中的 PWN，多数情况下，我们希望我们的程序可以执行下面的代码：
```
system("/bin/sh")
```
执行上面的代码，也就是在我们的远程机器上开一个命令行中端。这样我们就可以通过命令行来控制目标机器。通常来说，我们的 CTF 中只需要开启命令行后读 flag 即可。

### 返回到后门函数 (ret2tex)
假设我们在我们的文本中存在一个这样的函数：
```
void back_door(){
	system("/bin/sh)
}
```

那么这个时候，我们就很好处理，我们直接让我们的**返回地址等于我们的后门函数**我们就可以完成我们的函数调用来。这个时候，我们就相当于实现了我们的后门函数跳转。

### 返回到系统调用：
有些时候，我们**需要调用一些系统函数，比如说 system,puts**，但是我们程序中没有直接写好的 `system('/bin/sh')`。这个时候，我们应该怎么办呢？

这个时候，我们如果**拿到了 libc 中函数的地址**，我们就可以直接调用 libc 中的函数。只需要**传递好参数**，然后再去 call 即可。

我们知道，在我们的**64 位中**，我们的函数调用是需要通过我们的**寄存器来存储参数的**。这个时候，我们就需要通过我们的一个 `pop rdi return` 来执行我们的对应的参数。

我们考虑下面形式的溢出方式：`pop rdi ret +参数1+pop rdi ret +参数2...+system` 这个时候，我们一般的结果如下所示：
```
io.recvuntil('execv:')
execv_addr=io.recv(14)
execv_addr=int(execv_addr,16)
payload=b'a'*80+p64(0x0721)+p64(pop_ret)
payload=p64(参数一)+p64(pop_ret)+p64(参数2)+p64(参数3)+p64(执行)
```

当然，关于我们怎么样获取我们的**内存地址**就是我们额内存泄露的问题了，而不是我们的现在的问题了。