我们如果没有条件，我们也得要创造条件，我们可以通过**修改我们的栈位置来等价于修改我们的溢出数量**。

我们虽然**原来的修改位置不够，但是我们的中间的大量位置是空缺的**，我们如果能**重新让我们的栈迁移到我们的某一个位置**，让我们的之前的脏数据产生作用，那么我们是不是就可以利用到我们的更多的空间。

我们通过我们不断的**pop ret**就可以一边控制我们的 rsp 的栈向上移动，一边可以让我们的对应的元素移除到指定的位置。等到我们可以 ret 的时候，我们就可以

这个技巧就是我们的**栈迁移**，我们只要控制我们的 rsp 一直在我们可控制内容的区域，就可以完成我们的 rop。那么我们如何能够控制我们的 esp 。

我们如果有我们的指令形如：`mov rsp rax` 或者我们的 `pop rsp,ret`，那么我们的**移动 rsp 指针的方式就很简单可以实现**。但是我们显然没有这种指令。

我们于是就想**怎么样能够修改我们的 rsp**指令。我们可以利用我们的 `leave` 指令，我们的这一条指令的作用是，让我们的 `mov rsp rbp;pop rbp` 用于我们恢复栈帧。

也就是说，我们控制了我们的 rbp 指针的值，我们就可以来控制我们的对应的 rsp。其中我们的**rbp**的值是可以被我们**覆盖的**。

##### 方法一：
```
pop rbp return;
target addr;
leave ret
```

我们的 leave-ret 的指令的**实际效果就是把我们的 rbp 的值赋给我们的 rsp**。因此，我们可以通过我们的 rbp 来控制。因此我们可以考虑用我们的 `pop rbp ret` 来控制我们的 rbp，之后再去控制我们的其他元素。

我们计算一下这个时候我们溢出的总字节，一共只需要 32 字节，之后我们就可以把我们的栈转移到我们的目标地址上继续执行 rop。

#### 方法二：
```
target stack address
leave ret
leave ret
```
我们这一种方法与我们的方法与我们的上一种方法大同小异，但是我们需要把我们的**栈上保存的 rbp 改成迁移的地址**。程序在第一次执行 `leave ret` 时，会将 `rbp` 搞到目标迁移地址上。再次执行 leaveret 时，效果就和之前一样了。

我们的执行执行如下：
第一个 leave-ret 执行后，我们的 rbp->target, rsp->原 rbp
第二个 leave 执行后，我们的 rbp->不知道哪里, rsp->target_addr
第二个 ret 执行后，我们的 rip->target_addr+8 的指令。

这一种情况下，我们只需要**我们的 16 个字节**即可完成我们的任务

## 确定位置：
我们如果我们确定**只能在我们的栈上进行操作的话，那么我们就要确定我们的输入位置和我们的栈的插值**。

这个时候，我们如果想要知道我们的 `target_Addr` 是什么，我们就应该知道，我们的这个 `target_addr` 应该满足什么样的性质。首先我们要明确的一点是，我们这个 target_addr 一定要是一个可写可执行的段，我们于是考虑在我们的栈上进行我们的上述的操作。

我们就以**这一个函数栈作为我们的起点**，那么我们的这个的终止位置和我们的**栈**的偏移时固定的 28 个字节，这个我们可以从我们的 ida 看出。

但是这个时候我们通过我们的**字符串溢出得到的数据是我们的这一个栈帧的调用者的 ebp**。因此，我们还需要得到我们的俩个者之间的偏移量，然后**才能计算得到我们的当前的 ebp 是多少**。

这一点，显然我们需要通过我们的 IDA 来观看我们的两者之间的 dx 是多少，或者通过我们的 gdb 动态调试观察得到。于是终于，我们就可以用我们的上面的结果去作为我们的函数的嗲用。