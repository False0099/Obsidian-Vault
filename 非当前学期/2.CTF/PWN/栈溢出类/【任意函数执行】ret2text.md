## 原理：
当函数正在执行内部指令的过程中，我们无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就 `eip`（PC）,所以我们的目标就是让 `eip` **载入攻击指令的地址**。

我们思考，如果要让 `eip` 指向攻击指令，我们的一个思想，就是在退栈的过程中，**让溢出数据用攻击指令的地址覆盖返回地址**就可以了。其次，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。
```cpp
```text
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdint.h>

#define PTR_SIZE 8   // 指针的大小
#define EBP_SIZE 8   // ebp寄存器的大小

void inject_callback()
{
    printf("inject_callback called...\n");
    exit(0);
}

void func_call(char *addr, int len)
{
    char tmpBuf[16] = {0xff};

    memcpy(tmpBuf + 16 + EBP_SIZE, addr, len);

    printf("func_call called...\n");
}

int main(int argc, char** argv)
{
    uint64_t injectPtr = (uint64_t)&inject_callback;//给了我们函数的地址

    func_call(&injectPtr, PTR_SIZE);//我们直接把这个函数地址的指针写进去

    printf("main exited...\n");

    return 0;
}
```
从上图可以看出，`func_call()` 函数在调用 `memcpy()` 函数复制数据时，由于不小心用 `inject_callback()` 函数的地址覆盖了返回地址，导致 `func_call()` 函数执行完毕后，跳转到 `inject_callback()` 函数处执行。

这就是 `栈溢出攻击` 的原理，而导致 `栈溢出攻击` 的原因就是：调用 `memcpy()`、`strcpy()` 等函数复制数据时，没有对数据的长度进行验证，从而 `返回地址` 被复制的数据覆盖了。

缓冲区溢出：本质是向定长的缓冲区中写入了超长的数据，造成超出的数据覆写了合法内存区域。



![[Pasted image 20231121221256.png]]
![[Pasted image 20231121222110.png]]

![[Pasted image 20231122194817.png]]
当我们发生一个栈溢出时，可能会有下面的几种情况：
1、淹没了其他的局部变量。如果被淹没的局部变量是条件变量，那么可能会改变函数原本的执行流程。这种方式可以用于破解简单的软件验证。
2、淹没了ebp的值。修改了函数执行结束后**要恢复的栈指针**，将会导致栈帧失去平衡。
3、淹没了返回地址。这是栈溢出原理的核心所在，通过淹没的方式修改函数的返回地址，使程序代码执行“意外”的流程！
4、淹没参数变量。修改函数的参数变量也可能改变当前函数的执行结果和流程。
5、淹没上级函数的栈帧，情况与上述4点类似，只不过影响的是上级函数的执行。当然这里的前提是保证函数能正常返回，即函数地址不能被随意修改（这可能很麻烦！）。

如果在 data 本身的数据内就保存了一系列的指令的二进制代码，一旦栈溢出修改了函数的返回地址，并将该地址指向这段二进制代码的其实位置，那么就完成了基本的溢出攻击行为。

但事实上，我们不可能通过直接的淹没来实现我们的栈溢出攻击，因为这样的攻击是不可靠的，操作系统每次加载可执行文件到进程空间的位置都是无法预测的，因此栈的位置实际是不固定的，因此，我们需要借助一个跳板来进行我们的栈溢出操作。

根据前边所述，函数执行后，栈指针 esp 会恢复到压入参数时的状态，在图4中即 data 参数的地址。如果我们在函数的返回地址填入一个地址，该地址指向的内存保存了一条特殊的指令 jmp esp——跳板。那么函数返回后，会执行该指令并跳转到 esp 所在的位置——即 data 的位置。我们可以将缓冲区再多溢出一部分，淹没 data 这样的函数参数，并在这里放上我们想要执行的代码！这样，不管程序被加载到哪个位置，最终都会回来执行栈内的代码。

那么，我们怎么样才能得到我们的跳板呢？幸运的是，再 windows 操作系统加载的大量 dll 中，包含了许多这样的跳板，并且我们加载 dll 时候一般都是固定地址，因此这些 dll 内的跳板指令的地址一般都是固定的。我们可以离线搜索出跳板执行再 dll 内的偏移，并加上 dll 的加载地址。
```cpp
int findJmp(char*dll_name)  
{  
    char* handle=(char*)LoadLibraryA(dll_name);//获取dll加载地址  
    for(int pos=0;;pos++)//遍历dll代码空间  
    {  
        if(handle[pos]==(char)0xff&&handle[pos+1]==(char)0xe4)//寻找0xffe4 = jmp  esp  
        {  
            return (int)(handle+pos);  
        }  
    }  
}
```