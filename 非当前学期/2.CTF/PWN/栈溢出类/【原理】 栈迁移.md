我们的所谓栈迁移，就是来修改我们的 rsp 指针和我们的 rbp 指针的位置，从而使得我们的。

正常来说，我们的 `leave-ret` 指令可以当做是一套组合拳，我们的上面的指令，可以分解为：
```
mov rsp,rbp;
pop rbp;
pop rip;
```


![[Pasted image 20240206113435.png]]


这个时候，我们思考能否有一种方式，能同时移动我们的 RBP 和我们的 RSP，这个时候，可以考虑这么一种方法，我们不管怎么样，我们去修改我们的 rbp，然后再用我们的 leave，ret 让我们的 rsp 也指向对应的位置。我们的方法是：在我们的 ret_add 位置添加一条指令，让他能够给出我们的一个结果。

现在，一个程序有栈溢出，我们要对他进行利用，现在的栈情况是：

![](https://pic4.zhimg.com/80/v2-d105b03773cfbbaebf747fdf1cc2988b_720w.webp)

当这个函数执行结束后，正常执行 leave 后，那么栈就会经历以下变化：
1. 执行了 mov esp, ebp

![](https://pic3.zhimg.com/80/v2-e9ff51ad32b4f826b9ad2dd68c6cbf9e_720w.webp)

2. 执行了 POP EBP

![](https://pic3.zhimg.com/80/v2-d8533de14a912c73bd5c23c412da5ed6_720w.webp)


这个时候ebp就指向了old_ebp，在正常流程中，这里就是指**被调用函数**执行完毕后，ebp会指向**调用函数**的基地址，进行后续的运行。在栈迁移中，我们自然不会正常的运行：如果我们将ret_add覆盖为gadget：`leave ; ret`的地址， 那么程序会经历如下变化：
第二次执行了 mov esp, ebp
![](https://pic2.zhimg.com/80/v2-0fb0c8df2a032986ca972e2591087e11_720w.webp)

第二次执行了 pop ebp

![](https://pic1.zhimg.com/80/v2-ec35206dde5478f35e1bb25a7965c64c_720w.webp)



这可以看到，ebp 这时候又指向了另一个位置，但这时候这个 ebp 位置是哪里已经不重要了，因为我们已经构建出了一个新的空间了，这时候**esp 所指向的地方即将 ret**，我们只用将进行攻击的 shellcode 等的地址覆盖到这里就可以了，这就是栈迁移的主要原理了。


也就是说，我们只要能获得我们的第一个的 `old_ebp`,我们就可以知道我们的 esp 指针指向了什么地方。然后我们就可以吧我们的 esp 指针当成一个新的 ret 漏洞来使用了。



之后，我们就可以利用我们的栈迁移进行任意地址写。因为我们的局部变量定位都是依靠我们的 rbp 指针进行定位的，具体可以参考下面的图片：
![[Pasted image 20240206121357.png]]

因此，我们在构造 payload 的时候，要注意我们的一个偏移量是多少。这一点，我们可以通过我们的 ida 来进行观察：
![[Pasted image 20240206121515.png]]

例如在这里，我们的偏移量就是我们的 `0x28`,
于是, 我们可以考虑按照这么一种方法构造我们的 payload
```
payload=b'a'+栈迁移目标地址+leave-ret指令
```

我们的栈迁移，主要适用于：给了我们一个很大的空间去进行我们的写入，但是在栈上允许读入的空间很少
