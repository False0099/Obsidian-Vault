第一步：我们用 `iDA` 找到我们的函数，查看我们的 `checksec`
![[Pasted image 20231208211323.png]]
![[Pasted image 20231208211331.png]]

第二步：分析函数逻辑，我们会写入我们的 `buf` ,并且把我们的 ` buf ` 中的数据来直接通过 `printf` 打印出来。最后，我们去打印我们的 `x`,如果我们的 `x==4`,那么我们就可以直接去执行我们的 `/bin/sh`

第三步：我们去找我们的 `x` 的内存在哪里，然后我们修改对应位置的数据是多少。这里，我们就可以利用我们格式化字符串中的 `%n` 。

第四步：确定思路后，我们就可以考虑我们的实现，我们首先要知道我们的 `格式化字符串` 的存储地址，相较于我们的 `printf`，是第几个参数？这里，我们要通过我们的 `动态调试` 来实现。

 我们首先找到我们的 `printf` 的地址, 这里我们的特征就是：我们的栈顶就是我们的对应地址，在这里就是我们的 `0xffffd190` 我们的 ` 'aaaaaaa' ` 所在的地址就是我们的 ` 格式化字符串所在的地址 `，在我们的图中就是我们的 ` 0xffffd1bc `,
通过计算，我们就能得到，我们之间相隔的距离是我们的 11，也就是说，`格式字符串所在的地址` 是我们的第 11 个参数
 ![[Pasted image 20231208211916.png]]
第五步：构造我们的 `payload`,这里，我们的内容就如下：
```text
payload=p32(你要修改的元素的地址)+b'%11$n'
```

注意：如果我们要输入我们的元素字节数超过我们的需求，我们就要用我们的 `c` 来为我们重新赋值