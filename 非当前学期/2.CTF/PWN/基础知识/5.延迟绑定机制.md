## 静态编译与动态编译：
我们以一个例子来介绍我们的静态编译和我们的动态编译。

我们的 A 希望开一个餐馆，餐馆的菜单上有上百种菜肴，餐馆每天都要来很多顾客，每个顾客点的菜都不一样（调用函数），我们知道，每道菜所需要的食材都不一样，这些食材都存放于仓库中（函数实现存放在 libc 中）。

那么现在，我们的餐馆怎么样，才能保证我们的每个菜都被满足？

我们有两种方式，第一种，把仓库中的**所有食材都搬进厨房**，这个时候，我们只需要在处方中就可以工作。（静态编译）

第二种：每一次**遇到需要的食材，才去仓库中取**，这个时候可能我们的搬动不叫频繁，但是我们的仓库里的废物就会便沙盘（动态编译）

### 静态编译：
我们的静态编译就是说，我们将**所有可能运行的库函数一同编译到可执行文件中**，有点事编译运行中不需要依赖动态链接库，适用于我们的本地编译的程序需要的动态链接库版本比较特殊。

### 动态编译;
我们的动态编译就是说：我们知道**遇到需要的库函数，我们再去动态链接库中找**。其优点是缩小了体积，加快了编译速度。缺点是哪怕只用到了链接库中的一部分命令，也需要附带一个庞大的链接库。

## 延迟绑定：
我们假设我们已经选择了**动态编译**，但是我们如果每一次都需要去我们的仓库去找新的食材，我们这样就会效率很低，我们可以考虑使用一个策略：

我们采用一个表格**got 表**存储我们的每一个**函数在 libc 中的地址**，这个就是我们的延迟绑定机制，我们的**got 表**全程叫做我们的 global offset table, 也就是我们的全局偏移量表。

在我们的程序运行时，我们的 got 表初始并不保存库函数的地址，只有在**第一次调用过后，程序才把这一个地址保存在 got 表当中**。

## PLT 与 GOT
GOT（全局偏移表）：GOT 表是数据段用于地址无关代码的 Linux ELF 文件中确定**全局变量和外部函数地址**的表。ELF 中有. Got 和. Plt. Got 两个表，其中我们的前者用于我们的全局变量的引用地址，后者用于我们的保存函数引用的地址。

PLT（程序连接表）：我们的 PLT 是 ELF 文件中用于延迟绑定的表。无论我们是第几次调用外部函数，我们程序**真正调用的其实是 plt 表**。我们的 plt 表**其实是由一段段汇编代码组成的**。（我们的 plt 表只是为了跳转到我们的 got 表）

第一步：在我们第一次调用外部函数时，PLT 表会首先跳到对应的 got 表项中，

第二步：因为我们的对应的外部函数**没有被调用过**，我们此时的**got**表中存储的地址是**PLT 表中的一端指令**，其作用是准备一些参数，再**跳转回 PLT 表**进行动态解析。

第三步：跳转回 PLT 表后，PLT 表又会转回 PLT 的表头，表头的内容就是**调用动态解析函数**，将**目标函数地址存放入 GOT 表中**。

第四步：这个时候，我们在进行**第二次或者以上的调用时，我们已经完成了延迟绑定**，我们而不用再去通过我们的其他的函数。直接跳转即可。

**具体的演示，我们可以通过我们的 ida 来进行静态分析**。当我们去查看我们的 `call printf` 我们其实是跳转到了我们的 `plt` 表格当中，这一个函数是一个 `jmp cs::off_601040`，也就是跳转到我们 `got.plt` 当中，也就是我们的**got 表中**