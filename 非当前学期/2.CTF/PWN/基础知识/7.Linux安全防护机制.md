在我们的 Linux 当中，我们总的来说存在有下面的五种保护机制，包括我们的 Canary, NX, ASLR, PIE, RELO。这五种机制。

在我们的 Linux 当中，我们可以通过我们的 `checksec xxx` 来查看对应程序的信息，例如：
![[eace867a5ce23916c7f43a9a443196f2.png]]


我们首先可以知道，我们的栈的作用是存储函数调用相关信息以及函数的局部变量。这些变量通常为数组或者输入的缓冲区，而函数调用相关的信息，主要是**返回地址和栈底指针**。
## CANARY
CANARY 直译叫做金丝雀，在我们的 LINUX 中，CANARY 的作用就是用来判断程序的执行环境。**主要针对于我们的栈溢出**。

我们的 CANARY 是一个开头字节为 `\x00` 的一端长度为八个字节的随机数，这个随机数本题存放于 fs 段偏移为 0 x28 的区域。

每一次函数调用中，程序都为把这个随机数存放于栈底，每次运行结束返回时，都会将这一个随机数和他的本体进行对比。

如果这个值发生改变，则意味着发生了栈溢出。我们的绕过基本思路就是**泄露 canary**或者**修改 canary**。我们**泄露 canary 的思路就是把我们的末尾\x 00 修改**让他可以被打印出来。

### 调试特征：
如果我们的一个程序开启了我们的 canary，那么我们再进行程序的编译的时候，就会产生一个 `__readfsqword(0x28u) ^ v3` 的返回值，显然，只有当我们的 v 3 的值和我们的对应的结果相同时，我们才会返回 0，否则我们一定返回 1.

### 关闭方式：
```
-fno-stack-protector
```
## NX 保护
我们的 NX 保护意思就是 `Not Executebale`,开启这个保护后，程序中的堆、栈、bss 段等可写的段就不可以执行。这就意味着如果开启了 `NX` 保护，通常情况下我们就不能执行自己编写的 shell code.

### 绕过思路：
我们的绕过思路通常是用 `mprotect` 函数来改写段的权限，nx 保护对于 rop 或者劫持 got 表利用方式不影响。

### 关闭方法：
```
-z execstack
```
## PIE
我们在编写 ROP 或者 shellcode 时，有一个问题是离不开的，那就是找到函数地址，PIE 指的就是**程序内存加载基地址随机化**，也就是说，我们的**程序间的顺序没有发生变化**，但是我们的程序的**起始位置发生改变**意味着我们不能一下子确定程序的基地址。

### 绕过思路：
我们的 PIE 的绕过思路也相对来说简单一些，就是通过我们的**泄露一个函数的地址，从而获取所有函数的地址**。

### 编写时关闭：
```
gcc xxx.c -o xxx -no-pie
```

## ASLR
ASLR 与之大同小异，ASLR 时**程序运行动态链接库，栈地址随机化**。也就是我们的**栈，堆，libc, ld**的地址都随机化。

### 绕过思路：
我们的 ASLR 与我们的 PIE 的绕过方式大同小异，都是找到一个函数，然后通过这一个函数找到我们的对应的内容。

### 关闭：
```
cat /proc/sys/kernel/radomize_va_space
如果变量是2
echo 0->/proc/sys/kernal/radomize_va_space
```

## RELO
我们的 RELO 保护只要是针对我们的延迟绑定机制，意思就是说 got 表这种和函数动态链接相关的内存地址，对于用户是只读的。
开启了这个保护，意味着我们不能劫持 got 表中的函数指针。