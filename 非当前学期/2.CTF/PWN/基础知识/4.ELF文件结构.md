在 Linux 环境中，二进制可执行文件的格式是 ELF (Executable and Linkable Format) 文件
ELF 文件的格式比较简单，我们需要了解的是 ELF 文件中的**各个节，各个段的具体含义**。
## 头部
elf 的基本信息存在于 elf 的头部信息中，这些信息包括指令的**运行架构，程序入口等等**，我们可以通过 readelf -h 来查看对应的信息。

其中就包括下面的信息：
1. Magic: 魔数，让我们的系统能够识别我们的 ELF 文件，我们的**所有的 ELF 文件都是相同的**
2. 类别：ELF 64
3. 数据：小端序还是大端序
..... 我们的详细信息还是可以通过我们的百度来找到。


## 节：
我们的 elf 文件中包含许多个节，各个节中存放不同的数据，这些节的信息存放在**节头表**中，我们可以通过 `read -s file` 来查看。其中我们的常见的节和他们的作用如下所示：
```
.text 存放程序运行的代码
.rdata 存放一些如字符串等不可修改的值("hello world")
.data 存放已经初始化的可修改的数据
.bss 存放未被初始化的程序可修改的数据
.plt与.
```

我们想具体查看每一个段的数据，可以通过我们的**ida->view->open subviews->segment**来查看我们的每一个段内都具体有哪些数据。

## 加载到内存
显然，我们的程序编译完成后是**存放在我们的磁盘当中的**，我们只有在运行的时候才会放入到我们的内存中，显然，我们在我们的**外村和内存中是两个样子的**，我们的加载存在有下面的规则：
1. elf 文件的节会被映射进内存中的段 (segment), 而这一映射过程遵循的机制是根据各个节的权限来进行映射的。
2. 换句话说，**可读可写的节被映射入一个段，只读的节被映射到一个段**。我们的可读可写的我们同意都叫做我们的 data, 我们的只读的统一都叫做我们的 code 段。

![[Pasted image 20240710220847.png]]

**补充：在我们的栈段和我们的堆段之间存在一个位置，用于存放我们的动态链接库**

我们想要查看我们的**内存中的程序，我们可以同构我们的**`gdb->mmap`

同时，我们注意到，我们的途中存在有下面的含义：
1. `rwxp`,其中 r 代表我们可读，我们的 w 表示我们可写，我们的 x 表示我们可以执行，我们的 p 表示我们
2. 我们的每一个段的后 12 位都是以 000 结束的，这是因为我们**操作系统分配一个段的时候都是按页分配的，而我们的每一个页都是 1000**大小的。
![[Pasted image 20231201204124.png]]
## LIBC
在我们的文章中，我们发现，我们存在一些东西形如：
`/usr/lib/x86_64-linux-gnu/libc-2.31.so`，我们的 glibc 是我们的 linux 下面的 C 标准库的**实现**，也就是我们的 `GNU C Library`，

其中我们的 `libc-2.31.so`**本质上也是一个 ELF 文件**，他也是可以运行的，运行的结果只是打印对应的信息。

我们的 linux 中的所有程序都依赖于我们的 libc，所以 libc 中的函数至关重要，我们在必要的时候，**可以通过我们的 ida 来分析我们额 libc**。也就是说，我们的**大部分源码都是在我们的 LIBC 当中的**。

例如：我们的程序开发过程中，都会用带我们的系统函数，比如 `read write open` 等等，这些系统函数不需要我们去实现，系统已经帮助我们完成了这些工作，只需要调用即可。存放这些函数的库文件就是动态链接库。**也就是我们的 LIBC**。