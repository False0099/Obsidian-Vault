省流：PLT 表表用于我们的 `ret2text`,GOT 表用于我们的 `ret2libc`。

关于动态链接与静态链接，可以打个比方就是：如果我的文章引用了别人的一部分文字，在我发布文章的时候把别人的段落复制到我的文章里面就属于静态连接，而做一个超链接让你们自己去看就属于动态链接了

首先，在我们的每一个系统中，我们都是自带一个 `glib` 表的，这个表中存储了我们的所有的函数的源代码（包括 `system,puts` 等等等等）

而当我们使用动态链接，在运行某一个函数的时候，我们的系统会（随机）先把对应的位置给添加上对应的占位符。

现在问题来了，我们的代码段一旦添加是没有办法修改的，我们应该怎么办才能找到我们的真正的代码的位置呢？

在这里，我们的链接器会额外生成一小段代码，通过这样，我们就能获得我们的 `printf()` 的地址，然后，我们再去进行重定位。具体来说, 我们会采用一种类似于我们的 `rop` 链的方式，把我们的真正的地址写在我们的 data 段段中，然后我们再去从 data 段里读数据即可：

```cpp
.text
...

// 调用printf的call指令
call printf_stub
...
printf_stub:
    mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址
    jmp rax // 跳过去执行printf函数

.data
...
printf函数的储存地址,这里储存printf函数重定位后的地址
```

也就是说，我们的一个动态链接需要我们的两个过程：
第一个是我们用来存放外部函数地址的数据段
第二个是我们用来获取数据段记录的外部函数地址的代码。

对应了两个表，一个是我们的**全局偏移表（GOT）**，另一个是我们的**程序链接表（PLT）**. 也就是说，我们的 PLT 表中表中存放的是一个程序，只要执行了这个程序，我们就能找到我们的所对应的数据。我们的 GOT 表中存放的是我们的“真实地址”