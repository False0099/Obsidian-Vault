我们的计算机不能够直接运行我们的高级语言，我们编写的高级语言程序需要进行编译后才能在计算机上玉兴。高级语言经过编译之后，经过编译器处理，被打包为一个可执行文件的格式。而计算机**真正可以执行的**是我们的**机器码**。

我们知道，我们的计算机**只能够执行我们的 16 进制数字**，因此，我们为了能够提升我们的可读性，我们将我们的**机器码**转换为我们的**汇编语言**，因此我们的汇编语言，就是我们的**机器码的助记符**。

同时，我们的计算机的指令都是通过我们的 CPU 来执行的，在我们的计算机体系结构中，我们的 CPU 和内存是分开的。**寄存器在 CPU 当中**。

我们的寄存器种类包括有：
1. 通用寄存器：`RAX.RBX,RCX,RDX,RDI,RSI,R8,R9,`，当然如果我们在我们的 32 位系统中，因为我们的位数不同了，所以我们的**寄存器也会被分成两个**，一个名字叫做 `E.X`,另一个叫做 `.A`。
2. 栈顶指针 `RSP`，同时，我们的低 32 位叫做我们的 `ESP`
3. 栈底指针 `RBP`，同时，我们的第三十二位基座我们的 `EBP`
4. 标志寄存器 `EFLAGS` ,巨鹿我们的状态情况
5. 指令计数器 `RIP`，保存我们下一条将要执行的指令的地址。我们没执行完一条指令，我们的对应的值都会**自动加指向下一条**，也就是说，我们的 RIP 就相当于我们的下一条指令、
## 基本量词
在我们的计算机中，我们存在有下面的基本量词，例如我们的 bit（比特），byte (字节, 8 位)，word（字，16 位, char），dword（双字, 32 位, int），qword（四字, 64 位, long long）

而在当前的主流的操作系统当中，都是以**字节**（B），为单位进行寻址的。意味着，我们的**一个地址对应的是一个字节的数据，也就是 8bit**。

## 寻址方式：
加一个 `[]`,就相当于要去进行一个取地址操作。

在我们的计算机中，我们存在有**立即寻址**，**直接寻址**，**寄存器寻址**，**寄存器间接寻址**，**变址寻址**。五种方式来找到我们的对应的地址，我们的物种地址对应的汇编语言格式如下所示；
立即寻址：`1234h`,我们的实际地址就是我们的数字本身，也就是说我们需要的**数据就是我们的 1234**
直接寻址：`[1234h]`，我们要访问的**内存地址**就是我们的 1234h，我们需要的**数据就是我们的 1234h 地址里的字节**。

寄存器寻址：`RAX`，我们要访问的寄存器就是我们的 `RAX`，我们需要的
寄存器间接寻址 : `[RAX]`,我们要访问 `RAX` 这一个寄存器存储的值的这一个**内存地址**
变址寻址：`[RAX+1234h]`,访问 RAX 寄存器存储的值+1234h 这一个内存地址


## 汇编指令：
我们的汇编指令基本上存在有两种格式：intel 和 AT&T，两者的差别主要在于源和目的操作数顺序上。可以通过立即数寻址来进行判断。
1. MOV 指令
数据传送指令，相当于我们的赋值语句, 让我们的**左侧的元素等于我们的右侧的元素**、
```
mov eax,1234H (给我们的EAX赋值为1234H)
mov ebx,eax (给我们的EBX赋值为EAX)
=>eax=1234h,ebx=eax;
```

2. Lea 指令:
取地址指令，**同样相当我们的一个赋值指令**，让我们的**左侧元素等于右侧元素的地址**。
```
lea rax [rbx]
->rax=&*rbx
```

3. SUB 指令
进行我们的**减法**指令，让我们的左侧的数减去我们的右侧的数字。
```
sub eps,14H (给我们eps中的值减去14H)
```

4. ADD 指令
进行我们的**加法**指令，让我们的左侧的数减去我们的右侧的数字。
```
add esp,14H(给我们的ESP的值加上14)
```

5. and 指令
进行我们的逻辑与指令，让我们的左侧的数**等于我们的两数与运算的结果**。
```
and rax rbx->(rax=rax&rbx)
```

6. or 指令；
进行我们的逻辑或指令，让我们的左侧的数**等于我们的两数或运算的结果**。
```
or rax rbx->(rax=rax|rbx);
```

7. Call 指令：
进行我们的函数调用，指令我们的**内存地址为 1234 地址的函数**。例如我们要调用我们的 printf 语句
```
call 1234h->执行1234处的函数
```

8. ret 指令：
进行我们的函数返回，终止我们的当前函数，回到我们的**调用函数**。
```
ret
```

9. Cmp 指令：
进行我们的函数比较，比较我们的 rax 和 rbx，结果保存在我们的寄存器当中
```
cmp rax rbx
```

10. Jmp 指令：
进行我们的无条件跳转，让我们的函数跳转到我们的对应的函数地址。(jump 语句只能是类似于我们的 ifelse 语句，而不能作为函数调用来使用)
```
jump 1234h->goto a
```

11. Push 指令：
将我们的某一个元素的值压入我们的**函数栈**，
```
push rax 将rax的值压入栈
```

12. pop 指令：
将我们的某一个元素的值付给我们的 rax，同时让我们的战中的元素移动，**注意我们的栈顶的指针是+8**。
```
pop rax 将栈顶的值赋给rax，rsp+=8
```

例如：我们的 C 语言程序有：
```
int i=0;
while(i<100){
	i++;
}
i=0;
```

转换为我们的汇编语言就有：
```
move rax 0
label1:
inc rax;
cmp rax 100;
jge label2;
jmp label1;
label2;
mov rax 0;
```

## 数：
在我们的计算机中，无论我们的数据是以二进制或者我们的十进制的方式表示，本质都是代表一个数。我们的计算机不能够存储我们的无限的数字，我们能够存储的数字都是有限的。我们的常见的类型和大小如下：
```
char 8bit 
int 32bit
long long 64bit
```