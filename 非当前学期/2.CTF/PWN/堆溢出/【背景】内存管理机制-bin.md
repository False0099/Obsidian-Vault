概述：我们的 bin 其实可以理解为我们的一个 `h[N]` 数组，用于存储我们的每一个对应的大小对应的块有哪些，

释放状态的堆块会被放入 bin 中，而我们的 bin 也会分为我们的下面三类：
**Fastbin**: 处理 size 较小的 chunk
**unsortedbin**：chunk 回归其所属 bin 之前的缓冲区
**Smallbin**: 处理大小范围在 2-63 的 chunk
**Largebin**: 遵循 FIFO 策略的循环双向链表
## fastbin
**fastbin**是一个单向链表，并且每个 bin 采取了 LIFO 策略，最近释放的 chunk 会被更早地分配。所以当**用户申请的 chunk 大小在 fast bin 范围内**时，ptmalloc 会首先判断 fast bin 中是否有对应大小的空闲 chunk，有的话就会直接分配出去。（没有容量上限）

Fastbin 中的不能被切割，

1. 工作原理：相当于给我们的每一个块进行了一个标记，标记后的块就相当于我们不能够使用，我们会直接吧我们的对应块的地址放到我们的 `bin` 中。
2. 当我们要新开一个空间是，我们首先可以在我们的 `bin` 中找我们是否有满足条件的块，能够把我们的这个块分配给我们的这个请求，这个时候，我们的 `fastbin` 里就会有一个结构，表示我们满足我们大小要求的有哪些，
![[Pasted image 20231212125343.png]]
![[Pasted image 20231212125411.png]]
这里就是我们的**逻辑链表**。

总结：`fastbin` 起始是起到了一个集市的作用，如果你想要某个快的时候，

## Unsorted bin
对于其他的**bin**, 他们的头节点都有两个标记位置，他们都是由双向链表构成的。其中，我们的 `chunck` 节点中，就有我们的 `bk` 指向我们的前一个结点，我们的 `fd` 就指向我们的下一个结点。
我们的头节点也有一个**双向链表，我们就能构成一个环**
![[Pasted image 20231212130409.png]]


![[Pasted image 20240203170333.png]]
我们的 bk 就会指向我们的一个 p_s 指针，链表结构如下所示：
![[Pasted image 20240203170831.png]]

`arena` 的控制结构
`arena` 的控制头部相关文件：
![[Pasted image 20231212131040.png]]

## Unsorted bin
我们可以把这个看做空闲的 chunk 回归其




## Tcache bin
这是一种出现在 libc-2.26 之后的堆管理方式，可以用来存放 0-0 x 400 大小的 chunk。（最多只能存放七个，超过 7 个就放入 fastbin 或者 unsorted bin）

我们的 cache 的加入是通过我们的一个头插法来实现的。而在取空间的时候，是通过我们的 FIFO 原则。


![[Pasted image 20240211110413.png]]