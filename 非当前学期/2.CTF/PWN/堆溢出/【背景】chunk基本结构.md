我们的堆块宏观上来说可以分为两个部分来介绍，第一个部分是我们的堆块的内部结构。

第二个部分是管理堆块的相关结构和工具，

### 堆块的基本结构：
我们的一个堆块，由我们的 `pre_size` 位，`size` 位，`user_data` 位构成，
![[Pasted image 20240203165622.png]]
#### Pre_size:
用于标志我们前一个堆块的大小的，**只有在前一个堆块处在释放状态**的时候，才会标识（因此，我们直球覆盖也没有用）

处于使用状态的堆块可以使用下一个堆块的 `prev_size`,这就是堆块的复用机制。
例如：当我们要申请一个 `0x28` 大小的空间，而我们 `chunck` 的单位只是我们的 `0x20`,, 那么我们会把我们下一个块的 `prev` 指针，也当作我们的数据去使用
#### Size:
用于我们的一个信息显示和对应表示，其中的 AMP 位中 P 位最为重要。

P 位的作用是表示前一个堆块是出于**释放状态或者是处于使用状态**，如果是处于使用，那么我们的最后一位就是 1，也就是说，我们能这里的 size= `0x61` 并不代表我们的真实大小是 `0x61`, 其实我们的真实大小是我们的 ` 0x60 `,最后显示为 ` 0x61 ` 只是因为我们的标记位发力了。

M 位的作用是表示我们该堆块是否是 `mmap` 申请而来的。

A 位标识是否是主 `main_arena` 分配的。

#### UserData 
存储用户实际能够使用的值是多少。**在我们的内存被释放后，我们的对应位置会退化为一个 fd 指针，当中就存储了我们下一个块的位置**


## 内存管理机制-

### 单向链表 bin
我们的 bin 分为我们的单项链表 bin 和双向链表 bin。其中我们的双向链表 bin 就有：`unsorted bin`, `small bin`

我们的 `large bin` 就是有两个双向链表

我们的 `bin` 类似于单向循环链表，我们的 `bin` 是头结点。

我们就有：`bin->free chunk1->free chunk2->free chunk3`


### 双向链表 bin
这是，我们的堆块结构如下所示：

## 


3. 在我们调用我们的 `malloc` 函数之前，我们的动态管理器，甚至我们的堆段是并没有初始化的，直到我们的 `malloc` 执行完毕后，我们才完成。
![[Pasted image 20231211202432.png]]
3. 我们想要直到我们的最小的 `malloc` 能申请多少，我们就可以用我们的 `fastbin` 来查询。
4. 
5. 